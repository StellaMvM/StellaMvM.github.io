const Ph = function () { 
    const t = document.createElement("link").relList; 
    return t && t.supports && t.supports("modulepreload") ? "modulepreload" : "preload" }
    () , da = {}, Ah = "/", 
    ll = function (t, n) { 
        return !n || n.length === 0 ? t() : Promise.all(
            n.map(o => { 
                if (o = `${Ah}${o}`, o in da) 
                return; 
                da[o] = !0; 
                const r = o.endsWith(".css"), i = r ? '[rel="stylesheet"]' : ""; 
                if (document.querySelector(`link[href="${o}"]${i}`)) 
                return; 
                const s = document.createElement("link"); 
                if (s.rel = r ? "stylesheet" : Ph, r || (s.as = "script", s.crossOrigin = ""), s.href = o, document.head.appendChild(s), r) 
                return new Promise((l, a) => { 
                    s.addEventListener("load", l), s.addEventListener("error", () => a(new Error(`Unable to preload CSS for ${o}`))) 
                }) 
            })).then(() => t()) }; 
            function al(e, t) { 
                const n = Object.create(null), o = e.split(","); 
                for (let r = 0; r < o.length; r++)n[o[r]] = !0; 
                return t ? r => !!n[r.toLowerCase()] : r => !!n[r] 
            } 
            function Ar(e) { 
                if (_e(e)) { 
                    const t = {}; 
                    for (let n = 0; n < e.length; n++) { 
                        const o = e[n], r = Ye(o) ? $h(o) : Ar(o);
                        if (r) 
                        for (const i in r) t[i] = r[i] 
                    } 
                    return t 
                } else { 
                    if (Ye(e)) 
                    return e; 
                    if (De(e)) return e 
                } 
            } 
            const Oh = /;(?![^(]*\))/g, Rh = /:([^]+)/, Lh = /\/\*.*?\*\//gs; 
            function $h(e) { 
                const t = {};
                return e.replace(Lh, "").split(Oh).forEach(n => { 
                    if (n) { 
                        const o = n.split(Rh); 
                        o.length > 1 && (t[o[0].trim()] = o[1].trim()) 
                    } 
                }), t 
            } 
            function Or(e) { 
                let t = ""; 
                if (Ye(e)) 
                t = e; 
                else if (_e(e)) 
                for (let n = 0; n < e.length; n++) { 
                    const o = Or(e[n]);
                     o && (t += o + " ") 
                    } else if (De(e)) 
                    for (const n in e) 
                    e[n] && (t += n + " "); 
                    return t.trim() 
                } 
                const Mh = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Bh = al(Mh);
                function kc(e) { 
                    return !!e || e === "" 
                } 
                const tr = e => Ye(e) ? e : e == null ? "" : _e(e) || De(e) && (e.toString === Tc || !Se(e.toString)) ? JSON.stringify(e, Sc, 2) : String(e), Sc = (e, t) => t && t.__v_isRef ? Sc(e, t.value) : ho(t) ? 
                { 
                    [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, r]) => (n[`${o} =>`] = r, n), {}) 
                } : Ec(t) ? { 
                    [`Set(${t.size})`]: [...t.values()] 
                } : De(t) && !_e(t) && !Pc(t) ? String(t) : t, je = {}, fo = [], Dt = () => { }, Ih = () => !1, Fh = /^on[^a-z]/, qi = e => Fh.test(e), ul = e => e.startsWith("onUpdate:"), st = Object.assign, cl = (e, t) => 
                { 
                    const n = e.indexOf(t); n > -1 && e.splice(n, 1) 
                }, 
                zh = Object.prototype.hasOwnProperty, 
                Ae = (e, t) => zh.call(e, t), 
                _e = Array.isArray, 
                ho = e => Ti(e) === "[object Map]", 
                Ec = e => Ti(e) === "[object Set]", 
                Se = e => typeof e == "function", 
                Ye = e => typeof e == "string", 
                dl = e => typeof e == "symbol", 
                De = e => e !== null && typeof e == "object", 
                qc = e => De(e) && Se(e.then) && Se(e.catch), 
                Tc = Object.prototype.toString, 
                Ti = e => Tc.call(e), 
                Vh = e => Ti(e).slice(8, -1), 
                Pc = e => Ti(e) === "[object Object]", 
                fl = e => Ye(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, 
                Xr = al(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), 
                Pi = e => { 
                    const t = Object.create(null); 
                    return n => t[n] || (t[n] = e(n)) 
                }, 
                Nh = /-(\w)/g, 
                Xt = Pi(e => e.replace(Nh, (t, n) => n ? n.toUpperCase() : "")), 
                jh = /\B([A-Z])/g, 
                Po = Pi(e => e.replace(jh, "-$1").toLowerCase()), 
                Ai = Pi(e => e.charAt(0).toUpperCase() + e.slice(1)), 
                ts = Pi(e => e ? `on${Ai(e)}` : ""), 
                hr = (e, t) => !Object.is(e, t), 
                nr = (e, t) => { 
                    for (let n = 0; n < e.length; n++)
                    e[n](t) 
                }, 
                ai = (e, t, n) => { 
                    Object.defineProperty(e, t, { 
                        configurable: !0, enumerable: !1, value: n 
                    }) 
                }, 
                hl = e => { 
                    const t = parseFloat(e); 
                    return isNaN(t) ? e : t 
                }; 
                let fa; 
                const Dh = () => fa || (fa = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : {}); 
                let wt; 
                class Ac { 
                    constructor(t = !1) { 
                        this.detached = t, 
                        this.active = !0, 
                        this.effects = [], 
                        this.cleanups = [], 
                        this.parent = wt, 
                        !t && wt && (this.index = (wt.scopes || (wt.scopes = [])).push(this) - 1) 
                    } 
                    run(t) { 
                        if (this.active) { 
                            const n = wt; 
                            try { 
                                return wt = this, t() 
                            } 
                            finally { 
                                wt = n 
                            } 
                        } 
                    } 
                    on() { 
                        wt = this 
                    } 
                    off() { 
                        wt = this.parent 
                    } 
                    stop(t) { 
                        if (this.active) { 
                            let n, o; 
                            for (n = 0, o = this.effects.length; n < o; n++)
                            this.effects[n].stop(); 
                            for (n = 0, o = this.cleanups.length; n < o; n++)
                            this.cleanups[n](); 
                            if (this.scopes) 
                            for (n = 0, o = this.scopes.length; n < o; n++)
                            this.scopes[n].stop(!0); 
                            if (!this.detached && this.parent && !t) { 
                                const r = this.parent.scopes.pop(); 
                                r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) 
                            } 
                            this.parent = void 0, this.active = !1 
                        } 
                    } 
                } 
                function Oc(e) { 
                    return new Ac(e) 
                } 
                function Hh(e, t = wt) { 
                    t && t.active && t.effects.push(e) 
                } 
                function Kh() { 
                    return wt 
                } 
                function Uh(e) { 
                    wt && wt.cleanups.push(e) 
                } 
                const ml = e => { 
                    const t = new Set(e); 
                    return t.w = 0, t.n = 0, t 
                }, 
                Rc = e => (e.w & Tn) > 0, 
                Lc = e => (e.n & Tn) > 0, 
                Wh = ({ deps: e }) => { 
                    if (e.length) 
                    for (let t = 0; t < e.length; t++)
                    e[t].w |= Tn 
                }, 
                Qh = e => { const { deps: t } = e; 
                if (t.length) { 
                    let n = 0; 
                    for (let o = 0; o < t.length; o++) {
                        const r = t[o]; 
                        Rc(r) && !Lc(r) ? r.delete(e) : t[n++] = r, r.w &= ~Tn, r.n &= ~Tn 
                    } 
                    t.length = n 
                } 
            }, 
            Ps = new WeakMap; 
            let Yo = 0, Tn = 1; 
            const As = 30; 
            let Nt; 
            const Hn = Symbol(""), Os = Symbol(""); 
            class vl { 
                constructor(t, n = null, o) { 
                    this.fn = t, 
                    this.scheduler = n, 
                    this.active = !0, 
                    this.deps = [], 
                    this.parent = void 0, 
                    Hh(this, o) 
                } 
                run() { 
                    if (!this.active) 
                    return this.fn(); 
                    let t = Nt, n = Sn; 
                    for (; t;) { 
                        if (t === this) 
                        return; 
                        t = t.parent 
                    } 
                    try { 
                        return this.parent = Nt, Nt = this, Sn = !0, Tn = 1 << ++Yo, Yo <= As ? Wh(this) : ha(this), this.fn() 
                    } 
                    finally { 
                        Yo <= As && Qh(this), 
                        Tn = 1 << --Yo, Nt = this.parent, 
                        Sn = n, 
                        this.parent = void 0, 
                        this.deferStop && this.stop() 
                    } 
                } 
                stop() { 
                    Nt === this ? this.deferStop = !0 : this.active && (ha(this), this.onStop && this.onStop(), this.active = !1) 
                } 
            } 
            function ha(e) { 
                const { deps: t } = e; 
                if (t.length) { 
                    for (let n = 0; n < t.length; n++)
                    t[n].delete(e); 
                    t.length = 0 
                } 
            } 
            let Sn = !0; 
            const $c = []; 
            function Ao() { 
                $c.push(Sn), Sn = !1 
            } 
            function Oo() { 
                const e = $c.pop(); 
                Sn = e === void 0 ? !0 : e 
            } 
            function kt(e, t, n) { 
                if (Sn && Nt) { 
                    let o = Ps.get(e); 
                    o || Ps.set(e, o = new Map); 
                    let r = o.get(n); 
                    r || o.set(n, r = ml()), Mc(r) 
                } 
            } 
            function Mc(e, t) { 
                let n = !1; 
                Yo <= As ? Lc(e) || (e.n |= Tn, n = !Rc(e)) : n = !e.has(Nt), 
                n && (e.add(Nt), Nt.deps.push(e)) 
            } 
            function cn(e, t, n, o, r, i) { 
                const s = Ps.get(e); 
                if (!s) return; 
                let l = []; 
                if (t === "clear") 
                l = [...s.values()]; 
                else if (n === "length" && _e(e)) { 
                    const a = hl(o); 
                    s.forEach((c, u) => { (u === "length" || u >= a) && l.push(c) }) 
                } else 
                switch (n !== void 0 && l.push(s.get(n)), t) {
                    case "add": 
                    _e(e) ? fl(n) && l.push(s.get("length")) : (l.push(s.get(Hn)), 
                    ho(e) && l.push(s.get(Os))); 
                    break; 
                    case "delete": 
                    _e(e) || (l.push(s.get(Hn)), ho(e) && l.push(s.get(Os))); 
                    break; 
                    case "set": 
                    ho(e) && l.push(s.get(Hn)); 
                    break 
                }
                if (l.length === 1) 
                l[0] && Rs(l[0]); 
                else { 
                    const a = []; 
                    for (const c of l) 
                    c && a.push(...c); Rs(ml(a)) 
                } 
            } 
            function Rs(e, t) { 
                const n = _e(e) ? e : [...e]; 
                for (const o of n) 
                o.computed && ma(o); 
                for (const o of n) 
                o.computed || ma(o) 
            } 
            function ma(e, t) { 
                (e !== Nt || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()) 
            } 
            const Gh = al("__proto__,__v_isRef,__isVue"), 
            Bc = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(dl)), 
            Zh = pl(), 
            Yh = pl(!1, !0), Jh = pl(!0), 
            va = Xh(); 
            function Xh() { 
                const e = {}; 
                return ["includes", "indexOf", "lastIndexOf"].forEach(t => { 
                    e[t] = function (...n) { 
                        const o = ke(this); 
                        for (let i = 0, s = this.length; i < s; i++)
                        kt(o, "get", i + ""); 
                        const r = o[t](...n); 
                        return r === -1 || r === !1 ? o[t](...n.map(ke)) : r 
                    } 
                }), 
                ["push", "pop", "shift", "unshift", "splice"].forEach(t => { 
                    e[t] = function (...n) { 
                        Ao(); 
                        const o = ke(this)[t].apply(this, n); return Oo(), o 
                    } 
                }), 
                e 
            } 
            function pl(e = !1, t = !1) { 
                return function (o, r, i) { 
                    if (r === "__v_isReactive") 
                    return !e; 
                    if (r === "__v_isReadonly") 
                    return e; 
                    if (r === "__v_isShallow") 
                    return t; 
                    if (r === "__v_raw" && i === (e ? t ? vm : Nc : t ? Vc : zc).get(o)) 
                    return o; 
                    const s = _e(o); 
                    if (!e && s && Ae(va, r)) 
                    return Reflect.get(va, r, i); 
                    const l = Reflect.get(o, r, i); 
                    return (dl(r) ? Bc.has(r) : Gh(r)) || (e || kt(o, "get", r), t) ? l : Ze(l) ? s && fl(r) ? l : l.value : De(l) ? e ? jc(l) : Ot(l) : l 
                } 
            } 
            const em = Ic(), tm = Ic(!0); 
            function Ic(e = !1) { 
                return function (n, o, r, i) { 
                    let s = n[o]; 
                    if (_o(s) && Ze(s) && !Ze(r)) 
                    return !1; 
                    if (!e && (!ui(r) && !_o(r) && (s = ke(s), r = ke(r)), !_e(n) && Ze(s) && !Ze(r))) 
                    return s.value = r, !0; 
                    const l = _e(n) && fl(o) ? Number(o) < n.length : Ae(n, o), a = Reflect.set(n, o, r, i); 
                    return n === ke(i) && (l ? hr(r, s) && cn(n, "set", o, r) : cn(n, "add", o, r)), a 
                } 
            } 
            function nm(e, t) { 
                const n = Ae(e, t); 
                e[t]; 
                const o = Reflect.deleteProperty(e, t); 
                return o && n && cn(e, "delete", t, void 0), o 
            } 
            function om(e, t) { 
                const n = Reflect.has(e, t); 
                return (!dl(t) || !Bc.has(t)) && kt(e, "has", t), n 
            } 
            function rm(e) { 
                return kt(e, "iterate", _e(e) ? "length" : Hn), Reflect.ownKeys(e) 
            } 
            const Fc = { 
                get: Zh, 
                set: em, 
                deleteProperty: nm, 
                has: om, 
                ownKeys: rm 
            }, 
            im = { 
                get: Jh, 
                set(e, t) { return !0 }, 
                deleteProperty(e, t) { return !0 } 
            }, 
            sm = st({}, Fc, { get: Yh, set: tm }), 
            gl = e => e, 
            Oi = e => Reflect.getPrototypeOf(e); 
            function Fr(e, t, n = !1, o = !1) { 
                e = e.__v_raw; const r = ke(e), i = ke(t); n || (t !== i && kt(r, "get", t), kt(r, "get", i)); const { has: s } = Oi(r), l = o ? gl : n ? _l : mr; if (s.call(r, t)) return l(e.get(t)); if (s.call(r, i)) return l(e.get(i)); e !== r && e.get(t) } function zr(e, t = !1) { const n = this.__v_raw, o = ke(n), r = ke(e); return t || (e !== r && kt(o, "has", e), kt(o, "has", r)), e === r ? n.has(e) : n.has(e) || n.has(r) } function Vr(e, t = !1) { return e = e.__v_raw, !t && kt(ke(e), "iterate", Hn), Reflect.get(e, "size", e) } function pa(e) { e = ke(e); const t = ke(this); return Oi(t).has.call(t, e) || (t.add(e), cn(t, "add", e, e)), this } function ga(e, t) { t = ke(t); const n = ke(this), { has: o, get: r } = Oi(n); let i = o.call(n, e); i || (e = ke(e), i = o.call(n, e)); const s = r.call(n, e); return n.set(e, t), i ? hr(t, s) && cn(n, "set", e, t) : cn(n, "add", e, t), this } function ya(e) { const t = ke(this), { has: n, get: o } = Oi(t); let r = n.call(t, e); r || (e = ke(e), r = n.call(t, e)), o && o.call(t, e); const i = t.delete(e); return r && cn(t, "delete", e, void 0), i } function ba() { const e = ke(this), t = e.size !== 0, n = e.clear(); return t && cn(e, "clear", void 0, void 0), n } function Nr(e, t) { return function (o, r) { const i = this, s = i.__v_raw, l = ke(s), a = t ? gl : e ? _l : mr; return !e && kt(l, "iterate", Hn), s.forEach((c, u) => o.call(r, a(c), a(u), i)) } } function jr(e, t, n) { return function (...o) { const r = this.__v_raw, i = ke(r), s = ho(i), l = e === "entries" || e === Symbol.iterator && s, a = e === "keys" && s, c = r[e](...o), u = n ? gl : t ? _l : mr; return !t && kt(i, "iterate", a ? Os : Hn), { next() { const { value: d, done: f } = c.next(); return f ? { value: d, done: f } : { value: l ? [u(d[0]), u(d[1])] : u(d), done: f } }, [Symbol.iterator]() { return this } } } } function vn(e) { return function (...t) { return e === "delete" ? !1 : this } } function lm() { const e = { get(i) { return Fr(this, i) }, get size() { return Vr(this) }, has: zr, add: pa, set: ga, delete: ya, clear: ba, forEach: Nr(!1, !1) }, t = { get(i) { return Fr(this, i, !1, !0) }, get size() { return Vr(this) }, has: zr, add: pa, set: ga, delete: ya, clear: ba, forEach: Nr(!1, !0) }, n = { get(i) { return Fr(this, i, !0) }, get size() { return Vr(this, !0) }, has(i) { return zr.call(this, i, !0) }, add: vn("add"), set: vn("set"), delete: vn("delete"), clear: vn("clear"), forEach: Nr(!0, !1) }, o = { get(i) { return Fr(this, i, !0, !0) }, get size() { return Vr(this, !0) }, has(i) { return zr.call(this, i, !0) }, add: vn("add"), set: vn("set"), delete: vn("delete"), clear: vn("clear"), forEach: Nr(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(i => { e[i] = jr(i, !1, !1), n[i] = jr(i, !0, !1), t[i] = jr(i, !1, !0), o[i] = jr(i, !0, !0) }), [e, n, t, o] } const [am, um, cm, dm] = lm(); function yl(e, t) { const n = t ? e ? dm : cm : e ? um : am; return (o, r, i) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? o : Reflect.get(Ae(n, r) && r in o ? n : o, r, i) } const fm = { get: yl(!1, !1) }, hm = { get: yl(!1, !0) }, mm = { get: yl(!0, !1) }, zc = new WeakMap, Vc = new WeakMap, Nc = new WeakMap, vm = new WeakMap; function pm(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function gm(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : pm(Vh(e)) } function Ot(e) { return _o(e) ? e : bl(e, !1, Fc, fm, zc) } function ym(e) { return bl(e, !1, sm, hm, Vc) } function jc(e) { return bl(e, !0, im, mm, Nc) } function bl(e, t, n, o, r) { if (!De(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const i = r.get(e); if (i) return i; const s = gm(e); if (s === 0) return e; const l = new Proxy(e, s === 2 ? o : n); return r.set(e, l), l } function En(e) { return _o(e) ? En(e.__v_raw) : !!(e && e.__v_isReactive) } function _o(e) { return !!(e && e.__v_isReadonly) } function ui(e) { return !!(e && e.__v_isShallow) } function Dc(e) { return En(e) || _o(e) } function ke(e) { const t = e && e.__v_raw; return t ? ke(t) : e } function it(e) { return ai(e, "__v_skip", !0), e } const mr = e => De(e) ? Ot(e) : e, _l = e => De(e) ? jc(e) : e; function Hc(e) { Sn && Nt && (e = ke(e), Mc(e.dep || (e.dep = ml()))) } function Kc(e, t) { e = ke(e), e.dep && Rs(e.dep) } function Ze(e) { return !!(e && e.__v_isRef === !0) } function z(e) { return Uc(e, !1) } function bm(e) { return Uc(e, !0) } function Uc(e, t) { return Ze(e) ? e : new _m(e, t) } class _m { constructor(t, n) { this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : ke(t), this._value = n ? t : mr(t) } get value() { return Hc(this), this._value } set value(t) { const n = this.__v_isShallow || ui(t) || _o(t); t = n ? t : ke(t), hr(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : mr(t), Kc(this)) } } function Kn(e) { return Ze(e) ? e.value : e } const wm = { get: (e, t, n) => Kn(Reflect.get(e, t, n)), set: (e, t, n, o) => { const r = e[t]; return Ze(r) && !Ze(n) ? (r.value = n, !0) : Reflect.set(e, t, n, o) } }; function Wc(e) { return En(e) ? e : new Proxy(e, wm) } function Cm(e) { const t = _e(e) ? new Array(e.length) : {}; for (const n in e) t[n] = Zn(e, n); return t } class xm { constructor(t, n, o) { this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0 } get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } } function Zn(e, t, n) { const o = e[t]; return Ze(o) ? o : new xm(e, t, n) } var Qc; class km { constructor(t, n, o, r) { this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[Qc] = !1, this._dirty = !0, this.effect = new vl(t, () => { this._dirty || (this._dirty = !0, Kc(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = o } get value() { const t = ke(this); return Hc(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value } set value(t) { this._setter(t) } } Qc = "__v_isReadonly"; function Sm(e, t, n = !1) { let o, r; const i = Se(e); return i ? (o = e, r = Dt) : (o = e.get, r = e.set), new km(o, r, i || !r, n) } function qn(e, t, n, o) { let r; try { r = o ? e(...o) : e() } catch (i) { Ri(i, t, n) } return r } function $t(e, t, n, o) { if (Se(e)) { const i = qn(e, t, n, o); return i && qc(i) && i.catch(s => { Ri(s, t, n) }), i } const r = []; for (let i = 0; i < e.length; i++)r.push($t(e[i], t, n, o)); return r } function Ri(e, t, n, o = !0) { const r = t ? t.vnode : null; if (t) { let i = t.parent; const s = t.proxy, l = n; for (; i;) { const c = i.ec; if (c) { for (let u = 0; u < c.length; u++)if (c[u](e, s, l) === !1) return } i = i.parent } const a = t.appContext.config.errorHandler; if (a) { qn(a, null, 10, [e, s, l]); return } } Em(e, n, r, o) } function Em(e, t, n, o = !0) { console.error(e) } let vr = !1, Ls = !1; const ht = []; let Zt = 0; const mo = []; let an = null, Bn = 0; const Gc = Promise.resolve(); let wl = null; function Ie(e) { const t = wl || Gc; return e ? t.then(this ? e.bind(this) : e) : t } function qm(e) { let t = Zt + 1, n = ht.length; for (; t < n;) { const o = t + n >>> 1; pr(ht[o]) < e ? t = o + 1 : n = o } return t } function Cl(e) { (!ht.length || !ht.includes(e, vr && e.allowRecurse ? Zt + 1 : Zt)) && (e.id == null ? ht.push(e) : ht.splice(qm(e.id), 0, e), Zc()) } function Zc() { !vr && !Ls && (Ls = !0, wl = Gc.then(Jc)) } function Tm(e) { const t = ht.indexOf(e); t > Zt && ht.splice(t, 1) } function Pm(e) { _e(e) ? mo.push(...e) : (!an || !an.includes(e, e.allowRecurse ? Bn + 1 : Bn)) && mo.push(e), Zc() } function _a(e, t = vr ? Zt + 1 : 0) { for (; t < ht.length; t++) { const n = ht[t]; n && n.pre && (ht.splice(t, 1), t--, n()) } } function Yc(e) { if (mo.length) { const t = [...new Set(mo)]; if (mo.length = 0, an) { an.push(...t); return } for (an = t, an.sort((n, o) => pr(n) - pr(o)), Bn = 0; Bn < an.length; Bn++)an[Bn](); an = null, Bn = 0 } } const pr = e => e.id == null ? 1 / 0 : e.id, Am = (e, t) => { const n = pr(e) - pr(t); if (n === 0) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return n }; function Jc(e) { Ls = !1, vr = !0, ht.sort(Am); const t = Dt; try { for (Zt = 0; Zt < ht.length; Zt++) { const n = ht[Zt]; n && n.active !== !1 && qn(n, null, 14) } } finally { Zt = 0, ht.length = 0, Yc(), vr = !1, wl = null, (ht.length || mo.length) && Jc() } } function Om(e, t, ...n) { if (e.isUnmounted) return; const o = e.vnode.props || je; let r = n; const i = t.startsWith("update:"), s = i && t.slice(7); if (s && s in o) { const u = `${s === "modelValue" ? "model" : s}Modifiers`, { number: d, trim: f } = o[u] || je; f && (r = n.map(h => Ye(h) ? h.trim() : h)), d && (r = n.map(hl)) } let l, a = o[l = ts(t)] || o[l = ts(Xt(t))]; !a && i && (a = o[l = ts(Po(t))]), a && $t(a, e, 6, r); const c = o[l + "Once"]; if (c) { if (!e.emitted) e.emitted = {}; else if (e.emitted[l]) return; e.emitted[l] = !0, $t(c, e, 6, r) } } function Xc(e, t, n = !1) { const o = t.emitsCache, r = o.get(e); if (r !== void 0) return r; const i = e.emits; let s = {}, l = !1; if (!Se(e)) { const a = c => { const u = Xc(c, t, !0); u && (l = !0, st(s, u)) }; !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } return !i && !l ? (De(e) && o.set(e, null), null) : (_e(i) ? i.forEach(a => s[a] = null) : st(s, i), De(e) && o.set(e, s), s) } function Li(e, t) { return !e || !qi(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Ae(e, t[0].toLowerCase() + t.slice(1)) || Ae(e, Po(t)) || Ae(e, t)) } let ut = null, $i = null; function ci(e) { const t = ut; return ut = e, $i = e && e.type.__scopeId || null, t } function xl(e) { $i = e } function kl() { $i = null } const Sl = e => ae; function ae(e, t = ut, n) { if (!t || e._n) return e; const o = (...r) => { o._d && Oa(-1); const i = ci(t); let s; try { s = e(...r) } finally { ci(i), o._d && Oa(1) } return s }; return o._n = !0, o._c = !0, o._d = !0, o } function ns(e) { const { type: t, vnode: n, proxy: o, withProxy: r, props: i, propsOptions: [s], slots: l, attrs: a, emit: c, render: u, renderCache: d, data: f, setupState: h, ctx: v, inheritAttrs: x } = e; let _, A; const g = ci(e); try { if (n.shapeFlag & 4) { const w = r || o; _ = Qt(u.call(w, w, d, i, h, f, v)), A = a } else { const w = t; _ = Qt(w.length > 1 ? w(i, { attrs: a, slots: l, emit: c }) : w(i, null)), A = t.props ? a : Rm(a) } } catch (w) { ir.length = 0, Ri(w, e, 1), _ = K(gt) } let m = _; if (A && x !== !1) { const w = Object.keys(A), { shapeFlag: S } = m; w.length && S & 7 && (s && w.some(ul) && (A = Lm(A, s)), m = dn(m, A)) } return n.dirs && (m = dn(m), m.dirs = m.dirs ? m.dirs.concat(n.dirs) : n.dirs), n.transition && (m.transition = n.transition), _ = m, ci(g), _ } const Rm = e => { let t; for (const n in e) (n === "class" || n === "style" || qi(n)) && ((t || (t = {}))[n] = e[n]); return t }, Lm = (e, t) => { const n = {}; for (const o in e) (!ul(o) || !(o.slice(9) in t)) && (n[o] = e[o]); return n }; function $m(e, t, n) { const { props: o, children: r, component: i } = e, { props: s, children: l, patchFlag: a } = t, c = i.emitsOptions; if (t.dirs || t.transition) return !0; if (n && a >= 0) { if (a & 1024) return !0; if (a & 16) return o ? wa(o, s, c) : !!s; if (a & 8) { const u = t.dynamicProps; for (let d = 0; d < u.length; d++) { const f = u[d]; if (s[f] !== o[f] && !Li(c, f)) return !0 } } } else return (r || l) && (!l || !l.$stable) ? !0 : o === s ? !1 : o ? s ? wa(o, s, c) : !0 : !!s; return !1 } function wa(e, t, n) { const o = Object.keys(t); if (o.length !== Object.keys(e).length) return !0; for (let r = 0; r < o.length; r++) { const i = o[r]; if (t[i] !== e[i] && !Li(n, i)) return !0 } return !1 } function Mm({ vnode: e, parent: t }, n) { for (; t && t.subTree === e;)(e = t.vnode).el = n, t = t.parent } const ed = e => e.__isSuspense; function Bm(e, t) { t && t.pendingBranch ? _e(e) ? t.effects.push(...e) : t.effects.push(e) : Pm(e) } function xt(e, t) { if (rt) { let n = rt.provides; const o = rt.parent && rt.parent.provides; o === n && (n = rt.provides = Object.create(o)), n[e] = t } } function Le(e, t, n = !1) { const o = rt || ut; if (o) { const r = o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides; if (r && e in r) return r[e]; if (arguments.length > 1) return n && Se(t) ? t.call(o.proxy) : t } } const Dr = {}; function de(e, t, n) { return td(e, t, n) } function td(e, t, { immediate: n, deep: o, flush: r, onTrack: i, onTrigger: s } = je) { const l = rt; let a, c = !1, u = !1; if (Ze(e) ? (a = () => e.value, c = ui(e)) : En(e) ? (a = () => e, o = !0) : _e(e) ? (u = !0, c = e.some(m => En(m) || ui(m)), a = () => e.map(m => { if (Ze(m)) return m.value; if (En(m)) return Vn(m); if (Se(m)) return qn(m, l, 2) })) : Se(e) ? t ? a = () => qn(e, l, 2) : a = () => { if (!(l && l.isUnmounted)) return d && d(), $t(e, l, 3, [f]) } : a = Dt, t && o) { const m = a; a = () => Vn(m()) } let d, f = m => { d = A.onStop = () => { qn(m, l, 4) } }, h; if (_r) if (f = Dt, t ? n && $t(t, l, 3, [a(), u ? [] : void 0, f]) : a(), r === "sync") { const m = Ev(); h = m.__watcherHandles || (m.__watcherHandles = []) } else return Dt; let v = u ? new Array(e.length).fill(Dr) : Dr; const x = () => { if (!!A.active) if (t) { const m = A.run(); (o || c || (u ? m.some((w, S) => hr(w, v[S])) : hr(m, v))) && (d && d(), $t(t, l, 3, [m, v === Dr ? void 0 : u && v[0] === Dr ? [] : v, f]), v = m) } else A.run() }; x.allowRecurse = !!t; let _; r === "sync" ? _ = x : r === "post" ? _ = () => at(x, l && l.suspense) : (x.pre = !0, l && (x.id = l.uid), _ = () => Cl(x)); const A = new vl(a, _); t ? n ? x() : v = A.run() : r === "post" ? at(A.run.bind(A), l && l.suspense) : A.run(); const g = () => { A.stop(), l && l.scope && cl(l.scope.effects, A) }; return h && h.push(g), g } function Im(e, t, n) { const o = this.proxy, r = Ye(e) ? e.includes(".") ? nd(o, e) : () => o[e] : e.bind(o, o); let i; Se(t) ? i = t : (i = t.handler, n = t); const s = rt; Co(this); const l = td(r, i.bind(o), n); return s ? Co(s) : Un(), l } function nd(e, t) { const n = t.split("."); return () => { let o = e; for (let r = 0; r < n.length && o; r++)o = o[n[r]]; return o } } function Vn(e, t) { if (!De(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e; if (t.add(e), Ze(e)) Vn(e.value, t); else if (_e(e)) for (let n = 0; n < e.length; n++)Vn(e[n], t); else if (Ec(e) || ho(e)) e.forEach(n => { Vn(n, t) }); else if (Pc(e)) for (const n in e) Vn(e[n], t); return e } function od() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return et(() => { e.isMounted = !0 }), Re(() => { e.isUnmounting = !0 }), e } const Et = [Function, Array], Fm = { name: "BaseTransition", props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Et, onEnter: Et, onAfterEnter: Et, onEnterCancelled: Et, onBeforeLeave: Et, onLeave: Et, onAfterLeave: Et, onLeaveCancelled: Et, onBeforeAppear: Et, onAppear: Et, onAfterAppear: Et, onAppearCancelled: Et }, setup(e, { slots: t }) { const n = Ee(), o = od(); let r; return () => { const i = t.default && El(t.default(), !0); if (!i || !i.length) return; let s = i[0]; if (i.length > 1) { for (const x of i) if (x.type !== gt) { s = x; break } } const l = ke(e), { mode: a } = l; if (o.isLeaving) return os(s); const c = Ca(s); if (!c) return os(s); const u = gr(c, l, o, n); wo(c, u); const d = n.subTree, f = d && Ca(d); let h = !1; const { getTransitionKey: v } = c.type; if (v) { const x = v(); r === void 0 ? r = x : x !== r && (r = x, h = !0) } if (f && f.type !== gt && (!In(c, f) || h)) { const x = gr(f, l, o, n); if (wo(f, x), a === "out-in") return o.isLeaving = !0, x.afterLeave = () => { o.isLeaving = !1, n.update.active !== !1 && n.update() }, os(s); a === "in-out" && c.type !== gt && (x.delayLeave = (_, A, g) => { const m = id(o, f); m[String(f.key)] = f, _._leaveCb = () => { A(), _._leaveCb = void 0, delete u.delayedLeave }, u.delayedLeave = g }) } return s } } }, rd = Fm; function id(e, t) { const { leavingVNodes: n } = e; let o = n.get(t.type); return o || (o = Object.create(null), n.set(t.type, o)), o } function gr(e, t, n, o) { const { appear: r, mode: i, persisted: s = !1, onBeforeEnter: l, onEnter: a, onAfterEnter: c, onEnterCancelled: u, onBeforeLeave: d, onLeave: f, onAfterLeave: h, onLeaveCancelled: v, onBeforeAppear: x, onAppear: _, onAfterAppear: A, onAppearCancelled: g } = t, m = String(e.key), w = id(n, e), S = (q, F) => { q && $t(q, o, 9, F) }, k = (q, F) => { const B = F[1]; S(q, F), _e(q) ? q.every(j => j.length <= 1) && B() : q.length <= 1 && B() }, T = { mode: i, persisted: s, beforeEnter(q) { let F = l; if (!n.isMounted) if (r) F = x || l; else return; q._leaveCb && q._leaveCb(!0); const B = w[m]; B && In(e, B) && B.el._leaveCb && B.el._leaveCb(), S(F, [q]) }, enter(q) { let F = a, B = c, j = u; if (!n.isMounted) if (r) F = _ || a, B = A || c, j = g || u; else return; let $ = !1; const M = q._enterCb = R => { $ || ($ = !0, R ? S(j, [q]) : S(B, [q]), T.delayedLeave && T.delayedLeave(), q._enterCb = void 0) }; F ? k(F, [q, M]) : M() }, leave(q, F) { const B = String(e.key); if (q._enterCb && q._enterCb(!0), n.isUnmounting) return F(); S(d, [q]); let j = !1; const $ = q._leaveCb = M => { j || (j = !0, F(), M ? S(v, [q]) : S(h, [q]), q._leaveCb = void 0, w[B] === e && delete w[B]) }; w[B] = e, f ? k(f, [q, $]) : $() }, clone(q) { return gr(q, t, n, o) } }; return T } function os(e) { if (Mi(e)) return e = dn(e), e.children = null, e } function Ca(e) { return Mi(e) ? e.children ? e.children[0] : void 0 : e } function wo(e, t) { e.shapeFlag & 6 && e.component ? wo(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function El(e, t = !1, n) { let o = [], r = 0; for (let i = 0; i < e.length; i++) { let s = e[i]; const l = n == null ? s.key : String(n) + String(s.key != null ? s.key : i); s.type === Ue ? (s.patchFlag & 128 && r++, o = o.concat(El(s.children, t, l))) : (t || s.type !== gt) && o.push(l != null ? dn(s, { key: l }) : s) } if (r > 1) for (let i = 0; i < o.length; i++)o[i].patchFlag = -2; return o } function Ne(e) { return Se(e) ? { setup: e, name: e.name } : e } const vo = e => !!e.type.__asyncLoader, Mi = e => e.type.__isKeepAlive, zm = { name: "KeepAlive", __isKeepAlive: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(e, { slots: t }) { const n = Ee(), o = n.ctx; if (!o.renderer) return () => { const g = t.default && t.default(); return g && g.length === 1 ? g[0] : g }; const r = new Map, i = new Set; let s = null; const l = n.suspense, { renderer: { p: a, m: c, um: u, o: { createElement: d } } } = o, f = d("div"); o.activate = (g, m, w, S, k) => { const T = g.component; c(g, m, w, 0, l), a(T.vnode, g, m, w, T, l, S, g.slotScopeIds, k), at(() => { T.isDeactivated = !1, T.a && nr(T.a); const q = g.props && g.props.onVnodeMounted; q && Tt(q, T.parent, g) }, l) }, o.deactivate = g => { const m = g.component; c(g, f, null, 1, l), at(() => { m.da && nr(m.da); const w = g.props && g.props.onVnodeUnmounted; w && Tt(w, m.parent, g), m.isDeactivated = !0 }, l) }; function h(g) { rs(g), u(g, n, l, !0) } function v(g) { r.forEach((m, w) => { const S = Vs(m.type); S && (!g || !g(S)) && x(w) }) } function x(g) { const m = r.get(g); !s || m.type !== s.type ? h(m) : s && rs(s), r.delete(g), i.delete(g) } de(() => [e.include, e.exclude], ([g, m]) => { g && v(w => Jo(g, w)), m && v(w => !Jo(m, w)) }, { flush: "post", deep: !0 }); let _ = null; const A = () => { _ != null && r.set(_, is(n.subTree)) }; return et(A), Ii(A), Re(() => { r.forEach(g => { const { subTree: m, suspense: w } = n, S = is(m); if (g.type === S.type) { rs(S); const k = S.component.da; k && at(k, w); return } h(g) }) }), () => { if (_ = null, !t.default) return null; const g = t.default(), m = g[0]; if (g.length > 1) return s = null, g; if (!br(m) || !(m.shapeFlag & 4) && !(m.shapeFlag & 128)) return s = null, m; let w = is(m); const S = w.type, k = Vs(vo(w) ? w.type.__asyncResolved || {} : S), { include: T, exclude: q, max: F } = e; if (T && (!k || !Jo(T, k)) || q && k && Jo(q, k)) return s = w, m; const B = w.key == null ? S : w.key, j = r.get(B); return w.el && (w = dn(w), m.shapeFlag & 128 && (m.ssContent = w)), _ = B, j ? (w.el = j.el, w.component = j.component, w.transition && wo(w, w.transition), w.shapeFlag |= 512, i.delete(B), i.add(B)) : (i.add(B), F && i.size > parseInt(F, 10) && x(i.values().next().value)), w.shapeFlag |= 256, s = w, ed(m.type) ? m : w } } }, Vm = zm; function Jo(e, t) { return _e(e) ? e.some(n => Jo(n, t)) : Ye(e) ? e.split(",").includes(t) : e.test ? e.test(t) : !1 } function Rr(e, t) { sd(e, "a", t) } function Yn(e, t) { sd(e, "da", t) } function sd(e, t, n = rt) { const o = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (Bi(t, o, n), n) { let r = n.parent; for (; r && r.parent;)Mi(r.parent.vnode) && Nm(o, t, n, r), r = r.parent } } function Nm(e, t, n, o) { const r = Bi(t, e, o, !0); Fi(() => { cl(o[t], r) }, n) } function rs(e) { e.shapeFlag &= -257, e.shapeFlag &= -513 } function is(e) { return e.shapeFlag & 128 ? e.ssContent : e } function Bi(e, t, n = rt, o = !1) { if (n) { const r = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...s) => { if (n.isUnmounted) return; Ao(), Co(n); const l = $t(t, n, e, s); return Un(), Oo(), l }); return o ? r.unshift(i) : r.push(i), i } } const mn = e => (t, n = rt) => (!_r || e === "sp") && Bi(e, (...o) => t(...o), n), ql = mn("bm"), et = mn("m"), Tl = mn("bu"), Ii = mn("u"), Re = mn("bum"), Fi = mn("um"), jm = mn("sp"), Dm = mn("rtg"), Hm = mn("rtc"); function Km(e, t = rt) { Bi("ec", e, t) } function Rt(e, t) { const n = ut; if (n === null) return e; const o = ji(n) || n.proxy, r = e.dirs || (e.dirs = []); for (let i = 0; i < t.length; i++) { let [s, l, a, c = je] = t[i]; s && (Se(s) && (s = { mounted: s, updated: s }), s.deep && Vn(l), r.push({ dir: s, instance: o, value: l, oldValue: void 0, arg: a, modifiers: c })) } return e } function An(e, t, n, o) { const r = e.dirs, i = t && t.dirs; for (let s = 0; s < r.length; s++) { const l = r[s]; i && (l.oldValue = i[s].value); let a = l.dir[o]; a && (Ao(), $t(a, n, 8, [e.el, l, e, t]), Oo()) } } const ld = "components"; function Pt(e, t) { return Wm(ld, e, !0, t) || e } const Um = Symbol(); function Wm(e, t, n = !0, o = !1) { const r = ut || rt; if (r) { const i = r.type; if (e === ld) { const l = Vs(i, !1); if (l && (l === t || l === Xt(t) || l === Ai(Xt(t)))) return i } const s = xa(r[e] || i[e], t) || xa(r.appContext[e], t); return !s && o ? i : s } } function xa(e, t) { return e && (e[t] || e[Xt(t)] || e[Ai(Xt(t))]) } function po(e, t, n, o) { let r; const i = n && n[o]; if (_e(e) || Ye(e)) { r = new Array(e.length); for (let s = 0, l = e.length; s < l; s++)r[s] = t(e[s], s, void 0, i && i[s]) } else if (typeof e == "number") { r = new Array(e); for (let s = 0; s < e; s++)r[s] = t(s + 1, s, void 0, i && i[s]) } else if (De(e)) if (e[Symbol.iterator]) r = Array.from(e, (s, l) => t(s, l, void 0, i && i[l])); else { const s = Object.keys(e); r = new Array(s.length); for (let l = 0, a = s.length; l < a; l++) { const c = s[l]; r[l] = t(e[c], c, l, i && i[l]) } } else r = []; return n && (n[o] = r), r } function zi(e, t, n = {}, o, r) { if (ut.isCE || ut.parent && vo(ut.parent) && ut.parent.isCE) return t !== "default" && (n.name = t), K("slot", n, o && o()); let i = e[t]; i && i._c && (i._d = !1), Oe(); const s = i && ad(i(n)), l = Qe(Ue, { key: n.key || s && s.key || `_${t}` }, s || (o ? o() : []), s && e._ === 1 ? 64 : -2); return !r && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), i && i._c && (i._d = !0), l } function ad(e) { return e.some(t => br(t) ? !(t.type === gt || t.type === Ue && !ad(t.children)) : !0) ? e : null } const $s = e => e ? bd(e) ? ji(e) || e.proxy : $s(e.parent) : null, or = st(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => $s(e.parent), $root: e => $s(e.root), $emit: e => e.emit, $options: e => Pl(e), $forceUpdate: e => e.f || (e.f = () => Cl(e.update)), $nextTick: e => e.n || (e.n = Ie.bind(e.proxy)), $watch: e => Im.bind(e) }), ss = (e, t) => e !== je && !e.__isScriptSetup && Ae(e, t), Qm = { get({ _: e }, t) { const { ctx: n, setupState: o, data: r, props: i, accessCache: s, type: l, appContext: a } = e; let c; if (t[0] !== "$") { const h = s[t]; if (h !== void 0) switch (h) { case 1: return o[t]; case 2: return r[t]; case 4: return n[t]; case 3: return i[t] } else { if (ss(o, t)) return s[t] = 1, o[t]; if (r !== je && Ae(r, t)) return s[t] = 2, r[t]; if ((c = e.propsOptions[0]) && Ae(c, t)) return s[t] = 3, i[t]; if (n !== je && Ae(n, t)) return s[t] = 4, n[t]; Ms && (s[t] = 0) } } const u = or[t]; let d, f; if (u) return t === "$attrs" && kt(e, "get", t), u(e); if ((d = l.__cssModules) && (d = d[t])) return d; if (n !== je && Ae(n, t)) return s[t] = 4, n[t]; if (f = a.config.globalProperties, Ae(f, t)) return f[t] }, set({ _: e }, t, n) { const { data: o, setupState: r, ctx: i } = e; return ss(r, t) ? (r[t] = n, !0) : o !== je && Ae(o, t) ? (o[t] = n, !0) : Ae(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: r, propsOptions: i } }, s) { let l; return !!n[s] || e !== je && Ae(e, s) || ss(t, s) || (l = i[0]) && Ae(l, s) || Ae(o, s) || Ae(or, s) || Ae(r.config.globalProperties, s) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : Ae(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; let Ms = !0; function Gm(e) { const t = Pl(e), n = e.proxy, o = e.ctx; Ms = !1, t.beforeCreate && ka(t.beforeCreate, e, "bc"); const { data: r, computed: i, methods: s, watch: l, provide: a, inject: c, created: u, beforeMount: d, mounted: f, beforeUpdate: h, updated: v, activated: x, deactivated: _, beforeDestroy: A, beforeUnmount: g, destroyed: m, unmounted: w, render: S, renderTracked: k, renderTriggered: T, errorCaptured: q, serverPrefetch: F, expose: B, inheritAttrs: j, components: $, directives: M, filters: R } = t; if (c && Zm(c, o, null, e.appContext.config.unwrapInjectedRef), s) for (const D in s) { const oe = s[D]; Se(oe) && (o[D] = oe.bind(n)) } if (r) { const D = r.call(n, n); De(D) && (e.data = Ot(D)) } if (Ms = !0, i) for (const D in i) { const oe = i[D], Ce = Se(oe) ? oe.bind(n, n) : Se(oe.get) ? oe.get.bind(n, n) : Dt, ne = !Se(oe) && Se(oe.set) ? oe.set.bind(n) : Dt, O = y({ get: Ce, set: ne }); Object.defineProperty(o, D, { enumerable: !0, configurable: !0, get: () => O.value, set: J => O.value = J }) } if (l) for (const D in l) ud(l[D], o, n, D); if (a) { const D = Se(a) ? a.call(n) : a; Reflect.ownKeys(D).forEach(oe => { xt(oe, D[oe]) }) } u && ka(u, e, "c"); function fe(D, oe) { _e(oe) ? oe.forEach(Ce => D(Ce.bind(n))) : oe && D(oe.bind(n)) } if (fe(ql, d), fe(et, f), fe(Tl, h), fe(Ii, v), fe(Rr, x), fe(Yn, _), fe(Km, q), fe(Hm, k), fe(Dm, T), fe(Re, g), fe(Fi, w), fe(jm, F), _e(B)) if (B.length) { const D = e.exposed || (e.exposed = {}); B.forEach(oe => { Object.defineProperty(D, oe, { get: () => n[oe], set: Ce => n[oe] = Ce }) }) } else e.exposed || (e.exposed = {}); S && e.render === Dt && (e.render = S), j != null && (e.inheritAttrs = j), $ && (e.components = $), M && (e.directives = M) } function Zm(e, t, n = Dt, o = !1) { _e(e) && (e = Bs(e)); for (const r in e) { const i = e[r]; let s; De(i) ? "default" in i ? s = Le(i.from || r, i.default, !0) : s = Le(i.from || r) : s = Le(i), Ze(s) && o ? Object.defineProperty(t, r, { enumerable: !0, configurable: !0, get: () => s.value, set: l => s.value = l }) : t[r] = s } } function ka(e, t, n) { $t(_e(e) ? e.map(o => o.bind(t.proxy)) : e.bind(t.proxy), t, n) } function ud(e, t, n, o) { const r = o.includes(".") ? nd(n, o) : () => n[o]; if (Ye(e)) { const i = t[e]; Se(i) && de(r, i) } else if (Se(e)) de(r, e.bind(n)); else if (De(e)) if (_e(e)) e.forEach(i => ud(i, t, n, o)); else { const i = Se(e.handler) ? e.handler.bind(n) : t[e.handler]; Se(i) && de(r, i, e) } } function Pl(e) { const t = e.type, { mixins: n, extends: o } = t, { mixins: r, optionsCache: i, config: { optionMergeStrategies: s } } = e.appContext, l = i.get(t); let a; return l ? a = l : !r.length && !n && !o ? a = t : (a = {}, r.length && r.forEach(c => di(a, c, s, !0)), di(a, t, s)), De(t) && i.set(t, a), a } function di(e, t, n, o = !1) { const { mixins: r, extends: i } = t; i && di(e, i, n, !0), r && r.forEach(s => di(e, s, n, !0)); for (const s in t) if (!(o && s === "expose")) { const l = Ym[s] || n && n[s]; e[s] = l ? l(e[s], t[s]) : t[s] } return e } const Ym = { data: Sa, props: Mn, emits: Mn, methods: Mn, computed: Mn, beforeCreate: pt, created: pt, beforeMount: pt, mounted: pt, beforeUpdate: pt, updated: pt, beforeDestroy: pt, beforeUnmount: pt, destroyed: pt, unmounted: pt, activated: pt, deactivated: pt, errorCaptured: pt, serverPrefetch: pt, components: Mn, directives: Mn, watch: Xm, provide: Sa, inject: Jm }; function Sa(e, t) { return t ? e ? function () { return st(Se(e) ? e.call(this, this) : e, Se(t) ? t.call(this, this) : t) } : t : e } function Jm(e, t) { return Mn(Bs(e), Bs(t)) } function Bs(e) { if (_e(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function pt(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Mn(e, t) { return e ? st(st(Object.create(null), e), t) : t } function Xm(e, t) { if (!e) return t; if (!t) return e; const n = st(Object.create(null), e); for (const o in t) n[o] = pt(e[o], t[o]); return n } function ev(e, t, n, o = !1) { const r = {}, i = {}; ai(i, Ni, 1), e.propsDefaults = Object.create(null), cd(e, t, r, i); for (const s in e.propsOptions[0]) s in r || (r[s] = void 0); n ? e.props = o ? r : ym(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i } function tv(e, t, n, o) { const { props: r, attrs: i, vnode: { patchFlag: s } } = e, l = ke(r), [a] = e.propsOptions; let c = !1; if ((o || s > 0) && !(s & 16)) { if (s & 8) { const u = e.vnode.dynamicProps; for (let d = 0; d < u.length; d++) { let f = u[d]; if (Li(e.emitsOptions, f)) continue; const h = t[f]; if (a) if (Ae(i, f)) h !== i[f] && (i[f] = h, c = !0); else { const v = Xt(f); r[v] = Is(a, l, v, h, e, !1) } else h !== i[f] && (i[f] = h, c = !0) } } } else { cd(e, t, r, i) && (c = !0); let u; for (const d in l) (!t || !Ae(t, d) && ((u = Po(d)) === d || !Ae(t, u))) && (a ? n && (n[d] !== void 0 || n[u] !== void 0) && (r[d] = Is(a, l, d, void 0, e, !0)) : delete r[d]); if (i !== l) for (const d in i) (!t || !Ae(t, d) && !0) && (delete i[d], c = !0) } c && cn(e, "set", "$attrs") } function cd(e, t, n, o) { const [r, i] = e.propsOptions; let s = !1, l; if (t) for (let a in t) { if (Xr(a)) continue; const c = t[a]; let u; r && Ae(r, u = Xt(a)) ? !i || !i.includes(u) ? n[u] = c : (l || (l = {}))[u] = c : Li(e.emitsOptions, a) || (!(a in o) || c !== o[a]) && (o[a] = c, s = !0) } if (i) { const a = ke(n), c = l || je; for (let u = 0; u < i.length; u++) { const d = i[u]; n[d] = Is(r, a, d, c[d], e, !Ae(c, d)) } } return s } function Is(e, t, n, o, r, i) { const s = e[n]; if (s != null) { const l = Ae(s, "default"); if (l && o === void 0) { const a = s.default; if (s.type !== Function && Se(a)) { const { propsDefaults: c } = r; n in c ? o = c[n] : (Co(r), o = c[n] = a.call(null, t), Un()) } else o = a } s[0] && (i && !l ? o = !1 : s[1] && (o === "" || o === Po(n)) && (o = !0)) } return o } function dd(e, t, n = !1) { const o = t.propsCache, r = o.get(e); if (r) return r; const i = e.props, s = {}, l = []; let a = !1; if (!Se(e)) { const u = d => { a = !0; const [f, h] = dd(d, t, !0); st(s, f), h && l.push(...h) }; !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } if (!i && !a) return De(e) && o.set(e, fo), fo; if (_e(i)) for (let u = 0; u < i.length; u++) { const d = Xt(i[u]); Ea(d) && (s[d] = je) } else if (i) for (const u in i) { const d = Xt(u); if (Ea(d)) { const f = i[u], h = s[d] = _e(f) || Se(f) ? { type: f } : Object.assign({}, f); if (h) { const v = Pa(Boolean, h.type), x = Pa(String, h.type); h[0] = v > -1, h[1] = x < 0 || v < x, (v > -1 || Ae(h, "default")) && l.push(d) } } } const c = [s, l]; return De(e) && o.set(e, c), c } function Ea(e) { return e[0] !== "$" } function qa(e) { const t = e && e.toString().match(/^\s*function (\w+)/); return t ? t[1] : e === null ? "null" : "" } function Ta(e, t) { return qa(e) === qa(t) } function Pa(e, t) { return _e(t) ? t.findIndex(n => Ta(n, e)) : Se(t) && Ta(t, e) ? 0 : -1 } const fd = e => e[0] === "_" || e === "$stable", Al = e => _e(e) ? e.map(Qt) : [Qt(e)], nv = (e, t, n) => { if (t._n) return t; const o = ae((...r) => Al(t(...r)), n); return o._c = !1, o }, hd = (e, t, n) => { const o = e._ctx; for (const r in e) { if (fd(r)) continue; const i = e[r]; if (Se(i)) t[r] = nv(r, i, o); else if (i != null) { const s = Al(i); t[r] = () => s } } }, md = (e, t) => { const n = Al(t); e.slots.default = () => n }, ov = (e, t) => { if (e.vnode.shapeFlag & 32) { const n = t._; n ? (e.slots = ke(t), ai(t, "_", n)) : hd(t, e.slots = {}) } else e.slots = {}, t && md(e, t); ai(e.slots, Ni, 1) }, rv = (e, t, n) => { const { vnode: o, slots: r } = e; let i = !0, s = je; if (o.shapeFlag & 32) { const l = t._; l ? n && l === 1 ? i = !1 : (st(r, t), !n && l === 1 && delete r._) : (i = !t.$stable, hd(t, r)), s = t } else t && (md(e, t), s = { default: 1 }); if (i) for (const l in r) !fd(l) && !(l in s) && delete r[l] }; function vd() { return { app: null, config: { isNativeTag: Ih, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let iv = 0; function sv(e, t) { return function (o, r = null) { Se(o) || (o = Object.assign({}, o)), r != null && !De(r) && (r = null); const i = vd(), s = new Set; let l = !1; const a = i.app = { _uid: iv++, _component: o, _props: r, _container: null, _context: i, _instance: null, version: qv, get config() { return i.config }, set config(c) { }, use(c, ...u) { return s.has(c) || (c && Se(c.install) ? (s.add(c), c.install(a, ...u)) : Se(c) && (s.add(c), c(a, ...u))), a }, mixin(c) { return i.mixins.includes(c) || i.mixins.push(c), a }, component(c, u) { return u ? (i.components[c] = u, a) : i.components[c] }, directive(c, u) { return u ? (i.directives[c] = u, a) : i.directives[c] }, mount(c, u, d) { if (!l) { const f = K(o, r); return f.appContext = i, u && t ? t(f, c) : e(f, c, d), l = !0, a._container = c, c.__vue_app__ = a, ji(f.component) || f.component.proxy } }, unmount() { l && (e(null, a._container), delete a._container.__vue_app__) }, provide(c, u) { return i.provides[c] = u, a } }; return a } } function Fs(e, t, n, o, r = !1) { if (_e(e)) { e.forEach((f, h) => Fs(f, t && (_e(t) ? t[h] : t), n, o, r)); return } if (vo(o) && !r) return; const i = o.shapeFlag & 4 ? ji(o.component) || o.component.proxy : o.el, s = r ? null : i, { i: l, r: a } = e, c = t && t.r, u = l.refs === je ? l.refs = {} : l.refs, d = l.setupState; if (c != null && c !== a && (Ye(c) ? (u[c] = null, Ae(d, c) && (d[c] = null)) : Ze(c) && (c.value = null)), Se(a)) qn(a, l, 12, [s, u]); else { const f = Ye(a), h = Ze(a); if (f || h) { const v = () => { if (e.f) { const x = f ? Ae(d, a) ? d[a] : u[a] : a.value; r ? _e(x) && cl(x, i) : _e(x) ? x.includes(i) || x.push(i) : f ? (u[a] = [i], Ae(d, a) && (d[a] = u[a])) : (a.value = [i], e.k && (u[e.k] = a.value)) } else f ? (u[a] = s, Ae(d, a) && (d[a] = s)) : h && (a.value = s, e.k && (u[e.k] = s)) }; s ? (v.id = -1, at(v, n)) : v() } } } const at = Bm; function lv(e) { return av(e) } function av(e, t) { const n = Dh(); n.__VUE__ = !0; const { insert: o, remove: r, patchProp: i, createElement: s, createText: l, createComment: a, setText: c, setElementText: u, parentNode: d, nextSibling: f, setScopeId: h = Dt, insertStaticContent: v } = e, x = (p, C, I, H = null, G = null, re = null, se = !1, te = null, Y = !!C.dynamicChildren) => { if (p === C) return; p && !In(p, C) && (H = L(p), J(p, G, re, !0), p = null), C.patchFlag === -2 && (Y = !1, C.dynamicChildren = null); const { type: P, ref: Q, shapeFlag: Z } = C; switch (P) { case Vi: _(p, C, I, H); break; case gt: A(p, C, I, H); break; case ls: p == null && g(C, I, H, se); break; case Ue: $(p, C, I, H, G, re, se, te, Y); break; default: Z & 1 ? S(p, C, I, H, G, re, se, te, Y) : Z & 6 ? M(p, C, I, H, G, re, se, te, Y) : (Z & 64 || Z & 128) && P.process(p, C, I, H, G, re, se, te, Y, W) }Q != null && G && Fs(Q, p && p.ref, re, C || p, !C) }, _ = (p, C, I, H) => { if (p == null) o(C.el = l(C.children), I, H); else { const G = C.el = p.el; C.children !== p.children && c(G, C.children) } }, A = (p, C, I, H) => { p == null ? o(C.el = a(C.children || ""), I, H) : C.el = p.el }, g = (p, C, I, H) => { [p.el, p.anchor] = v(p.children, C, I, H, p.el, p.anchor) }, m = ({ el: p, anchor: C }, I, H) => { let G; for (; p && p !== C;)G = f(p), o(p, I, H), p = G; o(C, I, H) }, w = ({ el: p, anchor: C }) => { let I; for (; p && p !== C;)I = f(p), r(p), p = I; r(C) }, S = (p, C, I, H, G, re, se, te, Y) => { se = se || C.type === "svg", p == null ? k(C, I, H, G, re, se, te, Y) : F(p, C, G, re, se, te, Y) }, k = (p, C, I, H, G, re, se, te) => { let Y, P; const { type: Q, props: Z, shapeFlag: le, transition: he, dirs: me } = p; if (Y = p.el = s(p.type, re, Z && Z.is, Z), le & 8 ? u(Y, p.children) : le & 16 && q(p.children, Y, null, H, G, re && Q !== "foreignObject", se, te), me && An(p, null, H, "created"), Z) { for (const be in Z) be !== "value" && !Xr(be) && i(Y, be, null, Z[be], re, p.children, H, G, U); "value" in Z && i(Y, "value", null, Z.value), (P = Z.onVnodeBeforeMount) && Tt(P, H, p) } T(Y, p, p.scopeId, se, H), me && An(p, null, H, "beforeMount"); const pe = (!G || G && !G.pendingBranch) && he && !he.persisted; pe && he.beforeEnter(Y), o(Y, C, I), ((P = Z && Z.onVnodeMounted) || pe || me) && at(() => { P && Tt(P, H, p), pe && he.enter(Y), me && An(p, null, H, "mounted") }, G) }, T = (p, C, I, H, G) => { if (I && h(p, I), H) for (let re = 0; re < H.length; re++)h(p, H[re]); if (G) { let re = G.subTree; if (C === re) { const se = G.vnode; T(p, se, se.scopeId, se.slotScopeIds, G.parent) } } }, q = (p, C, I, H, G, re, se, te, Y = 0) => { for (let P = Y; P < p.length; P++) { const Q = p[P] = te ? bn(p[P]) : Qt(p[P]); x(null, Q, C, I, H, G, re, se, te) } }, F = (p, C, I, H, G, re, se) => { const te = C.el = p.el; let { patchFlag: Y, dynamicChildren: P, dirs: Q } = C; Y |= p.patchFlag & 16; const Z = p.props || je, le = C.props || je; let he; I && On(I, !1), (he = le.onVnodeBeforeUpdate) && Tt(he, I, C, p), Q && An(C, p, I, "beforeUpdate"), I && On(I, !0); const me = G && C.type !== "foreignObject"; if (P ? B(p.dynamicChildren, P, te, I, H, me, re) : se || oe(p, C, te, null, I, H, me, re, !1), Y > 0) { if (Y & 16) j(te, C, Z, le, I, H, G); else if (Y & 2 && Z.class !== le.class && i(te, "class", null, le.class, G), Y & 4 && i(te, "style", Z.style, le.style, G), Y & 8) { const pe = C.dynamicProps; for (let be = 0; be < pe.length; be++) { const Te = pe[be], Ke = Z[Te], yt = le[Te]; (yt !== Ke || Te === "value") && i(te, Te, Ke, yt, G, p.children, I, H, U) } } Y & 1 && p.children !== C.children && u(te, C.children) } else !se && P == null && j(te, C, Z, le, I, H, G); ((he = le.onVnodeUpdated) || Q) && at(() => { he && Tt(he, I, C, p), Q && An(C, p, I, "updated") }, H) }, B = (p, C, I, H, G, re, se) => { for (let te = 0; te < C.length; te++) { const Y = p[te], P = C[te], Q = Y.el && (Y.type === Ue || !In(Y, P) || Y.shapeFlag & 70) ? d(Y.el) : I; x(Y, P, Q, null, H, G, re, se, !0) } }, j = (p, C, I, H, G, re, se) => { if (I !== H) { if (I !== je) for (const te in I) !Xr(te) && !(te in H) && i(p, te, I[te], null, se, C.children, G, re, U); for (const te in H) { if (Xr(te)) continue; const Y = H[te], P = I[te]; Y !== P && te !== "value" && i(p, te, P, Y, se, C.children, G, re, U) } "value" in H && i(p, "value", I.value, H.value) } }, $ = (p, C, I, H, G, re, se, te, Y) => { const P = C.el = p ? p.el : l(""), Q = C.anchor = p ? p.anchor : l(""); let { patchFlag: Z, dynamicChildren: le, slotScopeIds: he } = C; he && (te = te ? te.concat(he) : he), p == null ? (o(P, I, H), o(Q, I, H), q(C.children, I, Q, G, re, se, te, Y)) : Z > 0 && Z & 64 && le && p.dynamicChildren ? (B(p.dynamicChildren, le, I, G, re, se, te), (C.key != null || G && C === G.subTree) && Ol(p, C, !0)) : oe(p, C, I, Q, G, re, se, te, Y) }, M = (p, C, I, H, G, re, se, te, Y) => { C.slotScopeIds = te, p == null ? C.shapeFlag & 512 ? G.ctx.activate(C, I, H, se, Y) : R(C, I, H, G, re, se, Y) : ee(p, C, Y) }, R = (p, C, I, H, G, re, se) => { const te = p.component = bv(p, H, G); if (Mi(p) && (te.ctx.renderer = W), _v(te), te.asyncDep) { if (G && G.registerDep(te, fe), !p.el) { const Y = te.subTree = K(gt); A(null, Y, C, I) } return } fe(te, p, C, I, G, re, se) }, ee = (p, C, I) => { const H = C.component = p.component; if ($m(p, C, I)) if (H.asyncDep && !H.asyncResolved) { D(H, C, I); return } else H.next = C, Tm(H.update), H.update(); else C.el = p.el, H.vnode = C }, fe = (p, C, I, H, G, re, se) => { const te = () => { if (p.isMounted) { let { next: Q, bu: Z, u: le, parent: he, vnode: me } = p, pe = Q, be; On(p, !1), Q ? (Q.el = me.el, D(p, Q, se)) : Q = me, Z && nr(Z), (be = Q.props && Q.props.onVnodeBeforeUpdate) && Tt(be, he, Q, me), On(p, !0); const Te = ns(p), Ke = p.subTree; p.subTree = Te, x(Ke, Te, d(Ke.el), L(Ke), p, G, re), Q.el = Te.el, pe === null && Mm(p, Te.el), le && at(le, G), (be = Q.props && Q.props.onVnodeUpdated) && at(() => Tt(be, he, Q, me), G) } else { let Q; const { el: Z, props: le } = C, { bm: he, m: me, parent: pe } = p, be = vo(C); if (On(p, !1), he && nr(he), !be && (Q = le && le.onVnodeBeforeMount) && Tt(Q, pe, C), On(p, !0), Z && ge) { const Te = () => { p.subTree = ns(p), ge(Z, p.subTree, p, G, null) }; be ? C.type.__asyncLoader().then(() => !p.isUnmounted && Te()) : Te() } else { const Te = p.subTree = ns(p); x(null, Te, I, H, p, G, re), C.el = Te.el } if (me && at(me, G), !be && (Q = le && le.onVnodeMounted)) { const Te = C; at(() => Tt(Q, pe, Te), G) } (C.shapeFlag & 256 || pe && vo(pe.vnode) && pe.vnode.shapeFlag & 256) && p.a && at(p.a, G), p.isMounted = !0, C = I = H = null } }, Y = p.effect = new vl(te, () => Cl(P), p.scope), P = p.update = () => Y.run(); P.id = p.uid, On(p, !0), P() }, D = (p, C, I) => { C.component = p; const H = p.vnode.props; p.vnode = C, p.next = null, tv(p, C.props, H, I), rv(p, C.children, I), Ao(), _a(), Oo() }, oe = (p, C, I, H, G, re, se, te, Y = !1) => { const P = p && p.children, Q = p ? p.shapeFlag : 0, Z = C.children, { patchFlag: le, shapeFlag: he } = C; if (le > 0) { if (le & 128) { ne(P, Z, I, H, G, re, se, te, Y); return } else if (le & 256) { Ce(P, Z, I, H, G, re, se, te, Y); return } } he & 8 ? (Q & 16 && U(P, G, re), Z !== P && u(I, Z)) : Q & 16 ? he & 16 ? ne(P, Z, I, H, G, re, se, te, Y) : U(P, G, re, !0) : (Q & 8 && u(I, ""), he & 16 && q(Z, I, H, G, re, se, te, Y)) }, Ce = (p, C, I, H, G, re, se, te, Y) => { p = p || fo, C = C || fo; const P = p.length, Q = C.length, Z = Math.min(P, Q); let le; for (le = 0; le < Z; le++) { const he = C[le] = Y ? bn(C[le]) : Qt(C[le]); x(p[le], he, I, null, G, re, se, te, Y) } P > Q ? U(p, G, re, !0, !1, Z) : q(C, I, H, G, re, se, te, Y, Z) }, ne = (p, C, I, H, G, re, se, te, Y) => { let P = 0; const Q = C.length; let Z = p.length - 1, le = Q - 1; for (; P <= Z && P <= le;) { const he = p[P], me = C[P] = Y ? bn(C[P]) : Qt(C[P]); if (In(he, me)) x(he, me, I, null, G, re, se, te, Y); else break; P++ } for (; P <= Z && P <= le;) { const he = p[Z], me = C[le] = Y ? bn(C[le]) : Qt(C[le]); if (In(he, me)) x(he, me, I, null, G, re, se, te, Y); else break; Z--, le-- } if (P > Z) { if (P <= le) { const he = le + 1, me = he < Q ? C[he].el : H; for (; P <= le;)x(null, C[P] = Y ? bn(C[P]) : Qt(C[P]), I, me, G, re, se, te, Y), P++ } } else if (P > le) for (; P <= Z;)J(p[P], G, re, !0), P++; else { const he = P, me = P, pe = new Map; for (P = me; P <= le; P++) { const dt = C[P] = Y ? bn(C[P]) : Qt(C[P]); dt.key != null && pe.set(dt.key, P) } let be, Te = 0; const Ke = le - me + 1; let yt = !1, Jn = 0; const bt = new Array(Ke); for (P = 0; P < Ke; P++)bt[P] = 0; for (P = he; P <= Z; P++) { const dt = p[P]; if (Te >= Ke) { J(dt, G, re, !0); continue } let _t; if (dt.key != null) _t = pe.get(dt.key); else for (be = me; be <= le; be++)if (bt[be - me] === 0 && In(dt, C[be])) { _t = be; break } _t === void 0 ? J(dt, G, re, !0) : (bt[_t - me] = P + 1, _t >= Jn ? Jn = _t : yt = !0, x(dt, C[_t], I, null, G, re, se, te, Y), Te++) } const mt = yt ? uv(bt) : fo; for (be = mt.length - 1, P = Ke - 1; P >= 0; P--) { const dt = me + P, _t = C[dt], zo = dt + 1 < Q ? C[dt + 1].el : H; bt[P] === 0 ? x(null, _t, I, zo, G, re, se, te, Y) : yt && (be < 0 || P !== mt[be] ? O(_t, I, zo, 2) : be--) } } }, O = (p, C, I, H, G = null) => { const { el: re, type: se, transition: te, children: Y, shapeFlag: P } = p; if (P & 6) { O(p.component.subTree, C, I, H); return } if (P & 128) { p.suspense.move(C, I, H); return } if (P & 64) { se.move(p, C, I, W); return } if (se === Ue) { o(re, C, I); for (let Z = 0; Z < Y.length; Z++)O(Y[Z], C, I, H); o(p.anchor, C, I); return } if (se === ls) { m(p, C, I); return } if (H !== 2 && P & 1 && te) if (H === 0) te.beforeEnter(re), o(re, C, I), at(() => te.enter(re), G); else { const { leave: Z, delayLeave: le, afterLeave: he } = te, me = () => o(re, C, I), pe = () => { Z(re, () => { me(), he && he() }) }; le ? le(re, me, pe) : pe() } else o(re, C, I) }, J = (p, C, I, H = !1, G = !1) => { const { type: re, props: se, ref: te, children: Y, dynamicChildren: P, shapeFlag: Q, patchFlag: Z, dirs: le } = p; if (te != null && Fs(te, null, I, p, !0), Q & 256) { C.ctx.deactivate(p); return } const he = Q & 1 && le, me = !vo(p); let pe; if (me && (pe = se && se.onVnodeBeforeUnmount) && Tt(pe, C, p), Q & 6) N(p.component, I, H); else { if (Q & 128) { p.suspense.unmount(I, H); return } he && An(p, null, C, "beforeUnmount"), Q & 64 ? p.type.remove(p, C, I, G, W, H) : P && (re !== Ue || Z > 0 && Z & 64) ? U(P, C, I, !1, !0) : (re === Ue && Z & 384 || !G && Q & 16) && U(Y, C, I), H && ue(p) } (me && (pe = se && se.onVnodeUnmounted) || he) && at(() => { pe && Tt(pe, C, p), he && An(p, null, C, "unmounted") }, I) }, ue = p => { const { type: C, el: I, anchor: H, transition: G } = p; if (C === Ue) { we(I, H); return } if (C === ls) { w(p); return } const re = () => { r(I), G && !G.persisted && G.afterLeave && G.afterLeave() }; if (p.shapeFlag & 1 && G && !G.persisted) { const { leave: se, delayLeave: te } = G, Y = () => se(I, re); te ? te(p.el, re, Y) : Y() } else re() }, we = (p, C) => { let I; for (; p !== C;)I = f(p), r(p), p = I; r(C) }, N = (p, C, I) => { const { bum: H, scope: G, update: re, subTree: se, um: te } = p; H && nr(H), G.stop(), re && (re.active = !1, J(se, p, C, I)), te && at(te, C), at(() => { p.isUnmounted = !0 }, C), C && C.pendingBranch && !C.isUnmounted && p.asyncDep && !p.asyncResolved && p.suspenseId === C.pendingId && (C.deps--, C.deps === 0 && C.resolve()) }, U = (p, C, I, H = !1, G = !1, re = 0) => { for (let se = re; se < p.length; se++)J(p[se], C, I, H, G) }, L = p => p.shapeFlag & 6 ? L(p.component.subTree) : p.shapeFlag & 128 ? p.suspense.next() : f(p.anchor || p.el), X = (p, C, I) => { p == null ? C._vnode && J(C._vnode, null, null, !0) : x(C._vnode || null, p, C, null, null, null, I), _a(), Yc(), C._vnode = p }, W = { p: x, um: J, m: O, r: ue, mt: R, mc: q, pc: oe, pbc: B, n: L, o: e }; let ye, ge; return t && ([ye, ge] = t(W)), { render: X, hydrate: ye, createApp: sv(X, ye) } } function On({ effect: e, update: t }, n) { e.allowRecurse = t.allowRecurse = n } function Ol(e, t, n = !1) { const o = e.children, r = t.children; if (_e(o) && _e(r)) for (let i = 0; i < o.length; i++) { const s = o[i]; let l = r[i]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[i] = bn(r[i]), l.el = s.el), n || Ol(s, l)), l.type === Vi && (l.el = s.el) } } function uv(e) { const t = e.slice(), n = [0]; let o, r, i, s, l; const a = e.length; for (o = 0; o < a; o++) { const c = e[o]; if (c !== 0) { if (r = n[n.length - 1], e[r] < c) { t[o] = r, n.push(o); continue } for (i = 0, s = n.length - 1; i < s;)l = i + s >> 1, e[n[l]] < c ? i = l + 1 : s = l; c < e[n[i]] && (i > 0 && (t[o] = n[i - 1]), n[i] = o) } } for (i = n.length, s = n[i - 1]; i-- > 0;)n[i] = s, s = t[s]; return n } const cv = e => e.__isTeleport, rr = e => e && (e.disabled || e.disabled === ""), Aa = e => typeof SVGElement != "undefined" && e instanceof SVGElement, zs = (e, t) => { const n = e && e.to; return Ye(n) ? t ? t(n) : null : n }, dv = { __isTeleport: !0, process(e, t, n, o, r, i, s, l, a, c) { const { mc: u, pc: d, pbc: f, o: { insert: h, querySelector: v, createText: x, createComment: _ } } = c, A = rr(t.props); let { shapeFlag: g, children: m, dynamicChildren: w } = t; if (e == null) { const S = t.el = x(""), k = t.anchor = x(""); h(S, n, o), h(k, n, o); const T = t.target = zs(t.props, v), q = t.targetAnchor = x(""); T && (h(q, T), s = s || Aa(T)); const F = (B, j) => { g & 16 && u(m, B, j, r, i, s, l, a) }; A ? F(n, k) : T && F(T, q) } else { t.el = e.el; const S = t.anchor = e.anchor, k = t.target = e.target, T = t.targetAnchor = e.targetAnchor, q = rr(e.props), F = q ? n : k, B = q ? S : T; if (s = s || Aa(k), w ? (f(e.dynamicChildren, w, F, r, i, s, l), Ol(e, t, !0)) : a || d(e, t, F, B, r, i, s, l, !1), A) q || Hr(t, n, S, c, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const j = t.target = zs(t.props, v); j && Hr(t, j, null, c, 0) } else q && Hr(t, k, T, c, 1) } pd(t) }, remove(e, t, n, o, { um: r, o: { remove: i } }, s) { const { shapeFlag: l, children: a, anchor: c, targetAnchor: u, target: d, props: f } = e; if (d && i(u), (s || !rr(f)) && (i(c), l & 16)) for (let h = 0; h < a.length; h++) { const v = a[h]; r(v, t, n, !0, !!v.dynamicChildren) } }, move: Hr, hydrate: fv }; function Hr(e, t, n, { o: { insert: o }, m: r }, i = 2) { i === 0 && o(e.targetAnchor, t, n); const { el: s, anchor: l, shapeFlag: a, children: c, props: u } = e, d = i === 2; if (d && o(s, t, n), (!d || rr(u)) && a & 16) for (let f = 0; f < c.length; f++)r(c[f], t, n, 2); d && o(l, t, n) } function fv(e, t, n, o, r, i, { o: { nextSibling: s, parentNode: l, querySelector: a } }, c) { const u = t.target = zs(t.props, a); if (u) { const d = u._lpa || u.firstChild; if (t.shapeFlag & 16) if (rr(t.props)) t.anchor = c(s(e), t, l(e), n, o, r, i), t.targetAnchor = d; else { t.anchor = s(e); let f = d; for (; f;)if (f = s(f), f && f.nodeType === 8 && f.data === "teleport anchor") { t.targetAnchor = f, u._lpa = t.targetAnchor && s(t.targetAnchor); break } c(d, t, u, n, o, r, i) } pd(t) } return t.anchor && s(t.anchor) } const hv = dv; function pd(e) { const t = e.ctx; if (t && t.ut) { let n = e.children[0].el; for (; n !== e.targetAnchor;)n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling; t.ut() } } const Ue = Symbol(void 0), Vi = Symbol(void 0), gt = Symbol(void 0), ls = Symbol(void 0), ir = []; let jt = null; function Oe(e = !1) { ir.push(jt = e ? null : []) } function mv() { ir.pop(), jt = ir[ir.length - 1] || null } let yr = 1; function Oa(e) { yr += e } function gd(e) { return e.dynamicChildren = yr > 0 ? jt || fo : null, mv(), yr > 0 && jt && jt.push(e), e } function Yt(e, t, n, o, r, i) { return gd(V(e, t, n, o, r, i, !0)) } function Qe(e, t, n, o, r) { return gd(K(e, t, n, o, r, !0)) } function br(e) { return e ? e.__v_isVNode === !0 : !1 } function In(e, t) { return e.type === t.type && e.key === t.key } const Ni = "__vInternal", yd = ({ key: e }) => e != null ? e : null, ei = ({ ref: e, ref_key: t, ref_for: n }) => e != null ? Ye(e) || Ze(e) || Se(e) ? { i: ut, r: e, k: t, f: !!n } : e : null; function V(e, t = null, n = null, o = 0, r = null, i = e === Ue ? 0 : 1, s = !1, l = !1) { const a = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && yd(t), ref: t && ei(t), scopeId: $i, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: o, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: ut }; return l ? (Rl(a, n), i & 128 && e.normalize(a)) : n && (a.shapeFlag |= Ye(n) ? 8 : 16), yr > 0 && !s && jt && (a.patchFlag > 0 || i & 6) && a.patchFlag !== 32 && jt.push(a), a } const K = vv; function vv(e, t = null, n = null, o = 0, r = null, i = !1) { if ((!e || e === Um) && (e = gt), br(e)) { const l = dn(e, t, !0); return n && Rl(l, n), yr > 0 && !i && jt && (l.shapeFlag & 6 ? jt[jt.indexOf(e)] = l : jt.push(l)), l.patchFlag |= -2, l } if (kv(e) && (e = e.__vccOpts), t) { t = pv(t); let { class: l, style: a } = t; l && !Ye(l) && (t.class = Or(l)), De(a) && (Dc(a) && !_e(a) && (a = st({}, a)), t.style = Ar(a)) } const s = Ye(e) ? 1 : ed(e) ? 128 : cv(e) ? 64 : De(e) ? 4 : Se(e) ? 2 : 0; return V(e, t, n, o, r, s, i, !0) } function pv(e) { return e ? Dc(e) || Ni in e ? st({}, e) : e : null } function dn(e, t, n = !1) { const { props: o, ref: r, patchFlag: i, children: s } = e, l = t ? Ll(o || {}, t) : o; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: l, key: l && yd(l), ref: t && t.ref ? n && r ? _e(r) ? r.concat(ei(t)) : [r, ei(t)] : ei(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: s, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Ue ? i === -1 ? 16 : i | 16 : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && dn(e.ssContent), ssFallback: e.ssFallback && dn(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx } } function ie(e = " ", t = 0) { return K(Vi, null, e, t) } function Lr(e = "", t = !1) { return t ? (Oe(), Qe(gt, null, e)) : K(gt, null, e) } function Qt(e) { return e == null || typeof e == "boolean" ? K(gt) : _e(e) ? K(Ue, null, e.slice()) : typeof e == "object" ? bn(e) : K(Vi, null, String(e)) } function bn(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : dn(e) } function Rl(e, t) { let n = 0; const { shapeFlag: o } = e; if (t == null) t = null; else if (_e(t)) n = 16; else if (typeof t == "object") if (o & 65) { const r = t.default; r && (r._c && (r._d = !1), Rl(e, r()), r._c && (r._d = !0)); return } else { n = 32; const r = t._; !r && !(Ni in t) ? t._ctx = ut : r === 3 && ut && (ut.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else Se(t) ? (t = { default: t, _ctx: ut }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [ie(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Ll(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const o = e[n]; for (const r in o) if (r === "class") t.class !== o.class && (t.class = Or([t.class, o.class])); else if (r === "style") t.style = Ar([t.style, o.style]); else if (qi(r)) { const i = t[r], s = o[r]; s && i !== s && !(_e(i) && i.includes(s)) && (t[r] = i ? [].concat(i, s) : s) } else r !== "" && (t[r] = o[r]) } return t } function Tt(e, t, n, o = null) { $t(e, t, 7, [n, o]) } const gv = vd(); let yv = 0; function bv(e, t, n) { const o = e.type, r = (t ? t.appContext : e.appContext) || gv, i = { uid: yv++, vnode: e, type: o, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, scope: new Ac(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: dd(o, r), emitsOptions: Xc(o, r), emit: null, emitted: null, propsDefaults: je, inheritAttrs: o.inheritAttrs, ctx: je, data: je, props: je, attrs: je, slots: je, refs: je, setupState: je, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = Om.bind(null, i), e.ce && e.ce(i), i } let rt = null; const Ee = () => rt || ut, Co = e => { rt = e, e.scope.on() }, Un = () => { rt && rt.scope.off(), rt = null }; function bd(e) { return e.vnode.shapeFlag & 4 } let _r = !1; function _v(e, t = !1) { _r = t; const { props: n, children: o } = e.vnode, r = bd(e); ev(e, n, r, t), ov(e, o); const i = r ? wv(e, t) : void 0; return _r = !1, i } function wv(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = it(new Proxy(e.ctx, Qm)); const { setup: o } = n; if (o) { const r = e.setupContext = o.length > 1 ? xv(e) : null; Co(e), Ao(); const i = qn(o, e, 0, [e.props, r]); if (Oo(), Un(), qc(i)) { if (i.then(Un, Un), t) return i.then(s => { Ra(e, s, t) }).catch(s => { Ri(s, e, 0) }); e.asyncDep = i } else Ra(e, i, t) } else _d(e, t) } function Ra(e, t, n) { Se(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : De(t) && (e.setupState = Wc(t)), _d(e, n) } let La; function _d(e, t, n) { const o = e.type; if (!e.render) { if (!t && La && !o.render) { const r = o.template || Pl(e).template; if (r) { const { isCustomElement: i, compilerOptions: s } = e.appContext.config, { delimiters: l, compilerOptions: a } = o, c = st(st({ isCustomElement: i, delimiters: l }, s), a); o.render = La(r, c) } } e.render = o.render || Dt } Co(e), Ao(), Gm(e), Oo(), Un() } function Cv(e) { return new Proxy(e.attrs, { get(t, n) { return kt(e, "get", "$attrs"), t[n] } }) } function xv(e) { const t = o => { e.exposed = o || {} }; let n; return { get attrs() { return n || (n = Cv(e)) }, slots: e.slots, emit: e.emit, expose: t } } function ji(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Wc(it(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in or) return or[n](e) }, has(t, n) { return n in t || n in or } })) } function Vs(e, t = !0) { return Se(e) ? e.displayName || e.name : e.name || t && e.__name } function kv(e) { return Se(e) && "__vccOpts" in e } const y = (e, t) => Sm(e, t, _r); function b(e, t, n) { const o = arguments.length; return o === 2 ? De(t) && !_e(t) ? br(t) ? K(e, null, [t]) : K(e, t) : K(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && br(n) && (n = [n]), K(e, t, n)) } const Sv = Symbol(""), Ev = () => Le(Sv), qv = "3.2.45", Tv = "http://www.w3.org/2000/svg", Fn = typeof document != "undefined" ? document : null, $a = Fn && Fn.createElement("template"), Pv = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, o) => { const r = t ? Fn.createElementNS(Tv, e) : Fn.createElement(e, n ? { is: n } : void 0); return e === "select" && o && o.multiple != null && r.setAttribute("multiple", o.multiple), r }, createText: e => Fn.createTextNode(e), createComment: e => Fn.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Fn.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, o, r, i) { const s = n ? n.previousSibling : t.lastChild; if (r && (r === i || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === i || !(r = r.nextSibling));); else { $a.innerHTML = o ? `<svg>${e}</svg>` : e; const l = $a.content; if (o) { const a = l.firstChild; for (; a.firstChild;)l.appendChild(a.firstChild); l.removeChild(a) } t.insertBefore(l, n) } return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }; function Av(e, t, n) { const o = e._vtc; o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } function Ov(e, t, n) { const o = e.style, r = Ye(n); if (n && !r) { for (const i in n) Ns(o, i, n[i]); if (t && !Ye(t)) for (const i in t) n[i] == null && Ns(o, i, "") } else { const i = o.display; r ? t !== n && (o.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (o.display = i) } } const Ma = /\s*!important$/; function Ns(e, t, n) { if (_e(n)) n.forEach(o => Ns(e, t, o)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const o = Rv(e, t); Ma.test(n) ? e.setProperty(Po(o), n.replace(Ma, ""), "important") : e[o] = n } } const Ba = ["Webkit", "Moz", "ms"], as = {}; function Rv(e, t) { const n = as[t]; if (n) return n; let o = Xt(t); if (o !== "filter" && o in e) return as[t] = o; o = Ai(o); for (let r = 0; r < Ba.length; r++) { const i = Ba[r] + o; if (i in e) return as[t] = i } return t } const Ia = "http://www.w3.org/1999/xlink"; function Lv(e, t, n, o, r) { if (o && t.startsWith("xlink:")) n == null ? e.removeAttributeNS(Ia, t.slice(6, t.length)) : e.setAttributeNS(Ia, t, n); else { const i = Bh(t); n == null || i && !kc(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : n) } } function $v(e, t, n, o, r, i, s) { if (t === "innerHTML" || t === "textContent") { o && s(o, r, i), e[t] = n == null ? "" : n; return } if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) { e._value = n; const a = n == null ? "" : n; (e.value !== a || e.tagName === "OPTION") && (e.value = a), n == null && e.removeAttribute(t); return } let l = !1; if (n === "" || n == null) { const a = typeof e[t]; a === "boolean" ? n = kc(n) : n == null && a === "string" ? (n = "", l = !0) : a === "number" && (n = 0, l = !0) } try { e[t] = n } catch { } l && e.removeAttribute(t) } function Mv(e, t, n, o) { e.addEventListener(t, n, o) } function Bv(e, t, n, o) { e.removeEventListener(t, n, o) } function Iv(e, t, n, o, r = null) { const i = e._vei || (e._vei = {}), s = i[t]; if (o && s) s.value = o; else { const [l, a] = Fv(t); if (o) { const c = i[t] = Nv(o, r); Mv(e, l, c, a) } else s && (Bv(e, l, s, a), i[t] = void 0) } } const Fa = /(?:Once|Passive|Capture)$/; function Fv(e) { let t; if (Fa.test(e)) { t = {}; let o; for (; o = e.match(Fa);)e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Po(e.slice(2)), t] } let us = 0; const zv = Promise.resolve(), Vv = () => us || (zv.then(() => us = 0), us = Date.now()); function Nv(e, t) { const n = o => { if (!o._vts) o._vts = Date.now(); else if (o._vts <= n.attached) return; $t(jv(o, n.value), t, 5, [o]) }; return n.value = e, n.attached = Vv(), n } function jv(e, t) { if (_e(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(o => r => !r._stopped && o && o(r)) } else return t } const za = /^on[a-z]/, Dv = (e, t, n, o, r = !1, i, s, l, a) => { t === "class" ? Av(e, o, r) : t === "style" ? Ov(e, n, o) : qi(t) ? ul(t) || Iv(e, t, n, o, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Hv(e, t, o, r)) ? $v(e, t, o, i, s, l, a) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), Lv(e, t, o, r)) }; function Hv(e, t, n, o) { return o ? !!(t === "innerHTML" || t === "textContent" || t in e && za.test(t) && Se(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || za.test(t) && Ye(n) ? !1 : t in e } const pn = "transition", No = "animation", fn = (e, { slots: t }) => b(rd, Cd(e), t); fn.displayName = "Transition"; const wd = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Kv = fn.props = st({}, rd.props, wd), Rn = (e, t = []) => { _e(e) ? e.forEach(n => n(...t)) : e && e(...t) }, Va = e => e ? _e(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function Cd(e) { const t = {}; for (const $ in e) $ in wd || (t[$] = e[$]); if (e.css === !1) return t; const { name: n = "v", type: o, duration: r, enterFromClass: i = `${n}-enter-from`, enterActiveClass: s = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: a = i, appearActiveClass: c = s, appearToClass: u = l, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: f = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, v = Uv(r), x = v && v[0], _ = v && v[1], { onBeforeEnter: A, onEnter: g, onEnterCancelled: m, onLeave: w, onLeaveCancelled: S, onBeforeAppear: k = A, onAppear: T = g, onAppearCancelled: q = m } = t, F = ($, M, R) => { yn($, M ? u : l), yn($, M ? c : s), R && R() }, B = ($, M) => { $._isLeaving = !1, yn($, d), yn($, h), yn($, f), M && M() }, j = $ => (M, R) => { const ee = $ ? T : g, fe = () => F(M, $, R); Rn(ee, [M, fe]), Na(() => { yn(M, $ ? a : i), ln(M, $ ? u : l), Va(ee) || ja(M, o, x, fe) }) }; return st(t, { onBeforeEnter($) { Rn(A, [$]), ln($, i), ln($, s) }, onBeforeAppear($) { Rn(k, [$]), ln($, a), ln($, c) }, onEnter: j(!1), onAppear: j(!0), onLeave($, M) { $._isLeaving = !0; const R = () => B($, M); ln($, d), kd(), ln($, f), Na(() => { !$._isLeaving || (yn($, d), ln($, h), Va(w) || ja($, o, _, R)) }), Rn(w, [$, R]) }, onEnterCancelled($) { F($, !1), Rn(m, [$]) }, onAppearCancelled($) { F($, !0), Rn(q, [$]) }, onLeaveCancelled($) { B($), Rn(S, [$]) } }) } function Uv(e) { if (e == null) return null; if (De(e)) return [cs(e.enter), cs(e.leave)]; { const t = cs(e); return [t, t] } } function cs(e) { return hl(e) } function ln(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e._vtc || (e._vtc = new Set)).add(t) } function yn(e, t) { t.split(/\s+/).forEach(o => o && e.classList.remove(o)); const { _vtc: n } = e; n && (n.delete(t), n.size || (e._vtc = void 0)) } function Na(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let Wv = 0; function ja(e, t, n, o) { const r = e._endId = ++Wv, i = () => { r === e._endId && o() }; if (n) return setTimeout(i, n); const { type: s, timeout: l, propCount: a } = xd(e, t); if (!s) return o(); const c = s + "end"; let u = 0; const d = () => { e.removeEventListener(c, f), i() }, f = h => { h.target === e && ++u >= a && d() }; setTimeout(() => { u < a && d() }, l + 1), e.addEventListener(c, f) } function xd(e, t) { const n = window.getComputedStyle(e), o = v => (n[v] || "").split(", "), r = o(`${pn}Delay`), i = o(`${pn}Duration`), s = Da(r, i), l = o(`${No}Delay`), a = o(`${No}Duration`), c = Da(l, a); let u = null, d = 0, f = 0; t === pn ? s > 0 && (u = pn, d = s, f = i.length) : t === No ? c > 0 && (u = No, d = c, f = a.length) : (d = Math.max(s, c), u = d > 0 ? s > c ? pn : No : null, f = u ? u === pn ? i.length : a.length : 0); const h = u === pn && /\b(transform|all)(,|$)/.test(o(`${pn}Property`).toString()); return { type: u, timeout: d, propCount: f, hasTransform: h } } function Da(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, o) => Ha(n) + Ha(e[o]))) } function Ha(e) { return Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function kd() { return document.body.offsetHeight } const Sd = new WeakMap, Ed = new WeakMap, Qv = { name: "TransitionGroup", props: st({}, Kv, { tag: String, moveClass: String }), setup(e, { slots: t }) { const n = Ee(), o = od(); let r, i; return Ii(() => { if (!r.length) return; const s = e.moveClass || `${e.name || "v"}-move`; if (!Xv(r[0].el, n.vnode.el, s)) return; r.forEach(Zv), r.forEach(Yv); const l = r.filter(Jv); kd(), l.forEach(a => { const c = a.el, u = c.style; ln(c, s), u.transform = u.webkitTransform = u.transitionDuration = ""; const d = c._moveCb = f => { f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", d), c._moveCb = null, yn(c, s)) }; c.addEventListener("transitionend", d) }) }), () => { const s = ke(e), l = Cd(s); let a = s.tag || Ue; r = i, i = t.default ? El(t.default()) : []; for (let c = 0; c < i.length; c++) { const u = i[c]; u.key != null && wo(u, gr(u, l, o, n)) } if (r) for (let c = 0; c < r.length; c++) { const u = r[c]; wo(u, gr(u, l, o, n)), Sd.set(u, u.el.getBoundingClientRect()) } return K(a, null, i) } } }, Gv = Qv; function Zv(e) { const t = e.el; t._moveCb && t._moveCb(), t._enterCb && t._enterCb() } function Yv(e) { Ed.set(e, e.el.getBoundingClientRect()) } function Jv(e) { const t = Sd.get(e), n = Ed.get(e), o = t.left - n.left, r = t.top - n.top; if (o || r) { const i = e.el.style; return i.transform = i.webkitTransform = `translate(${o}px,${r}px)`, i.transitionDuration = "0s", e } } function Xv(e, t, n) { const o = e.cloneNode(); e._vtc && e._vtc.forEach(s => { s.split(/\s+/).forEach(l => l && o.classList.remove(l)) }), n.split(/\s+/).forEach(s => s && o.classList.add(s)), o.style.display = "none"; const r = t.nodeType === 1 ? t : t.parentNode; r.appendChild(o); const { hasTransform: i } = xd(o); return r.removeChild(o), i } const ep = ["ctrl", "shift", "alt", "meta"], tp = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => ep.some(n => e[`${n}Key`] && !t.includes(n)) }, fi = (e, t) => (n, ...o) => { for (let r = 0; r < t.length; r++) { const i = tp[t[r]]; if (i && i(n, t)) return } return e(n, ...o) }, np = { beforeMount(e, { value: t }, { transition: n }) { e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : jo(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: o }) { !t != !n && (o ? t ? (o.beforeEnter(e), jo(e, !0), o.enter(e)) : o.leave(e, () => { jo(e, !1) }) : jo(e, t)) }, beforeUnmount(e, { value: t }) { jo(e, t) } }; function jo(e, t) { e.style.display = t ? e._vod : "none" } const op = st({ patchProp: Dv }, Pv); let Ka; function rp() { return Ka || (Ka = lv(op)) } const qd = (...e) => { const t = rp().createApp(...e), { mount: n } = t; return t.mount = o => { const r = ip(o); if (!r) return; const i = t._component; !Se(i) && !i.render && !i.template && (i.template = r.innerHTML), r.innerHTML = ""; const s = n(r, !1, r instanceof SVGElement); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s }, t }; function ip(e) { return Ye(e) ? document.querySelector(e) : e } function Ro(e, t, n, o) { return Object.defineProperty(e, t, { get: n, set: o, enumerable: !0 }), e } const Ht = z(!1); let Di; function sp(e, t) { const n = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(vivaldi)[\/]([\w.]+)/.exec(e) || /(chrome|crios)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(firefox|fxios)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(e) || []; return { browser: n[5] || n[3] || n[1] || "", version: n[2] || n[4] || "0", versionNumber: n[4] || n[2] || "0", platform: t[0] || "" } } function lp(e) { return /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(silk)/.exec(e) || /(android)/.exec(e) || /(win)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || /(playbook)/.exec(e) || /(bb)/.exec(e) || /(blackberry)/.exec(e) || [] } const Td = "ontouchstart" in window || window.navigator.maxTouchPoints > 0; function ap(e) { Di = { is: { ...e } }, delete e.mac, delete e.desktop; const t = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone"; Object.assign(e, { mobile: !0, ios: !0, platform: t, [t]: !0 }) } function up(e) { const t = e.toLowerCase(), n = lp(t), o = sp(t, n), r = {}; o.browser && (r[o.browser] = !0, r.version = o.version, r.versionNumber = parseInt(o.versionNumber, 10)), o.platform && (r[o.platform] = !0); const i = r.android || r.ios || r.bb || r.blackberry || r.ipad || r.iphone || r.ipod || r.kindle || r.playbook || r.silk || r["windows phone"]; return i === !0 || t.indexOf("mobile") > -1 ? (r.mobile = !0, r.edga || r.edgios ? (r.edge = !0, o.browser = "edge") : r.crios ? (r.chrome = !0, o.browser = "chrome") : r.fxios && (r.firefox = !0, o.browser = "firefox")) : r.desktop = !0, (r.ipod || r.ipad || r.iphone) && (r.ios = !0), r["windows phone"] && (r.winphone = !0, delete r["windows phone"]), (r.chrome || r.opr || r.safari || r.vivaldi || r.mobile === !0 && r.ios !== !0 && i !== !0) && (r.webkit = !0), r.edg && (o.browser = "edgechromium", r.edgeChromium = !0), (r.safari && r.blackberry || r.bb) && (o.browser = "blackberry", r.blackberry = !0), r.safari && r.playbook && (o.browser = "playbook", r.playbook = !0), r.opr && (o.browser = "opera", r.opera = !0), r.safari && r.android && (o.browser = "android", r.android = !0), r.safari && r.kindle && (o.browser = "kindle", r.kindle = !0), r.safari && r.silk && (o.browser = "silk", r.silk = !0), r.vivaldi && (o.browser = "vivaldi", r.vivaldi = !0), r.name = o.browser, r.platform = o.platform, t.indexOf("electron") > -1 ? r.electron = !0 : document.location.href.indexOf("-extension://") > -1 ? r.bex = !0 : (window.Capacitor !== void 0 ? (r.capacitor = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "capacitor") : (window._cordovaNative !== void 0 || window.cordova !== void 0) && (r.cordova = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "cordova"), Td === !0 && r.mac === !0 && (r.desktop === !0 && r.safari === !0 || r.nativeMobile === !0 && r.android !== !0 && r.ios !== !0 && r.ipad !== !0) && ap(r)), r } const Ua = navigator.userAgent || navigator.vendor || window.opera, cp = { has: { touch: !1, webStorage: !1 }, within: { iframe: !1 } }, Fe = { userAgent: Ua, is: up(Ua), has: { touch: Td }, within: { iframe: window.self !== window.top } }, hi = { install(e) { const { $q: t } = e; Ht.value === !0 ? (e.onSSRHydrated.push(() => { Object.assign(t.platform, Fe), Ht.value = !1, Di = void 0 }), t.platform = Ot(this)) : t.platform = this } }; { let e; Ro(Fe.has, "webStorage", () => { if (e !== void 0) return e; try { if (window.localStorage) return e = !0, !0 } catch { } return e = !1, !1 }), Fe.is.ios === !0 && window.navigator.vendor.toLowerCase().indexOf("apple"), Ht.value === !0 ? Object.assign(hi, Fe, Di, cp) : Object.assign(hi, Fe) } var $r = (e, t) => { const n = Ot(e); for (const o in e) Ro(t, o, () => n[o], r => { n[o] = r }); return t }; const Je = { hasPassive: !1, passiveCapture: !0, notPassiveCapture: !0 }; try { const e = Object.defineProperty({}, "passive", { get() { Object.assign(Je, { hasPassive: !0, passive: { passive: !0 }, notPassive: { passive: !1 }, passiveCapture: { passive: !0, capture: !0 }, notPassiveCapture: { passive: !1, capture: !0 } }) } }); window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e) } catch { } function hn() { } function dp(e) { return e.button === 0 } function mi(e) { return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), { top: e.clientY, left: e.clientX } } function fp(e) { if (e.path) return e.path; if (e.composedPath) return e.composedPath(); const t = []; let n = e.target; for (; n;) { if (t.push(n), n.tagName === "HTML") return t.push(document), t.push(window), t; n = n.parentElement } } function Gt(e) { e.stopPropagation() } function Ct(e) { e.cancelable !== !1 && e.preventDefault() } function Be(e) { e.cancelable !== !1 && e.preventDefault(), e.stopPropagation() } function ds(e, t) { if (e === void 0 || t === !0 && e.__dragPrevented === !0) return; const n = t === !0 ? o => { o.__dragPrevented = !0, o.addEventListener("dragstart", Ct, Je.notPassiveCapture) } : o => { delete o.__dragPrevented, o.removeEventListener("dragstart", Ct, Je.notPassiveCapture) }; e.querySelectorAll("a, img").forEach(n) } function Nn(e, t, n) { const o = `__q_${t}_evt`; e[o] = e[o] !== void 0 ? e[o].concat(n) : n, n.forEach(r => { r[0].addEventListener(r[1], e[r[2]], Je[r[3]]) }) } function sr(e, t) { const n = `__q_${t}_evt`; e[n] !== void 0 && (e[n].forEach(o => { o[0].removeEventListener(o[1], e[o[2]], Je[o[3]]) }), e[n] = void 0) } function $l(e, t = 250, n) { let o = null; function r() { const i = arguments, s = () => { o = null, n !== !0 && e.apply(this, i) }; o !== null ? clearTimeout(o) : n === !0 && e.apply(this, i), o = setTimeout(s, t) } return r.cancel = () => { o !== null && clearTimeout(o) }, r } const fs = ["sm", "md", "lg", "xl"], { passive: Wa } = Je; var hp = $r({ width: 0, height: 0, name: "xs", sizes: { sm: 600, md: 1024, lg: 1440, xl: 1920 }, lt: { sm: !0, md: !0, lg: !0, xl: !0 }, gt: { xs: !1, sm: !1, md: !1, lg: !1 }, xs: !0, sm: !1, md: !1, lg: !1, xl: !1 }, { setSizes: hn, setDebounce: hn, install({ $q: e, onSSRHydrated: t }) { if (e.screen = this, this.__installed === !0) { e.config.screen !== void 0 && (e.config.screen.bodyClasses === !1 ? document.body.classList.remove(`screen--${this.name}`) : this.__update(!0)); return } const { visualViewport: n } = window, o = n || window, r = document.scrollingElement || document.documentElement, i = n === void 0 || Fe.is.mobile === !0 ? () => [Math.max(window.innerWidth, r.clientWidth), Math.max(window.innerHeight, r.clientHeight)] : () => [n.width * n.scale + window.innerWidth - r.clientWidth, n.height * n.scale + window.innerHeight - r.clientHeight], s = e.config.screen !== void 0 && e.config.screen.bodyClasses === !0; this.__update = d => { const [f, h] = i(); if (h !== this.height && (this.height = h), f !== this.width) this.width = f; else if (d !== !0) return; let v = this.sizes; this.gt.xs = f >= v.sm, this.gt.sm = f >= v.md, this.gt.md = f >= v.lg, this.gt.lg = f >= v.xl, this.lt.sm = f < v.sm, this.lt.md = f < v.md, this.lt.lg = f < v.lg, this.lt.xl = f < v.xl, this.xs = this.lt.sm, this.sm = this.gt.xs === !0 && this.lt.md === !0, this.md = this.gt.sm === !0 && this.lt.lg === !0, this.lg = this.gt.md === !0 && this.lt.xl === !0, this.xl = this.gt.lg, v = this.xs === !0 && "xs" || this.sm === !0 && "sm" || this.md === !0 && "md" || this.lg === !0 && "lg" || "xl", v !== this.name && (s === !0 && (document.body.classList.remove(`screen--${this.name}`), document.body.classList.add(`screen--${v}`)), this.name = v) }; let l, a = {}, c = 16; this.setSizes = d => { fs.forEach(f => { d[f] !== void 0 && (a[f] = d[f]) }) }, this.setDebounce = d => { c = d }; const u = () => { const d = getComputedStyle(document.body); d.getPropertyValue("--q-size-sm") && fs.forEach(f => { this.sizes[f] = parseInt(d.getPropertyValue(`--q-size-${f}`), 10) }), this.setSizes = f => { fs.forEach(h => { f[h] && (this.sizes[h] = f[h]) }), this.__update(!0) }, this.setDebounce = f => { l !== void 0 && o.removeEventListener("resize", l, Wa), l = f > 0 ? $l(this.__update, f) : this.__update, o.addEventListener("resize", l, Wa) }, this.setDebounce(c), Object.keys(a).length > 0 ? (this.setSizes(a), a = void 0) : this.__update(), s === !0 && this.name === "xs" && document.body.classList.add("screen--xs") }; Ht.value === !0 ? t.push(u) : u() } }); const ft = $r({ isActive: !1, mode: !1 }, { __media: void 0, set(e) { ft.mode = e, e === "auto" ? (ft.__media === void 0 && (ft.__media = window.matchMedia("(prefers-color-scheme: dark)"), ft.__updateMedia = () => { ft.set("auto") }, ft.__media.addListener(ft.__updateMedia)), e = ft.__media.matches) : ft.__media !== void 0 && (ft.__media.removeListener(ft.__updateMedia), ft.__media = void 0), ft.isActive = e === !0, document.body.classList.remove(`body--${e === !0 ? "light" : "dark"}`), document.body.classList.add(`body--${e === !0 ? "dark" : "light"}`) }, toggle() { ft.set(ft.isActive === !1) }, install({ $q: e, onSSRHydrated: t, ssrContext: n }) { const { dark: o } = e.config; if (e.dark = this, this.__installed === !0 && o === void 0) return; this.isActive = o === !0; const r = o !== void 0 ? o : !1; if (Ht.value === !0) { const i = l => { this.__fromSSR = l }, s = this.set; this.set = i, i(r), t.push(() => { this.set = s, this.set(this.__fromSSR) }) } else this.set(r) } }), Pd = () => !0; function mp(e) { return typeof e == "string" && e !== "" && e !== "/" && e !== "#/" } function vp(e) { return e.startsWith("#") === !0 && (e = e.substring(1)), e.startsWith("/") === !1 && (e = "/" + e), e.endsWith("/") === !0 && (e = e.substring(0, e.length - 1)), "#" + e } function pp(e) { if (e.backButtonExit === !1) return () => !1; if (e.backButtonExit === "*") return Pd; const t = ["#/"]; return Array.isArray(e.backButtonExit) === !0 && t.push(...e.backButtonExit.filter(mp).map(vp)), () => t.includes(window.location.hash) } var wr = { __history: [], add: hn, remove: hn, install({ $q: e }) { if (this.__installed === !0) return; const { cordova: t, capacitor: n } = Fe.is; if (t !== !0 && n !== !0) return; const o = e.config[t === !0 ? "cordova" : "capacitor"]; if (o !== void 0 && o.backButton === !1 || n === !0 && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)) return; this.add = s => { s.condition === void 0 && (s.condition = Pd), this.__history.push(s) }, this.remove = s => { const l = this.__history.indexOf(s); l >= 0 && this.__history.splice(l, 1) }; const r = pp(Object.assign({ backButtonExit: !0 }, o)), i = () => { if (this.__history.length) { const s = this.__history[this.__history.length - 1]; s.condition() === !0 && (this.__history.pop(), s.handler()) } else r() === !0 ? navigator.app.exitApp() : window.history.back() }; t === !0 ? document.addEventListener("deviceready", () => { document.addEventListener("backbutton", i, !1) }) : window.Capacitor.Plugins.App.addListener("backButton", i) } }, Qa = { isoName: "en-US", nativeName: "English (US)", label: { clear: "Clear", ok: "OK", cancel: "Cancel", close: "Close", set: "Set", select: "Select", reset: "Reset", remove: "Remove", update: "Update", create: "Create", search: "Search", filter: "Filter", refresh: "Refresh", expand: e => e ? `Expand "${e}"` : "Expand", collapse: e => e ? `Collapse "${e}"` : "Collapse" }, date: { days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), firstDayOfWeek: 0, format24h: !1, pluralDay: "days" }, table: { noData: "No data available", noResults: "No matching records found", loading: "Loading...", selectedRecords: e => e === 1 ? "1 record selected." : (e === 0 ? "No" : e) + " records selected.", recordsPerPage: "Records per page:", allRows: "All", pagination: (e, t, n) => e + "-" + t + " of " + n, columns: "Columns" }, editor: { url: "URL", bold: "Bold", italic: "Italic", strikethrough: "Strikethrough", underline: "Underline", unorderedList: "Unordered List", orderedList: "Ordered List", subscript: "Subscript", superscript: "Superscript", hyperlink: "Hyperlink", toggleFullscreen: "Toggle Fullscreen", quote: "Quote", left: "Left align", center: "Center align", right: "Right align", justify: "Justify align", print: "Print", outdent: "Decrease indentation", indent: "Increase indentation", removeFormat: "Remove formatting", formatting: "Formatting", fontSize: "Font Size", align: "Align", hr: "Insert Horizontal Rule", undo: "Undo", redo: "Redo", heading1: "Heading 1", heading2: "Heading 2", heading3: "Heading 3", heading4: "Heading 4", heading5: "Heading 5", heading6: "Heading 6", paragraph: "Paragraph", code: "Code", size1: "Very small", size2: "A bit small", size3: "Normal", size4: "Medium-large", size5: "Big", size6: "Very big", size7: "Maximum", defaultFont: "Default Font", viewSource: "View Source" }, tree: { noNodes: "No nodes available", noResults: "No matching nodes found" } }; function Ga() { const e = Array.isArray(navigator.languages) === !0 && navigator.languages.length > 0 ? navigator.languages[0] : navigator.language; if (typeof e == "string") return e.split(/[-_]/).map((t, n) => n === 0 ? t.toLowerCase() : n > 1 || t.length < 4 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1).toLowerCase()).join("-") } const It = $r({ __langPack: {} }, { getLocale: Ga, set(e = Qa, t) { const n = { ...e, rtl: e.rtl === !0, getLocale: Ga }; { if (n.set = It.set, It.__langConfig === void 0 || It.__langConfig.noHtmlAttrs !== !0) { const o = document.documentElement; o.setAttribute("dir", n.rtl === !0 ? "rtl" : "ltr"), o.setAttribute("lang", n.isoName) } Object.assign(It.__langPack, n), It.props = n, It.isoName = n.isoName, It.nativeName = n.nativeName } }, install({ $q: e, lang: t, ssrContext: n }) { e.lang = It.__langPack, It.__langConfig = e.config.lang, this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || Qa) } }); function gp(e, t, n = document.body) { if (typeof e != "string") throw new TypeError("Expected a string as propName"); if (typeof t != "string") throw new TypeError("Expected a string as value"); if (!(n instanceof Element)) throw new TypeError("Expected a DOM element"); n.style.setProperty(`--q-${e}`, t) } let Ad = !1; function yp(e) { Ad = e.isComposing === !0 } function Hi(e) { return Ad === !0 || e !== Object(e) || e.isComposing === !0 || e.qKeyEvent === !0 } function en(e, t) { return Hi(e) === !0 ? !1 : [].concat(t).includes(e.keyCode) } function Od(e) { if (e.ios === !0) return "ios"; if (e.android === !0) return "android" } function bp({ is: e, has: t, within: n }, o) { const r = [e.desktop === !0 ? "desktop" : "mobile", `${t.touch === !1 ? "no-" : ""}touch`]; if (e.mobile === !0) { const i = Od(e); i !== void 0 && r.push("platform-" + i) } if (e.nativeMobile === !0) { const i = e.nativeMobileWrapper; r.push(i), r.push("native-mobile"), e.ios === !0 && (o[i] === void 0 || o[i].iosStatusBarPadding !== !1) && r.push("q-ios-padding") } else e.electron === !0 ? r.push("electron") : e.bex === !0 && r.push("bex"); return n.iframe === !0 && r.push("within-iframe"), r } function _p() { const { is: e } = Fe, t = document.body.className, n = new Set(t.replace(/ {2}/g, " ").split(" ")); if (Di !== void 0) n.delete("desktop"), n.add("platform-ios"), n.add("mobile"); else if (e.nativeMobile !== !0 && e.electron !== !0 && e.bex !== !0) { if (e.desktop === !0) n.delete("mobile"), n.delete("platform-ios"), n.delete("platform-android"), n.add("desktop"); else if (e.mobile === !0) { n.delete("desktop"), n.add("mobile"); const r = Od(e); r !== void 0 ? (n.add(`platform-${r}`), n.delete(`platform-${r === "ios" ? "android" : "ios"}`)) : (n.delete("platform-ios"), n.delete("platform-android")) } } Fe.has.touch === !0 && (n.delete("no-touch"), n.add("touch")), Fe.within.iframe === !0 && n.add("within-iframe"); const o = Array.from(n).join(" "); t !== o && (document.body.className = o) } function wp(e) { for (const t in e) gp(t, e[t]) } var Cp = { install(e) { if (this.__installed !== !0) { if (Ht.value === !0) _p(); else { const { $q: t } = e; t.config.brand !== void 0 && wp(t.config.brand); const n = bp(Fe, t.config); document.body.classList.add.apply(document.body.classList, n) } Fe.is.ios === !0 && document.body.addEventListener("touchstart", hn), window.addEventListener("keydown", yp, !0) } } }, xp = { name: "material-icons", type: { positive: "check_circle", negative: "warning", info: "info", warning: "priority_high" }, arrow: { up: "arrow_upward", right: "arrow_forward", down: "arrow_downward", left: "arrow_back", dropdown: "arrow_drop_down" }, chevron: { left: "chevron_left", right: "chevron_right" }, colorPicker: { spectrum: "gradient", tune: "tune", palette: "style" }, pullToRefresh: { icon: "refresh" }, carousel: { left: "chevron_left", right: "chevron_right", up: "keyboard_arrow_up", down: "keyboard_arrow_down", navigationIcon: "lens" }, chip: { remove: "cancel", selected: "check" }, datetime: { arrowLeft: "chevron_left", arrowRight: "chevron_right", now: "access_time", today: "today" }, editor: { bold: "format_bold", italic: "format_italic", strikethrough: "strikethrough_s", underline: "format_underlined", unorderedList: "format_list_bulleted", orderedList: "format_list_numbered", subscript: "vertical_align_bottom", superscript: "vertical_align_top", hyperlink: "link", toggleFullscreen: "fullscreen", quote: "format_quote", left: "format_align_left", center: "format_align_center", right: "format_align_right", justify: "format_align_justify", print: "print", outdent: "format_indent_decrease", indent: "format_indent_increase", removeFormat: "format_clear", formatting: "text_format", fontSize: "format_size", align: "format_align_left", hr: "remove", undo: "undo", redo: "redo", heading: "format_size", code: "code", size: "format_size", font: "font_download", viewSource: "code" }, expansionItem: { icon: "keyboard_arrow_down", denseIcon: "arrow_drop_down" }, fab: { icon: "add", activeIcon: "close" }, field: { clear: "cancel", error: "error" }, pagination: { first: "first_page", prev: "keyboard_arrow_left", next: "keyboard_arrow_right", last: "last_page" }, rating: { icon: "grade" }, stepper: { done: "check", active: "edit", error: "warning" }, tabs: { left: "chevron_left", right: "chevron_right", up: "keyboard_arrow_up", down: "keyboard_arrow_down" }, table: { arrowUp: "arrow_upward", warning: "warning", firstPage: "first_page", prevPage: "chevron_left", nextPage: "chevron_right", lastPage: "last_page" }, tree: { icon: "play_arrow" }, uploader: { done: "done", clear: "clear", add: "add_box", upload: "cloud_upload", removeQueue: "clear_all", removeUploaded: "done_all" } }; const vi = $r({ iconMapFn: null, __icons: {} }, { set(e, t) { const n = { ...e, rtl: e.rtl === !0 }; n.set = vi.set, Object.assign(vi.__icons, n) }, install({ $q: e, iconSet: t, ssrContext: n }) { e.config.iconMapFn !== void 0 && (this.iconMapFn = e.config.iconMapFn), e.iconSet = this.__icons, Ro(e, "iconMapFn", () => this.iconMapFn, o => { this.iconMapFn = o }), this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || xp) } }), kp = "_q_", Mr = "_q_l_", Rd = "_q_pc_", Ld = "_q_fo_", $d = "_q_tabs_", ot = () => { }, pi = {}; let Md = !1; function Sp() { Md = !0 } function un(e, t) { if (e === t) return !0; if (e !== null && t !== null && typeof e == "object" && typeof t == "object") { if (e.constructor !== t.constructor) return !1; let n, o; if (e.constructor === Array) { if (n = e.length, n !== t.length) return !1; for (o = n; o-- !== 0;)if (un(e[o], t[o]) !== !0) return !1; return !0 } if (e.constructor === Map) { if (e.size !== t.size) return !1; let i = e.entries(); for (o = i.next(); o.done !== !0;) { if (t.has(o.value[0]) !== !0) return !1; o = i.next() } for (i = e.entries(), o = i.next(); o.done !== !0;) { if (un(o.value[1], t.get(o.value[0])) !== !0) return !1; o = i.next() } return !0 } if (e.constructor === Set) { if (e.size !== t.size) return !1; const i = e.entries(); for (o = i.next(); o.done !== !0;) { if (t.has(o.value[0]) !== !0) return !1; o = i.next() } return !0 } if (e.buffer != null && e.buffer.constructor === ArrayBuffer) { if (n = e.length, n !== t.length) return !1; for (o = n; o-- !== 0;)if (e[o] !== t[o]) return !1; return !0 } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString) return e.toString() === t.toString(); const r = Object.keys(e).filter(i => e[i] !== void 0); if (n = r.length, n !== Object.keys(t).filter(i => t[i] !== void 0).length) return !1; for (o = n; o-- !== 0;) { const i = r[o]; if (un(e[i], t[i]) !== !0) return !1 } return !0 } return e !== e && t !== t } function At(e) { return e !== null && typeof e == "object" && Array.isArray(e) !== !0 } function Ep(e) { return typeof e == "number" && isFinite(e) } const Za = [hi, Cp, ft, hp, wr, It, vi]; function Ml(e, t) { const n = qd(e); n.config.globalProperties = t.config.globalProperties; const { reload: o, ...r } = t._context; return Object.assign(n._context, r), n } function Ya(e, t) { t.forEach(n => { n.install(e), n.__installed = !0 }) } function qp(e, t, n) { e.config.globalProperties.$q = n.$q, e.provide(kp, n.$q), Ya(n, Za), t.components !== void 0 && Object.values(t.components).forEach(o => { At(o) === !0 && o.name !== void 0 && e.component(o.name, o) }), t.directives !== void 0 && Object.values(t.directives).forEach(o => { At(o) === !0 && o.name !== void 0 && e.directive(o.name, o) }), t.plugins !== void 0 && Ya(n, Object.values(t.plugins).filter(o => typeof o.install == "function" && Za.includes(o) === !1)), Ht.value === !0 && (n.$q.onSSRHydrated = () => { n.onSSRHydrated.forEach(o => { o() }), n.$q.onSSRHydrated = () => { } }) } var Tp = function (e, t = {}) { const n = { version: "2.11.5" }; Md === !1 ? (t.config !== void 0 && Object.assign(pi, t.config), n.config = { ...pi }, Sp()) : n.config = t.config || {}, qp(e, t, { parentApp: e, $q: n, lang: t.lang, iconSet: t.iconSet, onSSRHydrated: [] }) }, Pp = { version: "2.11.5", install: Tp, lang: It, iconSet: vi }, Mt = (e, t) => { const n = e.__vccOpts || e; for (const [o, r] of t) n[o] = r; return n }; const Ap = Ne({ name: "App" }); function Op(e, t, n, o, r, i) { const s = Pt("router-view"); return Oe(), Qe(s) } var Rp = Mt(Ap, [["render", Op]]); function l1(e) { return e } var Lp = !1;/*!
  * pinia v2.0.29
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */let Bd; const Ki = e => Bd = e, Id = Symbol(); function js(e) { return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function" } var lr; (function (e) { e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function" })(lr || (lr = {})); function $p() { const e = Oc(!0), t = e.run(() => z({})); let n = [], o = []; const r = it({ install(i) { Ki(r), r._a = i, i.provide(Id, r), i.config.globalProperties.$pinia = r, o.forEach(s => n.push(s)), o = [] }, use(i) { return !this._a && !Lp ? o.push(i) : n.push(i), this }, _p: n, _a: null, _e: e, _s: new Map, state: t }); return r } const Fd = () => { }; function Ja(e, t, n, o = Fd) { e.push(t); const r = () => { const i = e.indexOf(t); i > -1 && (e.splice(i, 1), o()) }; return !n && Kh() && Uh(r), r } function oo(e, ...t) { e.slice().forEach(n => { n(...t) }) } function Ds(e, t) { e instanceof Map && t instanceof Map && t.forEach((n, o) => e.set(o, n)), e instanceof Set && t instanceof Set && t.forEach(e.add, e); for (const n in t) { if (!t.hasOwnProperty(n)) continue; const o = t[n], r = e[n]; js(r) && js(o) && e.hasOwnProperty(n) && !Ze(o) && !En(o) ? e[n] = Ds(r, o) : e[n] = o } return e } const Mp = Symbol(); function Bp(e) { return !js(e) || !e.hasOwnProperty(Mp) } const { assign: _n } = Object; function Ip(e) { return !!(Ze(e) && e.effect) } function Fp(e, t, n, o) { const { state: r, actions: i, getters: s } = t, l = n.state.value[e]; let a; function c() { l || (n.state.value[e] = r ? r() : {}); const u = Cm(n.state.value[e]); return _n(u, i, Object.keys(s || {}).reduce((d, f) => (d[f] = it(y(() => { Ki(n); const h = n._s.get(e); return s[f].call(h, h) })), d), {})) } return a = zd(e, c, t, n, o, !0), a.$reset = function () { const d = r ? r() : {}; this.$patch(f => { _n(f, d) }) }, a } function zd(e, t, n = {}, o, r, i) { let s; const l = _n({ actions: {} }, n), a = { deep: !0 }; let c, u, d = it([]), f = it([]), h; const v = o.state.value[e]; !i && !v && (o.state.value[e] = {}), z({}); let x; function _(T) { let q; c = u = !1, typeof T == "function" ? (T(o.state.value[e]), q = { type: lr.patchFunction, storeId: e, events: h }) : (Ds(o.state.value[e], T), q = { type: lr.patchObject, payload: T, storeId: e, events: h }); const F = x = Symbol(); Ie().then(() => { x === F && (c = !0) }), u = !0, oo(d, q, o.state.value[e]) } const A = Fd; function g() { s.stop(), d = [], f = [], o._s.delete(e) } function m(T, q) { return function () { Ki(o); const F = Array.from(arguments), B = [], j = []; function $(ee) { B.push(ee) } function M(ee) { j.push(ee) } oo(f, { args: F, name: T, store: S, after: $, onError: M }); let R; try { R = q.apply(this && this.$id === e ? this : S, F) } catch (ee) { throw oo(j, ee), ee } return R instanceof Promise ? R.then(ee => (oo(B, ee), ee)).catch(ee => (oo(j, ee), Promise.reject(ee))) : (oo(B, R), R) } } const w = { _p: o, $id: e, $onAction: Ja.bind(null, f), $patch: _, $reset: A, $subscribe(T, q = {}) { const F = Ja(d, T, q.detached, () => B()), B = s.run(() => de(() => o.state.value[e], j => { (q.flush === "sync" ? u : c) && T({ storeId: e, type: lr.direct, events: h }, j) }, _n({}, a, q))); return F }, $dispose: g }, S = Ot(w); o._s.set(e, S); const k = o._e.run(() => (s = Oc(), s.run(() => t()))); for (const T in k) { const q = k[T]; if (Ze(q) && !Ip(q) || En(q)) i || (v && Bp(q) && (Ze(q) ? q.value = v[T] : Ds(q, v[T])), o.state.value[e][T] = q); else if (typeof q == "function") { const F = m(T, q); k[T] = F, l.actions[T] = q } } return _n(S, k), _n(ke(S), k), Object.defineProperty(S, "$state", { get: () => o.state.value[e], set: T => { _(q => { _n(q, T) }) } }), o._p.forEach(T => { _n(S, s.run(() => T({ store: S, app: o._a, pinia: o, options: l }))) }), v && i && n.hydrate && n.hydrate(S.$state, v), c = !0, u = !0, S } function zp(e, t, n) { let o, r; const i = typeof t == "function"; typeof e == "string" ? (o = e, r = i ? n : t) : (r = e, o = e.id); function s(l, a) { const c = Ee(); return l = l || c && Le(Id, null), l && Ki(l), l = Bd, l._s.has(o) || (i ? zd(o, t, r, l) : Fp(o, r, l)), l._s.get(o) } return s.$id = o, s } var hs = () => $p();/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */const uo = typeof window != "undefined"; function Vp(e) { return e.__esModule || e[Symbol.toStringTag] === "Module" } const Me = Object.assign; function ms(e, t) { const n = {}; for (const o in t) { const r = t[o]; n[o] = Kt(r) ? r.map(e) : e(r) } return n } const ar = () => { }, Kt = Array.isArray, Np = /\/$/, jp = e => e.replace(Np, ""); function vs(e, t, n = "/") { let o, r = {}, i = "", s = ""; const l = t.indexOf("#"); let a = t.indexOf("?"); return l < a && l >= 0 && (a = -1), a > -1 && (o = t.slice(0, a), i = t.slice(a + 1, l > -1 ? l : t.length), r = e(i)), l > -1 && (o = o || t.slice(0, l), s = t.slice(l, t.length)), o = Up(o != null ? o : t, n), { fullPath: o + (i && "?") + i + s, path: o, query: r, hash: s } } function Dp(e, t) { const n = t.query ? e(t.query) : ""; return t.path + (n && "?") + n + (t.hash || "") } function Xa(e, t) { return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/" } function Hp(e, t, n) { const o = t.matched.length - 1, r = n.matched.length - 1; return o > -1 && o === r && xo(t.matched[o], n.matched[r]) && Vd(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash } function xo(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function Vd(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (!Kp(e[n], t[n])) return !1; return !0 } function Kp(e, t) { return Kt(e) ? eu(e, t) : Kt(t) ? eu(t, e) : e === t } function eu(e, t) { return Kt(t) ? e.length === t.length && e.every((n, o) => n === t[o]) : e.length === 1 && e[0] === t } function Up(e, t) { if (e.startsWith("/")) return e; if (!e) return t; const n = t.split("/"), o = e.split("/"); let r = n.length - 1, i, s; for (i = 0; i < o.length; i++)if (s = o[i], s !== ".") if (s === "..") r > 1 && r--; else break; return n.slice(0, r).join("/") + "/" + o.slice(i - (i === o.length ? 1 : 0)).join("/") } var Cr; (function (e) { e.pop = "pop", e.push = "push" })(Cr || (Cr = {})); var ur; (function (e) { e.back = "back", e.forward = "forward", e.unknown = "" })(ur || (ur = {})); function Wp(e) { if (!e) if (uo) { const t = document.querySelector("base"); e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "") } else e = "/"; return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), jp(e) } const Qp = /^[^#]+#/; function Gp(e, t) { return e.replace(Qp, "#") + t } function Zp(e, t) { const n = document.documentElement.getBoundingClientRect(), o = e.getBoundingClientRect(); return { behavior: t.behavior, left: o.left - n.left - (t.left || 0), top: o.top - n.top - (t.top || 0) } } const Ui = () => ({ left: window.pageXOffset, top: window.pageYOffset }); function Yp(e) { let t; if ("el" in e) { const n = e.el, o = typeof n == "string" && n.startsWith("#"), r = typeof n == "string" ? o ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!r) return; t = Zp(r, e) } else t = e; "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset) } function tu(e, t) { return (history.state ? history.state.position - t : -1) + e } const Hs = new Map; function Jp(e, t) { Hs.set(e, t) } function Xp(e) { const t = Hs.get(e); return Hs.delete(e), t } let eg = () => location.protocol + "//" + location.host; function Nd(e, t) { const { pathname: n, search: o, hash: r } = t, i = e.indexOf("#"); if (i > -1) { let l = r.includes(e.slice(i)) ? e.slice(i).length : 1, a = r.slice(l); return a[0] !== "/" && (a = "/" + a), Xa(a, "") } return Xa(n, e) + o + r } function tg(e, t, n, o) { let r = [], i = [], s = null; const l = ({ state: f }) => { const h = Nd(e, location), v = n.value, x = t.value; let _ = 0; if (f) { if (n.value = h, t.value = f, s && s === v) { s = null; return } _ = x ? f.position - x.position : 0 } else o(h); r.forEach(A => { A(n.value, v, { delta: _, type: Cr.pop, direction: _ ? _ > 0 ? ur.forward : ur.back : ur.unknown }) }) }; function a() { s = n.value } function c(f) { r.push(f); const h = () => { const v = r.indexOf(f); v > -1 && r.splice(v, 1) }; return i.push(h), h } function u() { const { history: f } = window; !f.state || f.replaceState(Me({}, f.state, { scroll: Ui() }), "") } function d() { for (const f of i) f(); i = [], window.removeEventListener("popstate", l), window.removeEventListener("beforeunload", u) } return window.addEventListener("popstate", l), window.addEventListener("beforeunload", u), { pauseListeners: a, listen: c, destroy: d } } function nu(e, t, n, o = !1, r = !1) { return { back: e, current: t, forward: n, replaced: o, position: window.history.length, scroll: r ? Ui() : null } } function ng(e) { const { history: t, location: n } = window, o = { value: Nd(e, n) }, r = { value: t.state }; r.value || i(o.value, { back: null, current: o.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0); function i(a, c, u) { const d = e.indexOf("#"), f = d > -1 ? (n.host && document.querySelector("base") ? e : e.slice(d)) + a : eg() + e + a; try { t[u ? "replaceState" : "pushState"](c, "", f), r.value = c } catch (h) { console.error(h), n[u ? "replace" : "assign"](f) } } function s(a, c) { const u = Me({}, t.state, nu(r.value.back, a, r.value.forward, !0), c, { position: r.value.position }); i(a, u, !0), o.value = a } function l(a, c) { const u = Me({}, r.value, t.state, { forward: a, scroll: Ui() }); i(u.current, u, !0); const d = Me({}, nu(o.value, a, null), { position: u.position + 1 }, c); i(a, d, !1), o.value = a } return { location: o, state: r, push: l, replace: s } } function og(e) { e = Wp(e); const t = ng(e), n = tg(e, t.state, t.location, t.replace); function o(i, s = !0) { s || n.pauseListeners(), history.go(i) } const r = Me({ location: "", base: e, go: o, createHref: Gp.bind(null, e) }, t, n); return Object.defineProperty(r, "location", { enumerable: !0, get: () => t.location.value }), Object.defineProperty(r, "state", { enumerable: !0, get: () => t.state.value }), r } function rg(e) { return typeof e == "string" || e && typeof e == "object" } function jd(e) { return typeof e == "string" || typeof e == "symbol" } const gn = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }, Dd = Symbol(""); var ou; (function (e) { e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated" })(ou || (ou = {})); function ko(e, t) { return Me(new Error, { type: e, [Dd]: !0 }, t) } function rn(e, t) { return e instanceof Error && Dd in e && (t == null || !!(e.type & t)) } const ru = "[^/]+?", ig = { sensitive: !1, strict: !1, start: !0, end: !0 }, sg = /[.+*?^${}()[\]/\\]/g; function lg(e, t) { const n = Me({}, ig, t), o = []; let r = n.start ? "^" : ""; const i = []; for (const c of e) { const u = c.length ? [] : [90]; n.strict && !c.length && (r += "/"); for (let d = 0; d < c.length; d++) { const f = c[d]; let h = 40 + (n.sensitive ? .25 : 0); if (f.type === 0) d || (r += "/"), r += f.value.replace(sg, "\\$&"), h += 40; else if (f.type === 1) { const { value: v, repeatable: x, optional: _, regexp: A } = f; i.push({ name: v, repeatable: x, optional: _ }); const g = A || ru; if (g !== ru) { h += 10; try { new RegExp(`(${g})`) } catch (w) { throw new Error(`Invalid custom RegExp for param "${v}" (${g}): ` + w.message) } } let m = x ? `((?:${g})(?:/(?:${g}))*)` : `(${g})`; d || (m = _ && c.length < 2 ? `(?:/${m})` : "/" + m), _ && (m += "?"), r += m, h += 20, _ && (h += -8), x && (h += -20), g === ".*" && (h += -50) } u.push(h) } o.push(u) } if (n.strict && n.end) { const c = o.length - 1; o[c][o[c].length - 1] += .7000000000000001 } n.strict || (r += "/?"), n.end ? r += "$" : n.strict && (r += "(?:/|$)"); const s = new RegExp(r, n.sensitive ? "" : "i"); function l(c) { const u = c.match(s), d = {}; if (!u) return null; for (let f = 1; f < u.length; f++) { const h = u[f] || "", v = i[f - 1]; d[v.name] = h && v.repeatable ? h.split("/") : h } return d } function a(c) { let u = "", d = !1; for (const f of e) { (!d || !u.endsWith("/")) && (u += "/"), d = !1; for (const h of f) if (h.type === 0) u += h.value; else if (h.type === 1) { const { value: v, repeatable: x, optional: _ } = h, A = v in c ? c[v] : ""; if (Kt(A) && !x) throw new Error(`Provided param "${v}" is an array but it is not repeatable (* or + modifiers)`); const g = Kt(A) ? A.join("/") : A; if (!g) if (_) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0); else throw new Error(`Missing required param "${v}"`); u += g } } return u || "/" } return { re: s, score: o, keys: i, parse: l, stringify: a } } function ag(e, t) { let n = 0; for (; n < e.length && n < t.length;) { const o = t[n] - e[n]; if (o) return o; n++ } return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0 } function ug(e, t) { let n = 0; const o = e.score, r = t.score; for (; n < o.length && n < r.length;) { const i = ag(o[n], r[n]); if (i) return i; n++ } if (Math.abs(r.length - o.length) === 1) { if (iu(o)) return 1; if (iu(r)) return -1 } return r.length - o.length } function iu(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0 } const cg = { type: 0, value: "" }, dg = /[a-zA-Z0-9_]/; function fg(e) { if (!e) return [[]]; if (e === "/") return [[cg]]; if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`); function t(h) { throw new Error(`ERR (${n})/"${c}": ${h}`) } let n = 0, o = n; const r = []; let i; function s() { i && r.push(i), i = [] } let l = 0, a, c = "", u = ""; function d() { !c || (n === 0 ? i.push({ type: 0, value: c }) : n === 1 || n === 2 || n === 3 ? (i.length > 1 && (a === "*" || a === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), i.push({ type: 1, value: c, regexp: u, repeatable: a === "*" || a === "+", optional: a === "*" || a === "?" })) : t("Invalid state to consume buffer"), c = "") } function f() { c += a } for (; l < e.length;) { if (a = e[l++], a === "\\" && n !== 2) { o = n, n = 4; continue } switch (n) { case 0: a === "/" ? (c && d(), s()) : a === ":" ? (d(), n = 1) : f(); break; case 4: f(), n = o; break; case 1: a === "(" ? n = 2 : dg.test(a) ? f() : (d(), n = 0, a !== "*" && a !== "?" && a !== "+" && l--); break; case 2: a === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + a : n = 3 : u += a; break; case 3: d(), n = 0, a !== "*" && a !== "?" && a !== "+" && l--, u = ""; break; default: t("Unknown state"); break } } return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), d(), s(), r } function hg(e, t, n) { const o = lg(fg(e.path), n), r = Me(o, { record: e, parent: t, children: [], alias: [] }); return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r } function mg(e, t) { const n = [], o = new Map; t = au({ strict: !1, end: !0, sensitive: !1 }, t); function r(u) { return o.get(u) } function i(u, d, f) { const h = !f, v = vg(u); v.aliasOf = f && f.record; const x = au(t, u), _ = [v]; if ("alias" in u) { const m = typeof u.alias == "string" ? [u.alias] : u.alias; for (const w of m) _.push(Me({}, v, { components: f ? f.record.components : v.components, path: w, aliasOf: f ? f.record : v })) } let A, g; for (const m of _) { const { path: w } = m; if (d && w[0] !== "/") { const S = d.record.path, k = S[S.length - 1] === "/" ? "" : "/"; m.path = d.record.path + (w && k + w) } if (A = hg(m, d, x), f ? f.alias.push(A) : (g = g || A, g !== A && g.alias.push(A), h && u.name && !lu(A) && s(u.name)), v.children) { const S = v.children; for (let k = 0; k < S.length; k++)i(S[k], A, f && f.children[k]) } f = f || A, (A.record.components && Object.keys(A.record.components).length || A.record.name || A.record.redirect) && a(A) } return g ? () => { s(g) } : ar } function s(u) { if (jd(u)) { const d = o.get(u); d && (o.delete(u), n.splice(n.indexOf(d), 1), d.children.forEach(s), d.alias.forEach(s)) } else { const d = n.indexOf(u); d > -1 && (n.splice(d, 1), u.record.name && o.delete(u.record.name), u.children.forEach(s), u.alias.forEach(s)) } } function l() { return n } function a(u) { let d = 0; for (; d < n.length && ug(u, n[d]) >= 0 && (u.record.path !== n[d].record.path || !Hd(u, n[d]));)d++; n.splice(d, 0, u), u.record.name && !lu(u) && o.set(u.record.name, u) } function c(u, d) { let f, h = {}, v, x; if ("name" in u && u.name) { if (f = o.get(u.name), !f) throw ko(1, { location: u }); x = f.record.name, h = Me(su(d.params, f.keys.filter(g => !g.optional).map(g => g.name)), u.params && su(u.params, f.keys.map(g => g.name))), v = f.stringify(h) } else if ("path" in u) v = u.path, f = n.find(g => g.re.test(v)), f && (h = f.parse(v), x = f.record.name); else { if (f = d.name ? o.get(d.name) : n.find(g => g.re.test(d.path)), !f) throw ko(1, { location: u, currentLocation: d }); x = f.record.name, h = Me({}, d.params, u.params), v = f.stringify(h) } const _ = []; let A = f; for (; A;)_.unshift(A.record), A = A.parent; return { name: x, path: v, params: h, matched: _, meta: gg(_) } } return e.forEach(u => i(u)), { addRoute: i, resolve: c, removeRoute: s, getRoutes: l, getRecordMatcher: r } } function su(e, t) { const n = {}; for (const o of t) o in e && (n[o] = e[o]); return n } function vg(e) { return { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: void 0, beforeEnter: e.beforeEnter, props: pg(e), children: e.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in e ? e.components || null : e.component && { default: e.component } } } function pg(e) { const t = {}, n = e.props || !1; if ("component" in e) t.default = n; else for (const o in e.components) t[o] = typeof n == "boolean" ? n : n[o]; return t } function lu(e) { for (; e;) { if (e.record.aliasOf) return !0; e = e.parent } return !1 } function gg(e) { return e.reduce((t, n) => Me(t, n.meta), {}) } function au(e, t) { const n = {}; for (const o in e) n[o] = o in t ? t[o] : e[o]; return n } function Hd(e, t) { return t.children.some(n => n === e || Hd(e, n)) } const Kd = /#/g, yg = /&/g, bg = /\//g, _g = /=/g, wg = /\?/g, Ud = /\+/g, Cg = /%5B/g, xg = /%5D/g, Wd = /%5E/g, kg = /%60/g, Qd = /%7B/g, Sg = /%7C/g, Gd = /%7D/g, Eg = /%20/g; function Bl(e) { return encodeURI("" + e).replace(Sg, "|").replace(Cg, "[").replace(xg, "]") } function qg(e) { return Bl(e).replace(Qd, "{").replace(Gd, "}").replace(Wd, "^") } function Ks(e) { return Bl(e).replace(Ud, "%2B").replace(Eg, "+").replace(Kd, "%23").replace(yg, "%26").replace(kg, "`").replace(Qd, "{").replace(Gd, "}").replace(Wd, "^") } function Tg(e) { return Ks(e).replace(_g, "%3D") } function Pg(e) { return Bl(e).replace(Kd, "%23").replace(wg, "%3F") } function Ag(e) { return e == null ? "" : Pg(e).replace(bg, "%2F") } function gi(e) { try { return decodeURIComponent("" + e) } catch { } return "" + e } function Og(e) { const t = {}; if (e === "" || e === "?") return t; const o = (e[0] === "?" ? e.slice(1) : e).split("&"); for (let r = 0; r < o.length; ++r) { const i = o[r].replace(Ud, " "), s = i.indexOf("="), l = gi(s < 0 ? i : i.slice(0, s)), a = s < 0 ? null : gi(i.slice(s + 1)); if (l in t) { let c = t[l]; Kt(c) || (c = t[l] = [c]), c.push(a) } else t[l] = a } return t } function uu(e) { let t = ""; for (let n in e) { const o = e[n]; if (n = Tg(n), o == null) { o !== void 0 && (t += (t.length ? "&" : "") + n); continue } (Kt(o) ? o.map(i => i && Ks(i)) : [o && Ks(o)]).forEach(i => { i !== void 0 && (t += (t.length ? "&" : "") + n, i != null && (t += "=" + i)) }) } return t } function Rg(e) { const t = {}; for (const n in e) { const o = e[n]; o !== void 0 && (t[n] = Kt(o) ? o.map(r => r == null ? null : "" + r) : o == null ? o : "" + o) } return t } const Lg = Symbol(""), cu = Symbol(""), Il = Symbol(""), Zd = Symbol(""), Us = Symbol(""); function Do() { let e = []; function t(o) { return e.push(o), () => { const r = e.indexOf(o); r > -1 && e.splice(r, 1) } } function n() { e = [] } return { add: t, list: () => e, reset: n } } function wn(e, t, n, o, r) { const i = o && (o.enterCallbacks[r] = o.enterCallbacks[r] || []); return () => new Promise((s, l) => { const a = d => { d === !1 ? l(ko(4, { from: n, to: t })) : d instanceof Error ? l(d) : rg(d) ? l(ko(2, { from: t, to: d })) : (i && o.enterCallbacks[r] === i && typeof d == "function" && i.push(d), s()) }, c = e.call(o && o.instances[r], t, n, a); let u = Promise.resolve(c); e.length < 3 && (u = u.then(a)), u.catch(d => l(d)) }) } function ps(e, t, n, o) { const r = []; for (const i of e) for (const s in i.components) { let l = i.components[s]; if (!(t !== "beforeRouteEnter" && !i.instances[s])) if ($g(l)) { const c = (l.__vccOpts || l)[t]; c && r.push(wn(c, n, o, i, s)) } else { let a = l(); r.push(() => a.then(c => { if (!c) return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${i.path}"`)); const u = Vp(c) ? c.default : c; i.components[s] = u; const f = (u.__vccOpts || u)[t]; return f && wn(f, n, o, i, s)() })) } } return r } function $g(e) { return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e } function du(e) { const t = Le(Il), n = Le(Zd), o = y(() => t.resolve(Kn(e.to))), r = y(() => { const { matched: a } = o.value, { length: c } = a, u = a[c - 1], d = n.matched; if (!u || !d.length) return -1; const f = d.findIndex(xo.bind(null, u)); if (f > -1) return f; const h = fu(a[c - 2]); return c > 1 && fu(u) === h && d[d.length - 1].path !== h ? d.findIndex(xo.bind(null, a[c - 2])) : f }), i = y(() => r.value > -1 && Fg(n.params, o.value.params)), s = y(() => r.value > -1 && r.value === n.matched.length - 1 && Vd(n.params, o.value.params)); function l(a = {}) { return Ig(a) ? t[Kn(e.replace) ? "replace" : "push"](Kn(e.to)).catch(ar) : Promise.resolve() } return { route: o, href: y(() => o.value.href), isActive: i, isExactActive: s, navigate: l } } const Mg = Ne({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: du, setup(e, { slots: t }) { const n = Ot(du(e)), { options: o } = Le(Il), r = y(() => ({ [hu(e.activeClass, o.linkActiveClass, "router-link-active")]: n.isActive, [hu(e.exactActiveClass, o.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive })); return () => { const i = t.default && t.default(n); return e.custom ? i : b("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: r.value }, i) } } }), Bg = Mg; function Ig(e) { if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) { if (e.currentTarget && e.currentTarget.getAttribute) { const t = e.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(t)) return } return e.preventDefault && e.preventDefault(), !0 } } function Fg(e, t) { for (const n in t) { const o = t[n], r = e[n]; if (typeof o == "string") { if (o !== r) return !1 } else if (!Kt(r) || r.length !== o.length || o.some((i, s) => i !== r[s])) return !1 } return !0 } function fu(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : "" } const hu = (e, t, n) => e != null ? e : t != null ? t : n, zg = Ne({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: n }) { const o = Le(Us), r = y(() => e.route || o.value), i = Le(cu, 0), s = y(() => { let c = Kn(i); const { matched: u } = r.value; let d; for (; (d = u[c]) && !d.components;)c++; return c }), l = y(() => r.value.matched[s.value]); xt(cu, y(() => s.value + 1)), xt(Lg, l), xt(Us, r); const a = z(); return de(() => [a.value, l.value, e.name], ([c, u, d], [f, h, v]) => { u && (u.instances[d] = c, h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), c && u && (!h || !xo(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(x => x(c)) }, { flush: "post" }), () => { const c = r.value, u = e.name, d = l.value, f = d && d.components[u]; if (!f) return mu(n.default, { Component: f, route: c }); const h = d.props[u], v = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null, _ = b(f, Me({}, v, t, { onVnodeUnmounted: A => { A.component.isUnmounted && (d.instances[u] = null) }, ref: a })); return mu(n.default, { Component: _, route: c }) || _ } } }); function mu(e, t) { if (!e) return null; const n = e(t); return n.length === 1 ? n[0] : n } const Vg = zg; function Ng(e) { const t = mg(e.routes, e), n = e.parseQuery || Og, o = e.stringifyQuery || uu, r = e.history, i = Do(), s = Do(), l = Do(), a = bm(gn); let c = gn; uo && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const u = ms.bind(null, N => "" + N), d = ms.bind(null, Ag), f = ms.bind(null, gi); function h(N, U) { let L, X; return jd(N) ? (L = t.getRecordMatcher(N), X = U) : X = N, t.addRoute(X, L) } function v(N) { const U = t.getRecordMatcher(N); U && t.removeRoute(U) } function x() { return t.getRoutes().map(N => N.record) } function _(N) { return !!t.getRecordMatcher(N) } function A(N, U) { if (U = Me({}, U || a.value), typeof N == "string") { const p = vs(n, N, U.path), C = t.resolve({ path: p.path }, U), I = r.createHref(p.fullPath); return Me(p, C, { params: f(C.params), hash: gi(p.hash), redirectedFrom: void 0, href: I }) } let L; if ("path" in N) L = Me({}, N, { path: vs(n, N.path, U.path).path }); else { const p = Me({}, N.params); for (const C in p) p[C] == null && delete p[C]; L = Me({}, N, { params: d(N.params) }), U.params = d(U.params) } const X = t.resolve(L, U), W = N.hash || ""; X.params = u(f(X.params)); const ye = Dp(o, Me({}, N, { hash: qg(W), path: X.path })), ge = r.createHref(ye); return Me({ fullPath: ye, hash: W, query: o === uu ? Rg(N.query) : N.query || {} }, X, { redirectedFrom: void 0, href: ge }) } function g(N) { return typeof N == "string" ? vs(n, N, a.value.path) : Me({}, N) } function m(N, U) { if (c !== N) return ko(8, { from: U, to: N }) } function w(N) { return T(N) } function S(N) { return w(Me(g(N), { replace: !0 })) } function k(N) { const U = N.matched[N.matched.length - 1]; if (U && U.redirect) { const { redirect: L } = U; let X = typeof L == "function" ? L(N) : L; return typeof X == "string" && (X = X.includes("?") || X.includes("#") ? X = g(X) : { path: X }, X.params = {}), Me({ query: N.query, hash: N.hash, params: "path" in X ? {} : N.params }, X) } } function T(N, U) { const L = c = A(N), X = a.value, W = N.state, ye = N.force, ge = N.replace === !0, p = k(L); if (p) return T(Me(g(p), { state: typeof p == "object" ? Me({}, W, p.state) : W, force: ye, replace: ge }), U || L); const C = L; C.redirectedFrom = U; let I; return !ye && Hp(o, X, L) && (I = ko(16, { to: C, from: X }), ne(X, X, !0, !1)), (I ? Promise.resolve(I) : F(C, X)).catch(H => rn(H) ? rn(H, 2) ? H : Ce(H) : D(H, C, X)).then(H => { if (H) { if (rn(H, 2)) return T(Me({ replace: ge }, g(H.to), { state: typeof H.to == "object" ? Me({}, W, H.to.state) : W, force: ye }), U || C) } else H = j(C, X, !0, ge, W); return B(C, X, H), H }) } function q(N, U) { const L = m(N, U); return L ? Promise.reject(L) : Promise.resolve() } function F(N, U) { let L; const [X, W, ye] = jg(N, U); L = ps(X.reverse(), "beforeRouteLeave", N, U); for (const p of X) p.leaveGuards.forEach(C => { L.push(wn(C, N, U)) }); const ge = q.bind(null, N, U); return L.push(ge), ro(L).then(() => { L = []; for (const p of i.list()) L.push(wn(p, N, U)); return L.push(ge), ro(L) }).then(() => { L = ps(W, "beforeRouteUpdate", N, U); for (const p of W) p.updateGuards.forEach(C => { L.push(wn(C, N, U)) }); return L.push(ge), ro(L) }).then(() => { L = []; for (const p of N.matched) if (p.beforeEnter && !U.matched.includes(p)) if (Kt(p.beforeEnter)) for (const C of p.beforeEnter) L.push(wn(C, N, U)); else L.push(wn(p.beforeEnter, N, U)); return L.push(ge), ro(L) }).then(() => (N.matched.forEach(p => p.enterCallbacks = {}), L = ps(ye, "beforeRouteEnter", N, U), L.push(ge), ro(L))).then(() => { L = []; for (const p of s.list()) L.push(wn(p, N, U)); return L.push(ge), ro(L) }).catch(p => rn(p, 8) ? p : Promise.reject(p)) } function B(N, U, L) { for (const X of l.list()) X(N, U, L) } function j(N, U, L, X, W) { const ye = m(N, U); if (ye) return ye; const ge = U === gn, p = uo ? history.state : {}; L && (X || ge ? r.replace(N.fullPath, Me({ scroll: ge && p && p.scroll }, W)) : r.push(N.fullPath, W)), a.value = N, ne(N, U, L, ge), Ce() } let $; function M() { $ || ($ = r.listen((N, U, L) => { if (!we.listening) return; const X = A(N), W = k(X); if (W) { T(Me(W, { replace: !0 }), X).catch(ar); return } c = X; const ye = a.value; uo && Jp(tu(ye.fullPath, L.delta), Ui()), F(X, ye).catch(ge => rn(ge, 12) ? ge : rn(ge, 2) ? (T(ge.to, X).then(p => { rn(p, 20) && !L.delta && L.type === Cr.pop && r.go(-1, !1) }).catch(ar), Promise.reject()) : (L.delta && r.go(-L.delta, !1), D(ge, X, ye))).then(ge => { ge = ge || j(X, ye, !1), ge && (L.delta && !rn(ge, 8) ? r.go(-L.delta, !1) : L.type === Cr.pop && rn(ge, 20) && r.go(-1, !1)), B(X, ye, ge) }).catch(ar) })) } let R = Do(), ee = Do(), fe; function D(N, U, L) { Ce(N); const X = ee.list(); return X.length ? X.forEach(W => W(N, U, L)) : console.error(N), Promise.reject(N) } function oe() { return fe && a.value !== gn ? Promise.resolve() : new Promise((N, U) => { R.add([N, U]) }) } function Ce(N) { return fe || (fe = !N, M(), R.list().forEach(([U, L]) => N ? L(N) : U()), R.reset()), N } function ne(N, U, L, X) { const { scrollBehavior: W } = e; if (!uo || !W) return Promise.resolve(); const ye = !L && Xp(tu(N.fullPath, 0)) || (X || !L) && history.state && history.state.scroll || null; return Ie().then(() => W(N, U, ye)).then(ge => ge && Yp(ge)).catch(ge => D(ge, N, U)) } const O = N => r.go(N); let J; const ue = new Set, we = { currentRoute: a, listening: !0, addRoute: h, removeRoute: v, hasRoute: _, getRoutes: x, resolve: A, options: e, push: w, replace: S, go: O, back: () => O(-1), forward: () => O(1), beforeEach: i.add, beforeResolve: s.add, afterEach: l.add, onError: ee.add, isReady: oe, install(N) { const U = this; N.component("RouterLink", Bg), N.component("RouterView", Vg), N.config.globalProperties.$router = U, Object.defineProperty(N.config.globalProperties, "$route", { enumerable: !0, get: () => Kn(a) }), uo && !J && a.value === gn && (J = !0, w(r.location).catch(W => { })); const L = {}; for (const W in gn) L[W] = y(() => a.value[W]); N.provide(Il, U), N.provide(Zd, Ot(L)), N.provide(Us, a); const X = N.unmount; ue.add(N), N.unmount = function () { ue.delete(N), ue.size < 1 && (c = gn, $ && $(), $ = null, a.value = gn, J = !1, fe = !1), X() } } }; return we } function ro(e) { return e.reduce((t, n) => t.then(() => n()), Promise.resolve()) } function jg(e, t) { const n = [], o = [], r = [], i = Math.max(t.matched.length, e.matched.length); for (let s = 0; s < i; s++) { const l = t.matched[s]; l && (e.matched.find(c => xo(c, l)) ? o.push(l) : n.push(l)); const a = e.matched[s]; a && (t.matched.find(c => xo(c, a)) || r.push(a)) } return [n, o, r] } const qe = e => it(Ne(e)), Fl = e => it(e); function He(e, t) { return e !== void 0 && e() || t } function Yd(e, t) { if (e !== void 0) { const n = e(); if (n != null) return n.slice() } return t } function Lt(e, t) { return e !== void 0 ? t.concat(e()) : t } function Jd(e, t) { return e === void 0 ? t : t !== void 0 ? t.concat(e()) : e() } function Xd(e, t, n, o, r, i) { t.key = o + r; const s = b(e, t, n); return r === !0 ? Rt(s, i()) : s } var vu = qe({ name: "QToolbarTitle", props: { shrink: Boolean }, setup(e, { slots: t }) { const n = y(() => "q-toolbar__title ellipsis" + (e.shrink === !0 ? " col-shrink" : "")); return () => b("div", { class: n.value }, He(t.default)) } }), pu = qe({ name: "QToolbar", props: { inset: Boolean }, setup(e, { slots: t }) { const n = y(() => "q-toolbar row no-wrap items-center" + (e.inset === !0 ? " q-toolbar--inset" : "")); return () => b("div", { class: n.value, role: "toolbar" }, He(t.default)) } }); function Dg() { const e = z(!Ht.value); return e.value === !1 && et(() => { e.value = !0 }), e } const ef = typeof ResizeObserver != "undefined", gu = ef === !0 ? {} : { style: "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;", url: "about:blank" }; var xr = qe({ name: "QResizeObserver", props: { debounce: { type: [String, Number], default: 100 } }, emits: ["resize"], setup(e, { emit: t }) { let n = null, o, r = { width: -1, height: -1 }; function i(a) { a === !0 || e.debounce === 0 || e.debounce === "0" ? s() : n === null && (n = setTimeout(s, e.debounce)) } function s() { if (n !== null && (clearTimeout(n), n = null), o) { const { offsetWidth: a, offsetHeight: c } = o; (a !== r.width || c !== r.height) && (r = { width: a, height: c }, t("resize", r)) } } const { proxy: l } = Ee(); if (ef === !0) { let a; const c = u => { o = l.$el.parentNode, o ? (a = new ResizeObserver(i), a.observe(o), s()) : u !== !0 && Ie(() => { c(!0) }) }; return et(() => { c() }), Re(() => { n !== null && clearTimeout(n), a !== void 0 && (a.disconnect !== void 0 ? a.disconnect() : o && a.unobserve(o)) }), hn } else { let u = function () { n !== null && (clearTimeout(n), n = null), c !== void 0 && (c.removeEventListener !== void 0 && c.removeEventListener("resize", i, Je.passive), c = void 0) }, d = function () { u(), o && o.contentDocument && (c = o.contentDocument.defaultView, c.addEventListener("resize", i, Je.passive), s()) }; const a = Dg(); let c; return et(() => { Ie(() => { o = l.$el, o && d() }) }), Re(u), l.trigger = i, () => { if (a.value === !0) return b("object", { style: gu.style, tabindex: -1, type: "text/html", data: gu.url, "aria-hidden": "true", onLoad: d }) } } } }), Hg = qe({ name: "QHeader", props: { modelValue: { type: Boolean, default: !0 }, reveal: Boolean, revealOffset: { type: Number, default: 250 }, bordered: Boolean, elevated: Boolean, heightHint: { type: [String, Number], default: 50 } }, emits: ["reveal", "focusin"], setup(e, { slots: t, emit: n }) { const { proxy: { $q: o } } = Ee(), r = Le(Mr, ot); if (r === ot) return console.error("QHeader needs to be child of QLayout"), ot; const i = z(parseInt(e.heightHint, 10)), s = z(!0), l = y(() => e.reveal === !0 || r.view.value.indexOf("H") > -1 || o.platform.is.ios && r.isContainer.value === !0), a = y(() => { if (e.modelValue !== !0) return 0; if (l.value === !0) return s.value === !0 ? i.value : 0; const g = i.value - r.scroll.value.position; return g > 0 ? g : 0 }), c = y(() => e.modelValue !== !0 || l.value === !0 && s.value !== !0), u = y(() => e.modelValue === !0 && c.value === !0 && e.reveal === !0), d = y(() => "q-header q-layout__section--marginal " + (l.value === !0 ? "fixed" : "absolute") + "-top" + (e.bordered === !0 ? " q-header--bordered" : "") + (c.value === !0 ? " q-header--hidden" : "") + (e.modelValue !== !0 ? " q-layout--prevent-focus" : "")), f = y(() => { const g = r.rows.value.top, m = {}; return g[0] === "l" && r.left.space === !0 && (m[o.lang.rtl === !0 ? "right" : "left"] = `${r.left.size}px`), g[2] === "r" && r.right.space === !0 && (m[o.lang.rtl === !0 ? "left" : "right"] = `${r.right.size}px`), m }); function h(g, m) { r.update("header", g, m) } function v(g, m) { g.value !== m && (g.value = m) } function x({ height: g }) { v(i, g), h("size", g) } function _(g) { u.value === !0 && v(s, !0), n("focusin", g) } de(() => e.modelValue, g => { h("space", g), v(s, !0), r.animate() }), de(a, g => { h("offset", g) }), de(() => e.reveal, g => { g === !1 && v(s, e.modelValue) }), de(s, g => { r.animate(), n("reveal", g) }), de(r.scroll, g => { e.reveal === !0 && v(s, g.direction === "up" || g.position <= e.revealOffset || g.position - g.inflectionPoint < 100) }); const A = {}; return r.instances.header = A, e.modelValue === !0 && h("size", i.value), h("space", e.modelValue), h("offset", a.value), Re(() => { r.instances.header === A && (r.instances.header = void 0, h("size", 0), h("offset", 0), h("space", !1)) }), () => { const g = Yd(t.default, []); return e.elevated === !0 && g.push(b("div", { class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events" })), g.push(b(xr, { debounce: 0, onResize: x })), b("header", { class: d.value, style: f.value, onFocusin: _ }, g) } } }), Kg = qe({ name: "QPageContainer", setup(e, { slots: t }) { const { proxy: { $q: n } } = Ee(), o = Le(Mr, ot); if (o === ot) return console.error("QPageContainer needs to be child of QLayout"), ot; xt(Rd, !0); const r = y(() => { const i = {}; return o.header.space === !0 && (i.paddingTop = `${o.header.size}px`), o.right.space === !0 && (i[`padding${n.lang.rtl === !0 ? "Left" : "Right"}`] = `${o.right.size}px`), o.footer.space === !0 && (i.paddingBottom = `${o.footer.size}px`), o.left.space === !0 && (i[`padding${n.lang.rtl === !0 ? "Right" : "Left"}`] = `${o.left.size}px`), i }); return () => b("div", { class: "q-page-container", style: r.value }, He(t.default)) } }); function ti(e) { if (Object(e.$parent) === e.$parent) return e.$parent; let { parent: t } = e.$; for (; Object(t) === t;) { if (Object(t.proxy) === t.proxy) return t.proxy; t = t.parent } } function tf(e, t) { typeof t.type == "symbol" ? Array.isArray(t.children) === !0 && t.children.forEach(n => { tf(e, n) }) : e.add(t) } function Ug(e) { const t = new Set; return e.forEach(n => { tf(t, n) }), Array.from(t) } function zl(e) { return e.appContext.config.globalProperties.$router !== void 0 } function Vl(e) { return e.isUnmounted === !0 || e.isDeactivated === !0 } function yu(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : "" } function bu(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function Wg(e, t) { for (const n in t) { const o = t[n], r = e[n]; if (typeof o == "string") { if (o !== r) return !1 } else if (Array.isArray(r) === !1 || r.length !== o.length || o.some((i, s) => i !== r[s])) return !1 } return !0 } function _u(e, t) { return Array.isArray(t) === !0 ? e.length === t.length && e.every((n, o) => n === t[o]) : e.length === 1 && e[0] === t } function Qg(e, t) { return Array.isArray(e) === !0 ? _u(e, t) : Array.isArray(t) === !0 ? _u(t, e) : e === t } function Gg(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (Qg(e[n], t[n]) === !1) return !1; return !0 } const Nl = { to: [String, Object], replace: Boolean, exact: Boolean, activeClass: { type: String, default: "q-router-link--active" }, exactActiveClass: { type: String, default: "q-router-link--exact-active" }, href: String, target: String, disable: Boolean }; function jl({ fallbackTag: e, useDisableForRouterLinkProps: t = !0 } = {}) { const n = Ee(), { props: o, proxy: r, emit: i } = n, s = zl(n), l = y(() => o.disable !== !0 && o.href !== void 0), a = y(t === !0 ? () => s === !0 && o.disable !== !0 && l.value !== !0 && o.to !== void 0 && o.to !== null && o.to !== "" : () => s === !0 && l.value !== !0 && o.to !== void 0 && o.to !== null && o.to !== ""), c = y(() => a.value === !0 ? g(o.to) : null), u = y(() => c.value !== null), d = y(() => l.value === !0 || u.value === !0), f = y(() => o.type === "a" || d.value === !0 ? "a" : o.tag || e || "div"), h = y(() => l.value === !0 ? { href: o.href, target: o.target } : u.value === !0 ? { href: c.value.href, target: o.target } : {}), v = y(() => { if (u.value === !1) return -1; const { matched: S } = c.value, { length: k } = S, T = S[k - 1]; if (T === void 0) return -1; const q = r.$route.matched; if (q.length === 0) return -1; const F = q.findIndex(bu.bind(null, T)); if (F > -1) return F; const B = yu(S[k - 2]); return k > 1 && yu(T) === B && q[q.length - 1].path !== B ? q.findIndex(bu.bind(null, S[k - 2])) : F }), x = y(() => u.value === !0 && v.value !== -1 && Wg(r.$route.params, c.value.params)), _ = y(() => x.value === !0 && v.value === r.$route.matched.length - 1 && Gg(r.$route.params, c.value.params)), A = y(() => u.value === !0 ? _.value === !0 ? ` ${o.exactActiveClass} ${o.activeClass}` : o.exact === !0 ? "" : x.value === !0 ? ` ${o.activeClass}` : "" : ""); function g(S) { try { return r.$router.resolve(S) } catch { } return null } function m(S, { returnRouterError: k, to: T = o.to, replace: q = o.replace } = {}) { if (o.disable === !0) return S.preventDefault(), Promise.resolve(!1); if (S.metaKey || S.altKey || S.ctrlKey || S.shiftKey || S.button !== void 0 && S.button !== 0 || o.target === "_blank") return Promise.resolve(!1); S.preventDefault(); const F = r.$router[q === !0 ? "replace" : "push"](T); return k === !0 ? F : F.then(() => { }).catch(() => { }) } function w(S) { if (u.value === !0) { const k = T => m(S, T); i("click", S, k), S.defaultPrevented !== !0 && k() } else i("click", S) } return { hasRouterLink: u, hasHrefLink: l, hasLink: d, linkTag: f, resolvedLink: c, linkIsActive: x, linkIsExactActive: _, linkClass: A, linkAttrs: h, getLink: g, navigateToRouterLink: m, navigateOnClick: w } } const Ws = { xs: 18, sm: 24, md: 32, lg: 38, xl: 46 }, Lo = { size: String }; function $o(e, t = Ws) { return y(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null) } const wu = "0 0 24 24", Cu = e => e, gs = e => `ionicons ${e}`, nf = { "mdi-": e => `mdi ${e}`, "icon-": Cu, "bt-": e => `bt ${e}`, "eva-": e => `eva ${e}`, "ion-md": gs, "ion-ios": gs, "ion-logo": gs, "iconfont ": Cu, "ti-": e => `themify-icon ${e}`, "bi-": e => `bootstrap-icons ${e}` }, of = { o_: "-outlined", r_: "-round", s_: "-sharp" }, rf = { sym_o_: "-outlined", sym_r_: "-rounded", sym_s_: "-sharp" }, Zg = new RegExp("^(" + Object.keys(nf).join("|") + ")"), Yg = new RegExp("^(" + Object.keys(of).join("|") + ")"), xu = new RegExp("^(" + Object.keys(rf).join("|") + ")"), Jg = /^[Mm]\s?[-+]?\.?\d/, Xg = /^img:/, ey = /^svguse:/, ty = /^ion-/, ny = /^(fa-(solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /; var ct = qe({ name: "QIcon", props: { ...Lo, tag: { type: String, default: "i" }, name: String, color: String, left: Boolean, right: Boolean }, setup(e, { slots: t }) { const { proxy: { $q: n } } = Ee(), o = $o(e), r = y(() => "q-icon" + (e.left === !0 ? " on-left" : "") + (e.right === !0 ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")), i = y(() => { let s, l = e.name; if (l === "none" || !l) return { none: !0 }; if (n.iconMapFn !== null) { const u = n.iconMapFn(l); if (u !== void 0) if (u.icon !== void 0) { if (l = u.icon, l === "none" || !l) return { none: !0 } } else return { cls: u.cls, content: u.content !== void 0 ? u.content : " " } } if (Jg.test(l) === !0) { const [u, d = wu] = l.split("|"); return { svg: !0, viewBox: d, nodes: u.split("&&").map(f => { const [h, v, x] = f.split("@@"); return b("path", { style: v, d: h, transform: x }) }) } } if (Xg.test(l) === !0) return { img: !0, src: l.substring(4) }; if (ey.test(l) === !0) { const [u, d = wu] = l.split("|"); return { svguse: !0, src: u.substring(7), viewBox: d } } let a = " "; const c = l.match(Zg); if (c !== null) s = nf[c[1]](l); else if (ny.test(l) === !0) s = l; else if (ty.test(l) === !0) s = `ionicons ion-${n.platform.is.ios === !0 ? "ios" : "md"}${l.substring(3)}`; else if (xu.test(l) === !0) { s = "notranslate material-symbols"; const u = l.match(xu); u !== null && (l = l.substring(6), s += rf[u[1]]), a = l } else { s = "notranslate material-icons"; const u = l.match(Yg); u !== null && (l = l.substring(2), s += of[u[1]]), a = l } return { cls: s, content: a } }); return () => { const s = { class: r.value, style: o.value, "aria-hidden": "true", role: "presentation" }; return i.value.none === !0 ? b(e.tag, s, He(t.default)) : i.value.img === !0 ? b("span", s, Lt(t.default, [b("img", { src: i.value.src })])) : i.value.svg === !0 ? b("span", s, Lt(t.default, [b("svg", { viewBox: i.value.viewBox || "0 0 24 24" }, i.value.nodes)])) : i.value.svguse === !0 ? b("span", s, Lt(t.default, [b("svg", { viewBox: i.value.viewBox }, [b("use", { "xlink:href": i.value.src })])])) : (i.value.cls !== void 0 && (s.class += " " + i.value.cls), b(e.tag, s, Lt(t.default, [i.value.content]))) } } }); function Qs(e, t) { const n = e.style; for (const o in t) n[o] = t[o] } function oy(e) { if (e == null) return; if (typeof e == "string") try { return document.querySelector(e) || void 0 } catch { return } const t = Kn(e); if (t) return t.$el || t } function sf(e, t) { if (e == null || e.contains(t) === !0) return !0; for (let n = e.nextElementSibling; n !== null; n = n.nextElementSibling)if (n.contains(t)) return !0; return !1 } function ry(e, t = 250) { let n = !1, o; return function () { return n === !1 && (n = !0, setTimeout(() => { n = !1 }, t), o = e.apply(this, arguments)), o } } function ku(e, t, n, o) { n.modifiers.stop === !0 && Gt(e); const r = n.modifiers.color; let i = n.modifiers.center; i = i === !0 || o === !0; const s = document.createElement("span"), l = document.createElement("span"), a = mi(e), { left: c, top: u, width: d, height: f } = t.getBoundingClientRect(), h = Math.sqrt(d * d + f * f), v = h / 2, x = `${(d - h) / 2}px`, _ = i ? x : `${a.left - c - v}px`, A = `${(f - h) / 2}px`, g = i ? A : `${a.top - u - v}px`; l.className = "q-ripple__inner", Qs(l, { height: `${h}px`, width: `${h}px`, transform: `translate3d(${_},${g},0) scale3d(.2,.2,1)`, opacity: 0 }), s.className = `q-ripple${r ? " text-" + r : ""}`, s.setAttribute("dir", "ltr"), s.appendChild(l), t.appendChild(s); const m = () => { s.remove(), clearTimeout(w) }; n.abort.push(m); let w = setTimeout(() => { l.classList.add("q-ripple__inner--enter"), l.style.transform = `translate3d(${x},${A},0) scale3d(1,1,1)`, l.style.opacity = .2, w = setTimeout(() => { l.classList.remove("q-ripple__inner--enter"), l.classList.add("q-ripple__inner--leave"), l.style.opacity = 0, w = setTimeout(() => { s.remove(), n.abort.splice(n.abort.indexOf(m), 1) }, 275) }, 250) }, 50) } function Su(e, { modifiers: t, value: n, arg: o }) { const r = Object.assign({}, e.cfg.ripple, t, n); e.modifiers = { early: r.early === !0, stop: r.stop === !0, center: r.center === !0, color: r.color || o, keyCodes: [].concat(r.keyCodes || 13) } } var Dl = Fl({ name: "ripple", beforeMount(e, t) { const n = t.instance.$.appContext.config.globalProperties.$q.config || {}; if (n.ripple === !1) return; const o = { cfg: n, enabled: t.value !== !1, modifiers: {}, abort: [], start(r) { o.enabled === !0 && r.qSkipRipple !== !0 && r.type === (o.modifiers.early === !0 ? "pointerdown" : "click") && ku(r, e, o, r.qKeyEvent === !0) }, keystart: ry(r => { o.enabled === !0 && r.qSkipRipple !== !0 && en(r, o.modifiers.keyCodes) === !0 && r.type === `key${o.modifiers.early === !0 ? "down" : "up"}` && ku(r, e, o, !0) }, 300) }; Su(o, t), e.__qripple = o, Nn(o, "main", [[e, "pointerdown", "start", "passive"], [e, "click", "start", "passive"], [e, "keydown", "keystart", "passive"], [e, "keyup", "keystart", "passive"]]) }, updated(e, t) { if (t.oldValue !== t.value) { const n = e.__qripple; n !== void 0 && (n.enabled = t.value !== !1, n.enabled === !0 && Object(t.value) === t.value && Su(n, t)) } }, beforeUnmount(e) { const t = e.__qripple; t !== void 0 && (t.abort.forEach(n => { n() }), sr(t, "main"), delete e._qripple) } }); let ys, Kr = 0; const lt = new Array(256); for (let e = 0; e < 256; e++)lt[e] = (e + 256).toString(16).substring(1); const iy = (() => { const e = typeof crypto != "undefined" ? crypto : typeof window != "undefined" ? window.crypto || window.msCrypto : void 0; if (e !== void 0) { if (e.randomBytes !== void 0) return e.randomBytes; if (e.getRandomValues !== void 0) return t => { const n = new Uint8Array(t); return e.getRandomValues(n), n } } return t => { const n = []; for (let o = t; o > 0; o--)n.push(Math.floor(Math.random() * 256)); return n } })(), Eu = 4096; function lf() { (ys === void 0 || Kr + 16 > Eu) && (Kr = 0, ys = iy(Eu)); const e = Array.prototype.slice.call(ys, Kr, Kr += 16); return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, lt[e[0]] + lt[e[1]] + lt[e[2]] + lt[e[3]] + "-" + lt[e[4]] + lt[e[5]] + "-" + lt[e[6]] + lt[e[7]] + "-" + lt[e[8]] + lt[e[9]] + "-" + lt[e[10]] + lt[e[11]] + lt[e[12]] + lt[e[13]] + lt[e[14]] + lt[e[15]] } let sy = 0; const ly = ["click", "keydown"], ay = { icon: String, label: [Number, String], alert: [Boolean, String], alertIcon: String, name: { type: [Number, String], default: () => `t_${sy++}` }, noCaps: Boolean, tabindex: [String, Number], disable: Boolean, contentClass: String, ripple: { type: [Boolean, Object], default: !0 } }; function uy(e, t, n, o) { const r = Le($d, ot); if (r === ot) return console.error("QTab/QRouteTab component needs to be child of QTabs"), ot; const { proxy: i } = Ee(), s = z(null), l = z(null), a = z(null), c = y(() => e.disable === !0 || e.ripple === !1 ? !1 : Object.assign({ keyCodes: [13, 32], early: !0 }, e.ripple === !0 ? {} : e.ripple)), u = y(() => r.currentModel.value === e.name), d = y(() => "q-tab relative-position self-stretch flex flex-center text-center" + (u.value === !0 ? " q-tab--active" + (r.tabProps.value.activeClass ? " " + r.tabProps.value.activeClass : "") + (r.tabProps.value.activeColor ? ` text-${r.tabProps.value.activeColor}` : "") + (r.tabProps.value.activeBgColor ? ` bg-${r.tabProps.value.activeBgColor}` : "") : " q-tab--inactive") + (e.icon && e.label && r.tabProps.value.inlineLabel === !1 ? " q-tab--full" : "") + (e.noCaps === !0 || r.tabProps.value.noCaps === !0 ? " q-tab--no-caps" : "") + (e.disable === !0 ? " disabled" : " q-focusable q-hoverable cursor-pointer") + (o !== void 0 ? o.linkClass.value : "")), f = y(() => "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable " + (r.tabProps.value.inlineLabel === !0 ? "row no-wrap q-tab__content--inline" : "column") + (e.contentClass !== void 0 ? ` ${e.contentClass}` : "")), h = y(() => e.disable === !0 || r.hasFocus.value === !0 || u.value === !1 && r.hasActiveTab.value === !0 ? -1 : e.tabindex || 0); function v(m, w) { if (w !== !0 && s.value !== null && s.value.focus(), e.disable === !0) { o !== void 0 && o.hasRouterLink.value === !0 && Be(m); return } if (o === void 0) { r.updateModel({ name: e.name }), n("click", m); return } if (o.hasRouterLink.value === !0) { const S = (k = {}) => { let T; const q = k.to === void 0 || un(k.to, e.to) === !0 ? r.avoidRouteWatcher = lf() : null; return o.navigateToRouterLink(m, { ...k, returnRouterError: !0 }).catch(F => { T = F }).then(F => { if (q === r.avoidRouteWatcher && (r.avoidRouteWatcher = !1, T === void 0 && (F === void 0 || F.message.startsWith("Avoided redundant navigation") === !0) && r.updateModel({ name: e.name })), k.returnRouterError === !0) return T !== void 0 ? Promise.reject(T) : F }) }; n("click", m, S), m.defaultPrevented !== !0 && S(); return } n("click", m) } function x(m) { en(m, [13, 32]) ? v(m, !0) : Hi(m) !== !0 && m.keyCode >= 35 && m.keyCode <= 40 && m.altKey !== !0 && m.metaKey !== !0 && r.onKbdNavigate(m.keyCode, i.$el) === !0 && Be(m), n("keydown", m) } function _() { const m = r.tabProps.value.narrowIndicator, w = [], S = b("div", { ref: a, class: ["q-tab__indicator", r.tabProps.value.indicatorClass] }); e.icon !== void 0 && w.push(b(ct, { class: "q-tab__icon", name: e.icon })), e.label !== void 0 && w.push(b("div", { class: "q-tab__label" }, e.label)), e.alert !== !1 && w.push(e.alertIcon !== void 0 ? b(ct, { class: "q-tab__alert-icon", color: e.alert !== !0 ? e.alert : void 0, name: e.alertIcon }) : b("div", { class: "q-tab__alert" + (e.alert !== !0 ? ` text-${e.alert}` : "") })), m === !0 && w.push(S); const k = [b("div", { class: "q-focus-helper", tabindex: -1, ref: s }), b("div", { class: f.value }, Lt(t.default, w))]; return m === !1 && k.push(S), k } const A = { name: y(() => e.name), rootRef: l, tabIndicatorRef: a, routeData: o }; Re(() => { r.unregisterTab(A) }), et(() => { r.registerTab(A) }); function g(m, w) { const S = { ref: l, class: d.value, tabindex: h.value, role: "tab", "aria-selected": u.value === !0 ? "true" : "false", "aria-disabled": e.disable === !0 ? "true" : void 0, onClick: v, onKeydown: x, ...w }; return Rt(b(m, S, _()), [[Dl, c.value]]) } return { renderTab: g, $tabs: r } } var Ho = qe({ name: "QRouteTab", props: { ...Nl, ...ay }, emits: ly, setup(e, { slots: t, emit: n }) { const o = jl({ useDisableForRouterLinkProps: !1 }), { renderTab: r, $tabs: i } = uy(e, t, n, { exact: y(() => e.exact), ...o }); return de(() => `${e.name} | ${e.exact} | ${(o.resolvedLink.value || {}).href}`, () => { i.verifyRouteModel() }), () => r(o.linkTag.value, o.linkAttrs.value) } }); function cr() { let e; const t = Ee(); function n() { e = void 0 } return Yn(n), Re(n), { removeTick: n, registerTick(o) { e = o, Ie(() => { e === o && (Vl(t) === !1 && e(), e = void 0) }) } } } function yi() { let e = null; const t = Ee(); function n() { e !== null && (clearTimeout(e), e = null) } return Yn(n), Re(n), { removeTimeout: n, registerTimeout(o, r) { n(), Vl(t) === !1 && (e = setTimeout(o, r)) } } } let kr = !1; { const e = document.createElement("div"); e.setAttribute("dir", "rtl"), Object.assign(e.style, { width: "1px", height: "1px", overflow: "auto" }); const t = document.createElement("div"); Object.assign(t.style, { width: "1000px", height: "1px" }), document.body.appendChild(e), e.appendChild(t), e.scrollLeft = -1e3, kr = e.scrollLeft >= 0, e.remove() } function cy(e, t, n) { const o = n === !0 ? ["left", "right"] : ["top", "bottom"]; return `absolute-${t === !0 ? o[0] : o[1]}${e ? ` text-${e}` : ""}` } const dy = ["left", "center", "right", "justify"]; var fy = qe({ name: "QTabs", props: { modelValue: [Number, String], align: { type: String, default: "center", validator: e => dy.includes(e) }, breakpoint: { type: [String, Number], default: 600 }, vertical: Boolean, shrink: Boolean, stretch: Boolean, activeClass: String, activeColor: String, activeBgColor: String, indicatorColor: String, leftIcon: String, rightIcon: String, outsideArrows: Boolean, mobileArrows: Boolean, switchIndicator: Boolean, narrowIndicator: Boolean, inlineLabel: Boolean, noCaps: Boolean, dense: Boolean, contentClass: String, "onUpdate:modelValue": [Function, Array] }, setup(e, { slots: t, emit: n }) { const { proxy: o } = Ee(), { $q: r } = o, { registerTick: i } = cr(), { registerTick: s } = cr(), { registerTick: l } = cr(), { registerTimeout: a, removeTimeout: c } = yi(), { registerTimeout: u, removeTimeout: d } = yi(), f = z(null), h = z(null), v = z(e.modelValue), x = z(!1), _ = z(!0), A = z(!1), g = z(!1), m = [], w = z(0), S = z(!1); let k = null, T = null, q; const F = y(() => ({ activeClass: e.activeClass, activeColor: e.activeColor, activeBgColor: e.activeBgColor, indicatorClass: cy(e.indicatorColor, e.switchIndicator, e.vertical), narrowIndicator: e.narrowIndicator, inlineLabel: e.inlineLabel, noCaps: e.noCaps })), B = y(() => { const P = w.value, Q = v.value; for (let Z = 0; Z < P; Z++)if (m[Z].name.value === Q) return !0; return !1 }), j = y(() => `q-tabs__content--align-${x.value === !0 ? "left" : g.value === !0 ? "justify" : e.align}`), $ = y(() => `q-tabs row no-wrap items-center q-tabs--${x.value === !0 ? "" : "not-"}scrollable q-tabs--${e.vertical === !0 ? "vertical" : "horizontal"} q-tabs__arrows--${e.outsideArrows === !0 ? "outside" : "inside"} q-tabs--mobile-with${e.mobileArrows === !0 ? "" : "out"}-arrows` + (e.dense === !0 ? " q-tabs--dense" : "") + (e.shrink === !0 ? " col-shrink" : "") + (e.stretch === !0 ? " self-stretch" : "")), M = y(() => "q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position " + j.value + (e.contentClass !== void 0 ? ` ${e.contentClass}` : "")), R = y(() => e.vertical === !0 ? { container: "height", content: "offsetHeight", scroll: "scrollHeight" } : { container: "width", content: "offsetWidth", scroll: "scrollWidth" }), ee = y(() => e.vertical !== !0 && r.lang.rtl === !0), fe = y(() => kr === !1 && ee.value === !0); de(ee, J), de(() => e.modelValue, P => { D({ name: P, setCurrent: !0, skipEmit: !0 }) }), de(() => e.outsideArrows, oe); function D({ name: P, setCurrent: Q, skipEmit: Z }) { v.value !== P && (Z !== !0 && e["onUpdate:modelValue"] !== void 0 && n("update:modelValue", P), (Q === !0 || e["onUpdate:modelValue"] === void 0) && (ne(v.value, P), v.value = P)) } function oe() { i(() => { Ce({ width: f.value.offsetWidth, height: f.value.offsetHeight }) }) } function Ce(P) { if (R.value === void 0 || h.value === null) return; const Q = P[R.value.container], Z = Math.min(h.value[R.value.scroll], Array.prototype.reduce.call(h.value.children, (he, me) => he + (me[R.value.content] || 0), 0)), le = Q > 0 && Z > Q; x.value = le, le === !0 && s(J), g.value = Q < parseInt(e.breakpoint, 10) } function ne(P, Q) { const Z = P != null && P !== "" ? m.find(he => he.name.value === P) : null, le = Q != null && Q !== "" ? m.find(he => he.name.value === Q) : null; if (Z && le) { const he = Z.tabIndicatorRef.value, me = le.tabIndicatorRef.value; k !== null && (clearTimeout(k), k = null), he.style.transition = "none", he.style.transform = "none", me.style.transition = "none", me.style.transform = "none"; const pe = he.getBoundingClientRect(), be = me.getBoundingClientRect(); me.style.transform = e.vertical === !0 ? `translate3d(0,${pe.top - be.top}px,0) scale3d(1,${be.height ? pe.height / be.height : 1},1)` : `translate3d(${pe.left - be.left}px,0,0) scale3d(${be.width ? pe.width / be.width : 1},1,1)`, l(() => { k = setTimeout(() => { k = null, me.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)", me.style.transform = "none" }, 70) }) } le && x.value === !0 && O(le.rootRef.value) } function O(P) { const { left: Q, width: Z, top: le, height: he } = h.value.getBoundingClientRect(), me = P.getBoundingClientRect(); let pe = e.vertical === !0 ? me.top - le : me.left - Q; if (pe < 0) { h.value[e.vertical === !0 ? "scrollTop" : "scrollLeft"] += Math.floor(pe), J(); return } pe += e.vertical === !0 ? me.height - he : me.width - Z, pe > 0 && (h.value[e.vertical === !0 ? "scrollTop" : "scrollLeft"] += Math.ceil(pe), J()) } function J() { const P = h.value; if (P === null) return; const Q = P.getBoundingClientRect(), Z = e.vertical === !0 ? P.scrollTop : Math.abs(P.scrollLeft); ee.value === !0 ? (_.value = Math.ceil(Z + Q.width) < P.scrollWidth - 1, A.value = Z > 0) : (_.value = Z > 0, A.value = e.vertical === !0 ? Math.ceil(Z + Q.height) < P.scrollHeight : Math.ceil(Z + Q.width) < P.scrollWidth) } function ue(P) { T !== null && clearInterval(T), T = setInterval(() => { W(P) === !0 && U() }, 5) } function we() { ue(fe.value === !0 ? Number.MAX_SAFE_INTEGER : 0) } function N() { ue(fe.value === !0 ? 0 : Number.MAX_SAFE_INTEGER) } function U() { T !== null && (clearInterval(T), T = null) } function L(P, Q) { const Z = Array.prototype.filter.call(h.value.children, be => be === Q || be.matches && be.matches(".q-tab.q-focusable") === !0), le = Z.length; if (le === 0) return; if (P === 36) return O(Z[0]), Z[0].focus(), !0; if (P === 35) return O(Z[le - 1]), Z[le - 1].focus(), !0; const he = P === (e.vertical === !0 ? 38 : 37), me = P === (e.vertical === !0 ? 40 : 39), pe = he === !0 ? -1 : me === !0 ? 1 : void 0; if (pe !== void 0) { const be = ee.value === !0 ? -1 : 1, Te = Z.indexOf(Q) + pe * be; return Te >= 0 && Te < le && (O(Z[Te]), Z[Te].focus({ preventScroll: !0 })), !0 } } const X = y(() => fe.value === !0 ? { get: P => Math.abs(P.scrollLeft), set: (P, Q) => { P.scrollLeft = -Q } } : e.vertical === !0 ? { get: P => P.scrollTop, set: (P, Q) => { P.scrollTop = Q } } : { get: P => P.scrollLeft, set: (P, Q) => { P.scrollLeft = Q } }); function W(P) { const Q = h.value, { get: Z, set: le } = X.value; let he = !1, me = Z(Q); const pe = P < me ? -1 : 1; return me += pe * 5, me < 0 ? (he = !0, me = 0) : (pe === -1 && me <= P || pe === 1 && me >= P) && (he = !0, me = P), le(Q, me), J(), he } function ye(P, Q) { for (const Z in P) if (P[Z] !== Q[Z]) return !1; return !0 } function ge() { let P = null, Q = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 }; const Z = m.filter(pe => pe.routeData !== void 0 && pe.routeData.hasRouterLink.value === !0), { hash: le, query: he } = o.$route, me = Object.keys(he).length; for (const pe of Z) { const be = pe.routeData.exact.value === !0; if (pe.routeData[be === !0 ? "linkIsExactActive" : "linkIsActive"].value !== !0) continue; const { hash: Te, query: Ke, matched: yt, href: Jn } = pe.routeData.resolvedLink.value, bt = Object.keys(Ke).length; if (be === !0) { if (Te !== le || bt !== me || ye(he, Ke) === !1) continue; P = pe.name.value; break } if (Te !== "" && Te !== le || bt !== 0 && ye(Ke, he) === !1) continue; const mt = { matchedLen: yt.length, queryDiff: me - bt, hrefLen: Jn.length - Te.length }; if (mt.matchedLen > Q.matchedLen) { P = pe.name.value, Q = mt; continue } else if (mt.matchedLen !== Q.matchedLen) continue; if (mt.queryDiff < Q.queryDiff) P = pe.name.value, Q = mt; else if (mt.queryDiff !== Q.queryDiff) continue; mt.hrefLen > Q.hrefLen && (P = pe.name.value, Q = mt) } P === null && m.some(pe => pe.routeData === void 0 && pe.name.value === v.value) === !0 || D({ name: P, setCurrent: !0 }) } function p(P) { if (c(), S.value !== !0 && f.value !== null && P.target && typeof P.target.closest == "function") { const Q = P.target.closest(".q-tab"); Q && f.value.contains(Q) === !0 && (S.value = !0, x.value === !0 && O(Q)) } } function C() { a(() => { S.value = !1 }, 30) } function I() { se.avoidRouteWatcher === !1 ? u(ge) : d() } function H() { if (q === void 0) { const P = de(() => o.$route.fullPath, I); q = () => { P(), q = void 0 } } } function G(P) { m.push(P), w.value++, oe(), P.routeData === void 0 || o.$route === void 0 ? u(() => { if (x.value === !0) { const Q = v.value, Z = Q != null && Q !== "" ? m.find(le => le.name.value === Q) : null; Z && O(Z.rootRef.value) } }) : (H(), P.routeData.hasRouterLink.value === !0 && I()) } function re(P) { m.splice(m.indexOf(P), 1), w.value--, oe(), q !== void 0 && P.routeData !== void 0 && (m.every(Q => Q.routeData === void 0) === !0 && q(), I()) } const se = { currentModel: v, tabProps: F, hasFocus: S, hasActiveTab: B, registerTab: G, unregisterTab: re, verifyRouteModel: I, updateModel: D, onKbdNavigate: L, avoidRouteWatcher: !1 }; xt($d, se); function te() { k !== null && clearTimeout(k), U(), q !== void 0 && q() } let Y; return Re(te), Yn(() => { Y = q !== void 0, te() }), Rr(() => { Y === !0 && H(), oe() }), () => b("div", { ref: f, class: $.value, role: "tablist", onFocusin: p, onFocusout: C }, [b(xr, { onResize: Ce }), b("div", { ref: h, class: M.value, onScroll: J }, He(t.default)), b(ct, { class: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon" + (_.value === !0 ? "" : " q-tabs__arrow--faded"), name: e.leftIcon || r.iconSet.tabs[e.vertical === !0 ? "up" : "left"], onMousedownPassive: we, onTouchstartPassive: we, onMouseupPassive: U, onMouseleavePassive: U, onTouchendPassive: U }), b(ct, { class: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon" + (A.value === !0 ? "" : " q-tabs__arrow--faded"), name: e.rightIcon || r.iconSet.tabs[e.vertical === !0 ? "down" : "right"], onMousedownPassive: N, onTouchstartPassive: N, onMouseupPassive: U, onMouseleavePassive: U, onTouchendPassive: U })]) } }), hy = qe({ name: "QFooter", props: { modelValue: { type: Boolean, default: !0 }, reveal: Boolean, bordered: Boolean, elevated: Boolean, heightHint: { type: [String, Number], default: 50 } }, emits: ["reveal", "focusin"], setup(e, { slots: t, emit: n }) { const { proxy: { $q: o } } = Ee(), r = Le(Mr, ot); if (r === ot) return console.error("QFooter needs to be child of QLayout"), ot; const i = z(parseInt(e.heightHint, 10)), s = z(!0), l = z(Ht.value === !0 || r.isContainer.value === !0 ? 0 : window.innerHeight), a = y(() => e.reveal === !0 || r.view.value.indexOf("F") > -1 || o.platform.is.ios && r.isContainer.value === !0), c = y(() => r.isContainer.value === !0 ? r.containerHeight.value : l.value), u = y(() => { if (e.modelValue !== !0) return 0; if (a.value === !0) return s.value === !0 ? i.value : 0; const S = r.scroll.value.position + c.value + i.value - r.height.value; return S > 0 ? S : 0 }), d = y(() => e.modelValue !== !0 || a.value === !0 && s.value !== !0), f = y(() => e.modelValue === !0 && d.value === !0 && e.reveal === !0), h = y(() => "q-footer q-layout__section--marginal " + (a.value === !0 ? "fixed" : "absolute") + "-bottom" + (e.bordered === !0 ? " q-footer--bordered" : "") + (d.value === !0 ? " q-footer--hidden" : "") + (e.modelValue !== !0 ? " q-layout--prevent-focus" + (a.value !== !0 ? " hidden" : "") : "")), v = y(() => { const S = r.rows.value.bottom, k = {}; return S[0] === "l" && r.left.space === !0 && (k[o.lang.rtl === !0 ? "right" : "left"] = `${r.left.size}px`), S[2] === "r" && r.right.space === !0 && (k[o.lang.rtl === !0 ? "left" : "right"] = `${r.right.size}px`), k }); function x(S, k) { r.update("footer", S, k) } function _(S, k) { S.value !== k && (S.value = k) } function A({ height: S }) { _(i, S), x("size", S) } function g() { if (e.reveal !== !0) return; const { direction: S, position: k, inflectionPoint: T } = r.scroll.value; _(s, S === "up" || k - T < 100 || r.height.value - c.value - k - i.value < 300) } function m(S) { f.value === !0 && _(s, !0), n("focusin", S) } de(() => e.modelValue, S => { x("space", S), _(s, !0), r.animate() }), de(u, S => { x("offset", S) }), de(() => e.reveal, S => { S === !1 && _(s, e.modelValue) }), de(s, S => { r.animate(), n("reveal", S) }), de([i, r.scroll, r.height], g), de(() => o.screen.height, S => { r.isContainer.value !== !0 && _(l, S) }); const w = {}; return r.instances.footer = w, e.modelValue === !0 && x("size", i.value), x("space", e.modelValue), x("offset", u.value), Re(() => { r.instances.footer === w && (r.instances.footer = void 0, x("size", 0), x("offset", 0), x("space", !1)) }), () => { const S = Lt(t.default, [b(xr, { debounce: 0, onResize: A })]); return e.elevated === !0 && S.push(b("div", { class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events" })), b("footer", { class: h.value, style: v.value, onFocusin: m }, S) } } }); const my = [null, document, document.body, document.scrollingElement, document.documentElement]; function af(e, t) { let n = oy(t); if (n === void 0) { if (e == null) return window; n = e.closest(".scroll,.scroll-y,.overflow-auto") } return my.includes(n) ? window : n } function uf(e) { return e === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : e.scrollTop } function cf(e) { return e === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : e.scrollLeft } let Ur; function ni() { if (Ur !== void 0) return Ur; const e = document.createElement("p"), t = document.createElement("div"); Qs(e, { width: "100%", height: "200px" }), Qs(t, { position: "absolute", top: "0px", left: "0px", visibility: "hidden", width: "200px", height: "150px", overflow: "hidden" }), t.appendChild(e), document.body.appendChild(t); const n = e.offsetWidth; t.style.overflow = "scroll"; let o = e.offsetWidth; return n === o && (o = t.clientWidth), t.remove(), Ur = n - o, Ur } function vy(e, t = !0) { return !e || e.nodeType !== Node.ELEMENT_NODE ? !1 : t ? e.scrollHeight > e.clientHeight && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-y"])) : e.scrollWidth > e.clientWidth && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-x"])) } const { passive: qu } = Je, py = ["both", "horizontal", "vertical"]; var gy = qe({ name: "QScrollObserver", props: { axis: { type: String, validator: e => py.includes(e), default: "vertical" }, debounce: [String, Number], scrollTarget: { default: void 0 } }, emits: ["scroll"], setup(e, { emit: t }) { const n = { position: { top: 0, left: 0 }, direction: "down", directionChanged: !1, delta: { top: 0, left: 0 }, inflectionPoint: { top: 0, left: 0 } }; let o = null, r, i; de(() => e.scrollTarget, () => { a(), l() }); function s() { o !== null && o(); const d = Math.max(0, uf(r)), f = cf(r), h = { top: d - n.position.top, left: f - n.position.left }; if (e.axis === "vertical" && h.top === 0 || e.axis === "horizontal" && h.left === 0) return; const v = Math.abs(h.top) >= Math.abs(h.left) ? h.top < 0 ? "up" : "down" : h.left < 0 ? "left" : "right"; n.position = { top: d, left: f }, n.directionChanged = n.direction !== v, n.delta = h, n.directionChanged === !0 && (n.direction = v, n.inflectionPoint = n.position), t("scroll", { ...n }) } function l() { r = af(i, e.scrollTarget), r.addEventListener("scroll", c, qu), c(!0) } function a() { r !== void 0 && (r.removeEventListener("scroll", c, qu), r = void 0) } function c(d) { if (d === !0 || e.debounce === 0 || e.debounce === "0") s(); else if (o === null) { const [f, h] = e.debounce ? [setTimeout(s, e.debounce), clearTimeout] : [requestAnimationFrame(s), cancelAnimationFrame]; o = () => { h(f), o = null } } } const { proxy: u } = Ee(); return de(() => u.$q.lang.rtl, s), et(() => { i = u.$el.parentNode, l() }), Re(() => { o !== null && o(), a() }), Object.assign(u, { trigger: c, getPosition: () => n }), hn } }), yy = qe({ name: "QLayout", props: { container: Boolean, view: { type: String, default: "hhh lpr fff", validator: e => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(e.toLowerCase()) }, onScroll: Function, onScrollHeight: Function, onResize: Function }, setup(e, { slots: t, emit: n }) { const { proxy: { $q: o } } = Ee(), r = z(null), i = z(o.screen.height), s = z(e.container === !0 ? 0 : o.screen.width), l = z({ position: 0, direction: "down", inflectionPoint: 0 }), a = z(0), c = z(Ht.value === !0 ? 0 : ni()), u = y(() => "q-layout q-layout--" + (e.container === !0 ? "containerized" : "standard")), d = y(() => e.container === !1 ? { minHeight: o.screen.height + "px" } : null), f = y(() => c.value !== 0 ? { [o.lang.rtl === !0 ? "left" : "right"]: `${c.value}px` } : null), h = y(() => c.value !== 0 ? { [o.lang.rtl === !0 ? "right" : "left"]: 0, [o.lang.rtl === !0 ? "left" : "right"]: `-${c.value}px`, width: `calc(100% + ${c.value}px)` } : null); function v(w) { if (e.container === !0 || document.qScrollPrevented !== !0) { const S = { position: w.position.top, direction: w.direction, directionChanged: w.directionChanged, inflectionPoint: w.inflectionPoint.top, delta: w.delta.top }; l.value = S, e.onScroll !== void 0 && n("scroll", S) } } function x(w) { const { height: S, width: k } = w; let T = !1; i.value !== S && (T = !0, i.value = S, e.onScrollHeight !== void 0 && n("scrollHeight", S), A()), s.value !== k && (T = !0, s.value = k), T === !0 && e.onResize !== void 0 && n("resize", w) } function _({ height: w }) { a.value !== w && (a.value = w, A()) } function A() { if (e.container === !0) { const w = i.value > a.value ? ni() : 0; c.value !== w && (c.value = w) } } let g = null; const m = { instances: {}, view: y(() => e.view), isContainer: y(() => e.container), rootRef: r, height: i, containerHeight: a, scrollbarWidth: c, totalWidth: y(() => s.value + c.value), rows: y(() => { const w = e.view.toLowerCase().split(" "); return { top: w[0].split(""), middle: w[1].split(""), bottom: w[2].split("") } }), header: Ot({ size: 0, offset: 0, space: !1 }), right: Ot({ size: 300, offset: 0, space: !1 }), footer: Ot({ size: 0, offset: 0, space: !1 }), left: Ot({ size: 300, offset: 0, space: !1 }), scroll: l, animate() { g !== null ? clearTimeout(g) : document.body.classList.add("q-body--layout-animate"), g = setTimeout(() => { g = null, document.body.classList.remove("q-body--layout-animate") }, 155) }, update(w, S, k) { m[w][S] = k } }; if (xt(Mr, m), ni() > 0) { let k = function () { w = null, S.classList.remove("hide-scrollbar") }, T = function () { if (w === null) { if (S.scrollHeight > o.screen.height) return; S.classList.add("hide-scrollbar") } else clearTimeout(w); w = setTimeout(k, 300) }, q = function (F) { w !== null && F === "remove" && (clearTimeout(w), k()), window[`${F}EventListener`]("resize", T) }, w = null; const S = document.body; de(() => e.container !== !0 ? "add" : "remove", q), e.container !== !0 && q("add"), Fi(() => { q("remove") }) } return () => { const w = Lt(t.default, [b(gy, { onScroll: v }), b(xr, { onResize: x })]), S = b("div", { class: u.value, style: d.value, ref: e.container === !0 ? void 0 : r, tabindex: -1 }, w); return e.container === !0 ? b("div", { class: "q-layout-container overflow-hidden", ref: r }, [b(xr, { onResize: _ }), b("div", { class: "absolute-full", style: f.value }, [b("div", { class: "scroll", style: h.value }, [S])])]) : S } } }); const by = [{ title: "Mapa en tiempo real", caption: "Ver mapa en tiempo real", icon: "public", to: "/" }, { title: "Carnaval de Oruro", caption: "Ver informaci\xF3n del carnaval", icon: "o_info", to: "/carnaval" }, { title: "18 especialidades de danza", caption: "Ver informaci\xF3n de las 18 especialidades de danza", icon: "palette", to: "/especialidades" }, { title: "52 conjuntos folcl\xF3ricos", caption: "Ver informaci\xF3n de los 52 conjuntos folcl\xF3ricos", icon: "o_broken_image", to: "/sets" }, { title: "Galer\xEDa de fotograf\xEDas", caption: "Ver galer\xEDa de fotograf\xEDas", icon: "o_photo_camera", to: "/photo" }, { title: "Virgen del socav\xF3n", caption: "Ver informaci\xF3n de la virgen del socav\xF3n", icon: "query_stats", to: "/statue" }, { title: "Riqueza cultural", caption: "Ver informaci\xF3n de la riqueza cultural", icon: "blur_circular", to: "/cultura" }, { title: "Redes sociales", caption: "Ver informaci\xF3n de las redes sociales", icon: "share", to: "/social" }, { title: "Contactos", caption: "Ver informaci\xF3n de contacto", icon: "contact_mail", to: "/contact" }, { title: "Publicaciones", caption: "Ver informaci\xF3n de publicaciones", icon: "article", to: "/publications" }, { title: "Contactos con conjuntos folcl\xF3ricos", caption: "Ver informaci\xF3n de contactos con conjuntos folcl\xF3ricos", icon: "contact_mail", to: "/contactSets" }, { title: "Fechas a realizarse los siguientes carnavales", caption: "Ver informaci\xF3n de fechas a realizarse los siguientes carnavales", icon: "event", to: "/dates" }, { title: "Acerca de", caption: "Ver informaci\xF3n de acerca de", icon: "info", to: "/about" }], _y = Ne({ name: "MainLayout", setup() { const e = z(!1); return { essentialLinks: by, leftDrawerOpen: e, toggleLeftDrawer() { e.value = !e.value } } } }); function wy(e, t, n, o, r, i) { const s = Pt("router-view"); return Oe(), Qe(yy, { view: "lHh Lpr lFf" }, { default: ae(() => [K(Hg, { class: "bg-white text-black text-bold" }, { default: ae(() => [K(pu, null, { default: ae(() => [K(vu, { class: "text-center text-h5" }, { default: ae(() => [ie(" Carnaval Oruro 2023 ACFO ")]), _: 1 })]), _: 1 })]), _: 1 }), K(Kg, null, { default: ae(() => [K(s)]), _: 1 }), K(hy, { class: "bg-white text-black text-bold" }, { default: ae(() => [K(pu, null, { default: ae(() => [K(vu, { class: "text-center" }, { default: ae(() => [K(fy, null, { default: ae(() => [K(Ho, { exact: "", "active-class": "bg-red-4 text-white", "no-caps": "", to: "/", label: "Ruta", icon: "o_map" }), K(Ho, { exact: "", "active-class": "bg-red-4 text-white", "no-caps": "", to: "/point/comida", label: "Comida", icon: "o_restaurant_menu" }), K(Ho, { exact: "", "active-class": "bg-red-4 text-white", "no-caps": "", to: "/point/mercado", label: "Mercado", icon: "o_shopping_cart" }), K(Ho, { exact: "", "active-class": "bg-red-4 text-white", "no-caps": "", to: "/point/hotel", label: "Hotel", icon: "o_hotel" }), K(Ho, { exact: "", "active-class": "bg-red-4 text-white", "no-caps": "", to: "/point/hospital", label: "Hospital", icon: "o_local_hospital" })]), _: 1 })]), _: 1 })]), _: 1 })]), _: 1 })]), _: 1 }) } var Cy = Mt(_y, [["render", wy]]); const xy = b("div", { class: "q-space" }); var bi = qe({ name: "QSpace", setup() { return () => xy } }); const ky = { size: { type: [Number, String], default: "1em" }, color: String }; function Sy(e) { return { cSize: y(() => e.size in Ws ? `${Ws[e.size]}px` : e.size), classes: y(() => "q-spinner" + (e.color ? ` text-${e.color}` : "")) } } var So = qe({ name: "QSpinner", props: { ...ky, thickness: { type: Number, default: 5 } }, setup(e) { const { cSize: t, classes: n } = Sy(e); return () => b("svg", { class: n.value + " q-spinner-mat", width: t.value, height: t.value, viewBox: "25 25 50 50" }, [b("circle", { class: "path", cx: "50", cy: "50", r: "20", fill: "none", stroke: "currentColor", "stroke-width": e.thickness, "stroke-miterlimit": "10" })]) } }); const df = { left: "start", center: "center", right: "end", between: "between", around: "around", evenly: "evenly", stretch: "stretch" }, Ey = Object.keys(df), ff = { align: { type: String, validator: e => Ey.includes(e) } }; function hf(e) { return y(() => { const t = e.align === void 0 ? e.vertical === !0 ? "stretch" : "left" : e.align; return `${e.vertical === !0 ? "items" : "justify"}-${df[t]}` }) } const Tu = { none: 0, xs: 4, sm: 8, md: 16, lg: 24, xl: 32 }, qy = { xs: 8, sm: 10, md: 14, lg: 20, xl: 24 }, Ty = ["button", "submit", "reset"], Py = /[^\s]\/[^\s]/, Ay = ["flat", "outline", "push", "unelevated"], Oy = (e, t) => e.flat === !0 ? "flat" : e.outline === !0 ? "outline" : e.push === !0 ? "push" : e.unelevated === !0 ? "unelevated" : t, Ry = { ...Lo, ...Nl, type: { type: String, default: "button" }, label: [Number, String], icon: String, iconRight: String, ...Ay.reduce((e, t) => (e[t] = Boolean) && e, {}), square: Boolean, round: Boolean, rounded: Boolean, glossy: Boolean, size: String, fab: Boolean, fabMini: Boolean, padding: String, color: String, textColor: String, noCaps: Boolean, noWrap: Boolean, dense: Boolean, tabindex: [Number, String], ripple: { type: [Boolean, Object], default: !0 }, align: { ...ff.align, default: "center" }, stack: Boolean, stretch: Boolean, loading: { type: Boolean, default: null }, disable: Boolean }; function Ly(e) { const t = $o(e, qy), n = hf(e), { hasRouterLink: o, hasLink: r, linkTag: i, linkAttrs: s, navigateOnClick: l } = jl({ fallbackTag: "button" }), a = y(() => { const _ = e.fab === !1 && e.fabMini === !1 ? t.value : {}; return e.padding !== void 0 ? Object.assign({}, _, { padding: e.padding.split(/\s+/).map(A => A in Tu ? Tu[A] + "px" : A).join(" "), minWidth: "0", minHeight: "0" }) : _ }), c = y(() => e.rounded === !0 || e.fab === !0 || e.fabMini === !0), u = y(() => e.disable !== !0 && e.loading !== !0), d = y(() => u.value === !0 ? e.tabindex || 0 : -1), f = y(() => Oy(e, "standard")), h = y(() => { const _ = { tabindex: d.value }; return r.value === !0 ? Object.assign(_, s.value) : Ty.includes(e.type) === !0 && (_.type = e.type), i.value === "a" ? (e.disable === !0 ? _["aria-disabled"] = "true" : _.href === void 0 && (_.role = "button"), o.value !== !0 && Py.test(e.type) === !0 && (_.type = e.type)) : e.disable === !0 && (_.disabled = "", _["aria-disabled"] = "true"), e.loading === !0 && e.percentage !== void 0 && Object.assign(_, { role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": e.percentage }), _ }), v = y(() => { let _; e.color !== void 0 ? e.flat === !0 || e.outline === !0 ? _ = `text-${e.textColor || e.color}` : _ = `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (_ = `text-${e.textColor}`); const A = e.round === !0 ? "round" : `rectangle${c.value === !0 ? " q-btn--rounded" : e.square === !0 ? " q-btn--square" : ""}`; return `q-btn--${f.value} q-btn--${A}` + (_ !== void 0 ? " " + _ : "") + (u.value === !0 ? " q-btn--actionable q-focusable q-hoverable" : e.disable === !0 ? " disabled" : "") + (e.fab === !0 ? " q-btn--fab" : e.fabMini === !0 ? " q-btn--fab-mini" : "") + (e.noCaps === !0 ? " q-btn--no-uppercase" : "") + (e.dense === !0 ? " q-btn--dense" : "") + (e.stretch === !0 ? " no-border-radius self-stretch" : "") + (e.glossy === !0 ? " glossy" : "") + (e.square ? " q-btn--square" : "") }), x = y(() => n.value + (e.stack === !0 ? " column" : " row") + (e.noWrap === !0 ? " no-wrap text-no-wrap" : "") + (e.loading === !0 ? " q-btn__content--hidden" : "")); return { classes: v, style: a, innerClasses: x, attributes: h, hasLink: r, linkTag: i, navigateOnClick: l, isActionable: u } } const { passiveCapture: qt } = Je; let io = null, so = null, lo = null; var We = qe({ name: "QBtn", props: { ...Ry, percentage: Number, darkPercentage: Boolean, onTouchstart: [Function, Array] }, emits: ["click", "keydown", "mousedown", "keyup"], setup(e, { slots: t, emit: n }) { const { proxy: o } = Ee(), { classes: r, style: i, innerClasses: s, attributes: l, hasLink: a, linkTag: c, navigateOnClick: u, isActionable: d } = Ly(e), f = z(null), h = z(null); let v = null, x, _ = null; const A = y(() => e.label !== void 0 && e.label !== null && e.label !== ""), g = y(() => e.disable === !0 || e.ripple === !1 ? !1 : { keyCodes: a.value === !0 ? [13, 32] : [13], ...e.ripple === !0 ? {} : e.ripple }), m = y(() => ({ center: e.round })), w = y(() => { const R = Math.max(0, Math.min(100, e.percentage)); return R > 0 ? { transition: "transform 0.6s", transform: `translateX(${R - 100}%)` } : {} }), S = y(() => { if (e.loading === !0) return { onMousedown: M, onTouchstart: M, onClick: M, onKeydown: M, onKeyup: M }; if (d.value === !0) { const R = { onClick: T, onKeydown: q, onMousedown: B }; if (o.$q.platform.has.touch === !0) { const ee = e.onTouchstart !== void 0 ? "" : "Passive"; R[`onTouchstart${ee}`] = F } return R } return { onClick: Be } }), k = y(() => ({ ref: f, class: "q-btn q-btn-item non-selectable no-outline " + r.value, style: i.value, ...l.value, ...S.value })); function T(R) { if (f.value !== null) { if (R !== void 0) { if (R.defaultPrevented === !0) return; const ee = document.activeElement; if (e.type === "submit" && ee !== document.body && f.value.contains(ee) === !1 && ee.contains(f.value) === !1) { f.value.focus(); const fe = () => { document.removeEventListener("keydown", Be, !0), document.removeEventListener("keyup", fe, qt), f.value !== null && f.value.removeEventListener("blur", fe, qt) }; document.addEventListener("keydown", Be, !0), document.addEventListener("keyup", fe, qt), f.value.addEventListener("blur", fe, qt) } } u(R) } } function q(R) { f.value !== null && (n("keydown", R), en(R, [13, 32]) === !0 && so !== f.value && (so !== null && $(), R.defaultPrevented !== !0 && (f.value.focus(), so = f.value, f.value.classList.add("q-btn--active"), document.addEventListener("keyup", j, !0), f.value.addEventListener("blur", j, qt)), Be(R))) } function F(R) { f.value !== null && (n("touchstart", R), R.defaultPrevented !== !0 && (io !== f.value && (io !== null && $(), io = f.value, v = R.target, v.addEventListener("touchcancel", j, qt), v.addEventListener("touchend", j, qt)), x = !0, _ !== null && clearTimeout(_), _ = setTimeout(() => { _ = null, x = !1 }, 200))) } function B(R) { f.value !== null && (R.qSkipRipple = x === !0, n("mousedown", R), R.defaultPrevented !== !0 && lo !== f.value && (lo !== null && $(), lo = f.value, f.value.classList.add("q-btn--active"), document.addEventListener("mouseup", j, qt))) } function j(R) { if (f.value !== null && !(R !== void 0 && R.type === "blur" && document.activeElement === f.value)) { if (R !== void 0 && R.type === "keyup") { if (so === f.value && en(R, [13, 32]) === !0) { const ee = new MouseEvent("click", R); ee.qKeyEvent = !0, R.defaultPrevented === !0 && Ct(ee), R.cancelBubble === !0 && Gt(ee), f.value.dispatchEvent(ee), Be(R), R.qKeyEvent = !0 } n("keyup", R) } $() } } function $(R) { const ee = h.value; R !== !0 && (io === f.value || lo === f.value) && ee !== null && ee !== document.activeElement && (ee.setAttribute("tabindex", -1), ee.focus()), io === f.value && (v !== null && (v.removeEventListener("touchcancel", j, qt), v.removeEventListener("touchend", j, qt)), io = v = null), lo === f.value && (document.removeEventListener("mouseup", j, qt), lo = null), so === f.value && (document.removeEventListener("keyup", j, !0), f.value !== null && f.value.removeEventListener("blur", j, qt), so = null), f.value !== null && f.value.classList.remove("q-btn--active") } function M(R) { Be(R), R.qSkipRipple = !0 } return Re(() => { $(!0) }), Object.assign(o, { click: T }), () => { let R = []; e.icon !== void 0 && R.push(b(ct, { name: e.icon, left: e.stack === !1 && A.value === !0, role: "img", "aria-hidden": "true" })), A.value === !0 && R.push(b("span", { class: "block" }, [e.label])), R = Lt(t.default, R), e.iconRight !== void 0 && e.round === !1 && R.push(b(ct, { name: e.iconRight, right: e.stack === !1 && A.value === !0, role: "img", "aria-hidden": "true" })); const ee = [b("span", { class: "q-focus-helper", ref: h })]; return e.loading === !0 && e.percentage !== void 0 && ee.push(b("span", { class: "q-btn__progress absolute-full overflow-hidden" + (e.darkPercentage === !0 ? " q-btn__progress--dark" : "") }, [b("span", { class: "q-btn__progress-indicator fit block", style: w.value })])), ee.push(b("span", { class: "q-btn__content text-center col items-center q-anchor--skip " + s.value }, R)), e.loading !== null && ee.push(b(fn, { name: "q-transition--fade" }, () => e.loading === !0 ? [b("span", { key: "loading", class: "absolute-full flex flex-center" }, t.loading !== void 0 ? t.loading() : [b(So)])] : null)), Rt(b(c.value, k.value, ee), [[Dl, g.value, void 0, m.value]]) } } }), ze = qe({ name: "QCardSection", props: { tag: { type: String, default: "div" }, horizontal: Boolean }, setup(e, { slots: t }) { const n = y(() => `q-card__section q-card__section--${e.horizontal === !0 ? "horiz row no-wrap" : "vert"}`); return () => b(e.tag, { class: n.value }, He(t.default)) } }); const Ut = { dark: { type: Boolean, default: null } }; function Wt(e, t) { return y(() => e.dark === null ? t.dark.isActive : e.dark) } function $y({ validate: e, resetValidation: t, requiresQForm: n }) { const o = Le(Ld, !1); if (o !== !1) { const { props: r, proxy: i } = Ee(); Object.assign(i, { validate: e, resetValidation: t }), de(() => r.disable, s => { s === !0 ? (typeof t == "function" && t(), o.unbindComponent(i)) : o.bindComponent(i) }), et(() => { r.disable !== !0 && o.bindComponent(i) }), Re(() => { r.disable !== !0 && o.unbindComponent(i) }) } else n === !0 && console.error("Parent QForm not found on useFormChild()!") } const Pu = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, Au = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, Ou = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, Wr = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, Qr = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/, bs = { date: e => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e), time: e => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(e), fulltime: e => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(e), timeOrFulltime: e => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(e), email: e => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e), hexColor: e => Pu.test(e), hexaColor: e => Au.test(e), hexOrHexaColor: e => Ou.test(e), rgbColor: e => Wr.test(e), rgbaColor: e => Qr.test(e), rgbOrRgbaColor: e => Wr.test(e) || Qr.test(e), hexOrRgbColor: e => Pu.test(e) || Wr.test(e), hexaOrRgbaColor: e => Au.test(e) || Qr.test(e), anyColor: e => Ou.test(e) || Wr.test(e) || Qr.test(e) }, My = [!0, !1, "ondemand"], By = { modelValue: {}, error: { type: Boolean, default: null }, errorMessage: String, noErrorIcon: Boolean, rules: Array, reactiveRules: Boolean, lazyRules: { type: [Boolean, String], validator: e => My.includes(e) } }; function Iy(e, t) { const { props: n, proxy: o } = Ee(), r = z(!1), i = z(null), s = z(null); $y({ validate: v, resetValidation: h }); let l = 0, a; const c = y(() => n.rules !== void 0 && n.rules !== null && n.rules.length > 0), u = y(() => n.disable !== !0 && c.value === !0), d = y(() => n.error === !0 || r.value === !0), f = y(() => typeof n.errorMessage == "string" && n.errorMessage.length > 0 ? n.errorMessage : i.value); de(() => n.modelValue, () => { x() }), de(() => n.reactiveRules, A => { A === !0 ? a === void 0 && (a = de(() => n.rules, () => { x(!0) })) : a !== void 0 && (a(), a = void 0) }, { immediate: !0 }), de(e, A => { A === !0 ? s.value === null && (s.value = !1) : s.value === !1 && (s.value = !0, u.value === !0 && n.lazyRules !== "ondemand" && t.value === !1 && _()) }); function h() { l++, t.value = !1, s.value = null, r.value = !1, i.value = null, _.cancel() } function v(A = n.modelValue) { if (u.value !== !0) return !0; const g = ++l, m = t.value !== !0 ? () => { s.value = !0 } : () => { }, w = (k, T) => { k === !0 && m(), r.value = k, i.value = T || null, t.value = !1 }, S = []; for (let k = 0; k < n.rules.length; k++) { const T = n.rules[k]; let q; if (typeof T == "function" ? q = T(A, bs) : typeof T == "string" && bs[T] !== void 0 && (q = bs[T](A)), q === !1 || typeof q == "string") return w(!0, q), !1; q !== !0 && q !== void 0 && S.push(q) } return S.length === 0 ? (w(!1), !0) : (t.value = !0, Promise.all(S).then(k => { if (k === void 0 || Array.isArray(k) === !1 || k.length === 0) return g === l && w(!1), !0; const T = k.find(q => q === !1 || typeof q == "string"); return g === l && w(T !== void 0, T), T === void 0 }, k => (g === l && (console.error(k), w(!0)), !1))) } function x(A) { u.value === !0 && n.lazyRules !== "ondemand" && (s.value === !0 || n.lazyRules !== !0 && A !== !0) && _() } const _ = $l(v, 0); return Re(() => { a !== void 0 && a(), _.cancel() }), Object.assign(o, { resetValidation: h, validate: v }), Ro(o, "hasError", () => d.value), { isDirtyModel: s, hasRules: c, hasError: d, errorMessage: f, validate: v, resetValidation: h } } const Ru = /^on[A-Z]/; function Fy(e, t) { const n = { listeners: z({}), attributes: z({}) }; function o() { const r = {}, i = {}; for (const s in e) s !== "class" && s !== "style" && Ru.test(s) === !1 && (r[s] = e[s]); for (const s in t.props) Ru.test(s) === !0 && (i[s] = t.props[s]); n.attributes.value = r, n.listeners.value = i } return Tl(o), o(), n } let jn = [], Sr = []; function mf(e) { Sr = Sr.filter(t => t !== e) } function zy(e) { mf(e), Sr.push(e) } function Lu(e) { mf(e), Sr.length === 0 && jn.length > 0 && (jn[jn.length - 1](), jn = []) } function Br(e) { Sr.length === 0 ? e() : jn.push(e) } function Vy(e) { jn = jn.filter(t => t !== e) } function Gs(e) { return e === void 0 ? `f_${lf()}` : e } function Er(e) { return e != null && ("" + e).length > 0 } const Wi = { ...Ut, ...By, label: String, stackLabel: Boolean, hint: String, hideHint: Boolean, prefix: String, suffix: String, labelColor: String, color: String, bgColor: String, filled: Boolean, outlined: Boolean, borderless: Boolean, standout: [Boolean, String], square: Boolean, loading: Boolean, labelSlot: Boolean, bottomSlots: Boolean, hideBottomSpace: Boolean, rounded: Boolean, dense: Boolean, itemAligned: Boolean, counter: Boolean, clearable: Boolean, clearIcon: String, disable: Boolean, readonly: Boolean, autofocus: Boolean, for: String, maxlength: [Number, String] }, Hl = ["update:modelValue", "clear", "focus", "blur", "popupShow", "popupHide"]; function Kl() { const { props: e, attrs: t, proxy: n, vnode: o } = Ee(); return { isDark: Wt(e, n.$q), editable: y(() => e.disable !== !0 && e.readonly !== !0), innerLoading: z(!1), focused: z(!1), hasPopupOpen: !1, splitAttrs: Fy(t, o), targetUid: z(Gs(e.for)), rootRef: z(null), targetRef: z(null), controlRef: z(null) } } function Ul(e) { const { props: t, emit: n, slots: o, attrs: r, proxy: i } = Ee(), { $q: s } = i; let l = null; e.hasValue === void 0 && (e.hasValue = y(() => Er(t.modelValue))), e.emitValue === void 0 && (e.emitValue = D => { n("update:modelValue", D) }), e.controlEvents === void 0 && (e.controlEvents = { onFocusin: F, onFocusout: B }), Object.assign(e, { clearValue: j, onControlFocusin: F, onControlFocusout: B, focus: T }), e.computedCounter === void 0 && (e.computedCounter = y(() => { if (t.counter !== !1) { const D = typeof t.modelValue == "string" || typeof t.modelValue == "number" ? ("" + t.modelValue).length : Array.isArray(t.modelValue) === !0 ? t.modelValue.length : 0, oe = t.maxlength !== void 0 ? t.maxlength : t.maxValues; return D + (oe !== void 0 ? " / " + oe : "") } })); const { isDirtyModel: a, hasRules: c, hasError: u, errorMessage: d, resetValidation: f } = Iy(e.focused, e.innerLoading), h = e.floatingLabel !== void 0 ? y(() => t.stackLabel === !0 || e.focused.value === !0 || e.floatingLabel.value === !0) : y(() => t.stackLabel === !0 || e.focused.value === !0 || e.hasValue.value === !0), v = y(() => t.bottomSlots === !0 || t.hint !== void 0 || c.value === !0 || t.counter === !0 || t.error !== null), x = y(() => t.filled === !0 ? "filled" : t.outlined === !0 ? "outlined" : t.borderless === !0 ? "borderless" : t.standout ? "standout" : "standard"), _ = y(() => `q-field row no-wrap items-start q-field--${x.value}` + (e.fieldClass !== void 0 ? ` ${e.fieldClass.value}` : "") + (t.rounded === !0 ? " q-field--rounded" : "") + (t.square === !0 ? " q-field--square" : "") + (h.value === !0 ? " q-field--float" : "") + (g.value === !0 ? " q-field--labeled" : "") + (t.dense === !0 ? " q-field--dense" : "") + (t.itemAligned === !0 ? " q-field--item-aligned q-item-type" : "") + (e.isDark.value === !0 ? " q-field--dark" : "") + (e.getControl === void 0 ? " q-field--auto-height" : "") + (e.focused.value === !0 ? " q-field--focused" : "") + (u.value === !0 ? " q-field--error" : "") + (u.value === !0 || e.focused.value === !0 ? " q-field--highlighted" : "") + (t.hideBottomSpace !== !0 && v.value === !0 ? " q-field--with-bottom" : "") + (t.disable === !0 ? " q-field--disabled" : t.readonly === !0 ? " q-field--readonly" : "")), A = y(() => "q-field__control relative-position row no-wrap" + (t.bgColor !== void 0 ? ` bg-${t.bgColor}` : "") + (u.value === !0 ? " text-negative" : typeof t.standout == "string" && t.standout.length > 0 && e.focused.value === !0 ? ` ${t.standout}` : t.color !== void 0 ? ` text-${t.color}` : "")), g = y(() => t.labelSlot === !0 || t.label !== void 0), m = y(() => "q-field__label no-pointer-events absolute ellipsis" + (t.labelColor !== void 0 && u.value !== !0 ? ` text-${t.labelColor}` : "")), w = y(() => ({ id: e.targetUid.value, editable: e.editable.value, focused: e.focused.value, floatingLabel: h.value, modelValue: t.modelValue, emitValue: e.emitValue })), S = y(() => { const D = { for: e.targetUid.value }; return t.disable === !0 ? D["aria-disabled"] = "true" : t.readonly === !0 && (D["aria-readonly"] = "true"), D }); de(() => t.for, D => { e.targetUid.value = Gs(D) }); function k() { const D = document.activeElement; let oe = e.targetRef !== void 0 && e.targetRef.value; oe && (D === null || D.id !== e.targetUid.value) && (oe.hasAttribute("tabindex") === !0 || (oe = oe.querySelector("[tabindex]")), oe && oe !== D && oe.focus({ preventScroll: !0 })) } function T() { Br(k) } function q() { Vy(k); const D = document.activeElement; D !== null && e.rootRef.value.contains(D) && D.blur() } function F(D) { l !== null && (clearTimeout(l), l = null), e.editable.value === !0 && e.focused.value === !1 && (e.focused.value = !0, n("focus", D)) } function B(D, oe) { l !== null && clearTimeout(l), l = setTimeout(() => { l = null, !(document.hasFocus() === !0 && (e.hasPopupOpen === !0 || e.controlRef === void 0 || e.controlRef.value === null || e.controlRef.value.contains(document.activeElement) !== !1)) && (e.focused.value === !0 && (e.focused.value = !1, n("blur", D)), oe !== void 0 && oe()) }) } function j(D) { Be(D), s.platform.is.mobile !== !0 ? (e.targetRef !== void 0 && e.targetRef.value || e.rootRef.value).focus() : e.rootRef.value.contains(document.activeElement) === !0 && document.activeElement.blur(), t.type === "file" && (e.inputRef.value.value = null), n("update:modelValue", null), n("clear", t.modelValue), Ie(() => { f(), s.platform.is.mobile !== !0 && (a.value = !1) }) } function $() { const D = []; return o.prepend !== void 0 && D.push(b("div", { class: "q-field__prepend q-field__marginal row no-wrap items-center", key: "prepend", onClick: Ct }, o.prepend())), D.push(b("div", { class: "q-field__control-container col relative-position row no-wrap q-anchor--skip" }, M())), u.value === !0 && t.noErrorIcon === !1 && D.push(ee("error", [b(ct, { name: s.iconSet.field.error, color: "negative" })])), t.loading === !0 || e.innerLoading.value === !0 ? D.push(ee("inner-loading-append", o.loading !== void 0 ? o.loading() : [b(So, { color: t.color })])) : t.clearable === !0 && e.hasValue.value === !0 && e.editable.value === !0 && D.push(ee("inner-clearable-append", [b(ct, { class: "q-field__focusable-action", tag: "button", name: t.clearIcon || s.iconSet.field.clear, tabindex: 0, type: "button", "aria-hidden": null, role: null, onClick: j })])), o.append !== void 0 && D.push(b("div", { class: "q-field__append q-field__marginal row no-wrap items-center", key: "append", onClick: Ct }, o.append())), e.getInnerAppend !== void 0 && D.push(ee("inner-append", e.getInnerAppend())), e.getControlChild !== void 0 && D.push(e.getControlChild()), D } function M() { const D = []; return t.prefix !== void 0 && t.prefix !== null && D.push(b("div", { class: "q-field__prefix no-pointer-events row items-center" }, t.prefix)), e.getShadowControl !== void 0 && e.hasShadow.value === !0 && D.push(e.getShadowControl()), e.getControl !== void 0 ? D.push(e.getControl()) : o.rawControl !== void 0 ? D.push(o.rawControl()) : o.control !== void 0 && D.push(b("div", { ref: e.targetRef, class: "q-field__native row", tabindex: -1, ...e.splitAttrs.attributes.value, "data-autofocus": t.autofocus === !0 || void 0 }, o.control(w.value))), g.value === !0 && D.push(b("div", { class: m.value }, He(o.label, t.label))), t.suffix !== void 0 && t.suffix !== null && D.push(b("div", { class: "q-field__suffix no-pointer-events row items-center" }, t.suffix)), D.concat(He(o.default)) } function R() { let D, oe; u.value === !0 ? d.value !== null ? (D = [b("div", { role: "alert" }, d.value)], oe = `q--slot-error-${d.value}`) : (D = He(o.error), oe = "q--slot-error") : (t.hideHint !== !0 || e.focused.value === !0) && (t.hint !== void 0 ? (D = [b("div", t.hint)], oe = `q--slot-hint-${t.hint}`) : (D = He(o.hint), oe = "q--slot-hint")); const Ce = t.counter === !0 || o.counter !== void 0; if (t.hideBottomSpace === !0 && Ce === !1 && D === void 0) return; const ne = b("div", { key: oe, class: "q-field__messages col" }, D); return b("div", { class: "q-field__bottom row items-start q-field__bottom--" + (t.hideBottomSpace !== !0 ? "animated" : "stale"), onClick: Ct }, [t.hideBottomSpace === !0 ? ne : b(fn, { name: "q-transition--field-message" }, () => ne), Ce === !0 ? b("div", { class: "q-field__counter" }, o.counter !== void 0 ? o.counter() : e.computedCounter.value) : null]) } function ee(D, oe) { return oe === null ? null : b("div", { key: D, class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip" }, oe) } let fe = !1; return Yn(() => { fe = !0 }), Rr(() => { fe === !0 && t.autofocus === !0 && i.focus() }), et(() => { Ht.value === !0 && t.for === void 0 && (e.targetUid.value = Gs()), t.autofocus === !0 && i.focus() }), Re(() => { l !== null && clearTimeout(l) }), Object.assign(i, { focus: T, blur: q }), function () { const oe = e.getControl === void 0 && o.control === void 0 ? { ...e.splitAttrs.attributes.value, "data-autofocus": t.autofocus === !0 || void 0, ...S.value } : S.value; return b("label", { ref: e.rootRef, class: [_.value, r.class], style: r.style, ...oe }, [o.before !== void 0 ? b("div", { class: "q-field__before q-field__marginal row no-wrap items-center", onClick: Ct }, o.before()) : null, b("div", { class: "q-field__inner relative-position col self-stretch" }, [b("div", { ref: e.controlRef, class: A.value, tabindex: -1, ...e.controlEvents }, $()), v.value === !0 ? R() : null]), o.after !== void 0 ? b("div", { class: "q-field__after q-field__marginal row no-wrap items-center", onClick: Ct }, o.after()) : null]) } } var Ny = qe({ name: "QField", inheritAttrs: !1, props: Wi, emits: Hl, setup() { return Ul(Kl()) } }); const jy = { xs: 8, sm: 10, md: 14, lg: 20, xl: 24 }; var Dy = qe({ name: "QChip", props: { ...Ut, ...Lo, dense: Boolean, icon: String, iconRight: String, iconRemove: String, iconSelected: String, label: [String, Number], color: String, textColor: String, modelValue: { type: Boolean, default: !0 }, selected: { type: Boolean, default: null }, square: Boolean, outline: Boolean, clickable: Boolean, removable: Boolean, removeAriaLabel: String, tabindex: [String, Number], disable: Boolean, ripple: { type: [Boolean, Object], default: !0 } }, emits: ["update:modelValue", "update:selected", "remove", "click"], setup(e, { slots: t, emit: n }) { const { proxy: { $q: o } } = Ee(), r = Wt(e, o), i = $o(e, jy), s = y(() => e.selected === !0 || e.icon !== void 0), l = y(() => e.selected === !0 ? e.iconSelected || o.iconSet.chip.selected : e.icon), a = y(() => e.iconRemove || o.iconSet.chip.remove), c = y(() => e.disable === !1 && (e.clickable === !0 || e.selected !== null)), u = y(() => { const _ = e.outline === !0 && e.color || e.textColor; return "q-chip row inline no-wrap items-center" + (e.outline === !1 && e.color !== void 0 ? ` bg-${e.color}` : "") + (_ ? ` text-${_} q-chip--colored` : "") + (e.disable === !0 ? " disabled" : "") + (e.dense === !0 ? " q-chip--dense" : "") + (e.outline === !0 ? " q-chip--outline" : "") + (e.selected === !0 ? " q-chip--selected" : "") + (c.value === !0 ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (e.square === !0 ? " q-chip--square" : "") + (r.value === !0 ? " q-chip--dark q-dark" : "") }), d = y(() => { const _ = e.disable === !0 ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: e.tabindex || 0 }, A = { ..._, role: "button", "aria-hidden": "false", "aria-label": e.removeAriaLabel || o.lang.label.remove }; return { chip: _, remove: A } }); function f(_) { _.keyCode === 13 && h(_) } function h(_) { e.disable || (n("update:selected", !e.selected), n("click", _)) } function v(_) { (_.keyCode === void 0 || _.keyCode === 13) && (Be(_), e.disable === !1 && (n("update:modelValue", !1), n("remove"))) } function x() { const _ = []; c.value === !0 && _.push(b("div", { class: "q-focus-helper" })), s.value === !0 && _.push(b(ct, { class: "q-chip__icon q-chip__icon--left", name: l.value })); const A = e.label !== void 0 ? [b("div", { class: "ellipsis" }, [e.label])] : void 0; return _.push(b("div", { class: "q-chip__content col row no-wrap items-center q-anchor--skip" }, Jd(t.default, A))), e.iconRight && _.push(b(ct, { class: "q-chip__icon q-chip__icon--right", name: e.iconRight })), e.removable === !0 && _.push(b(ct, { class: "q-chip__icon q-chip__icon--remove cursor-pointer", name: a.value, ...d.value.remove, onClick: v, onKeyup: v })), _ } return () => { if (e.modelValue === !1) return; const _ = { class: u.value, style: i.value }; return c.value === !0 && Object.assign(_, d.value.chip, { onClick: h, onKeyup: f }), Xd("div", _, x(), "ripple", e.ripple !== !1 && e.disable !== !0, () => [[Dl, e.ripple]]) } } }), Hy = qe({ name: "QItem", props: { ...Ut, ...Nl, tag: { type: String, default: "div" }, active: { type: Boolean, default: null }, clickable: Boolean, dense: Boolean, insetLevel: Number, tabindex: [String, Number], focused: Boolean, manualFocus: Boolean }, emits: ["click", "keyup"], setup(e, { slots: t, emit: n }) { const { proxy: { $q: o } } = Ee(), r = Wt(e, o), { hasLink: i, linkAttrs: s, linkClass: l, linkTag: a, navigateOnClick: c } = jl(), u = z(null), d = z(null), f = y(() => e.clickable === !0 || i.value === !0 || e.tag === "label"), h = y(() => e.disable !== !0 && f.value === !0), v = y(() => "q-item q-item-type row no-wrap" + (e.dense === !0 ? " q-item--dense" : "") + (r.value === !0 ? " q-item--dark" : "") + (i.value === !0 && e.active === null ? l.value : e.active === !0 ? ` q-item--active${e.activeClass !== void 0 ? ` ${e.activeClass}` : ""}` : "") + (e.disable === !0 ? " disabled" : "") + (h.value === !0 ? " q-item--clickable q-link cursor-pointer " + (e.manualFocus === !0 ? "q-manual-focusable" : "q-focusable q-hoverable") + (e.focused === !0 ? " q-manual-focusable--focused" : "") : "")), x = y(() => { if (e.insetLevel === void 0) return null; const m = o.lang.rtl === !0 ? "Right" : "Left"; return { ["padding" + m]: 16 + e.insetLevel * 56 + "px" } }); function _(m) { h.value === !0 && (d.value !== null && (m.qKeyEvent !== !0 && document.activeElement === u.value ? d.value.focus() : document.activeElement === d.value && u.value.focus()), c(m)) } function A(m) { if (h.value === !0 && en(m, 13) === !0) { Be(m), m.qKeyEvent = !0; const w = new MouseEvent("click", m); w.qKeyEvent = !0, u.value.dispatchEvent(w) } n("keyup", m) } function g() { const m = Yd(t.default, []); return h.value === !0 && m.unshift(b("div", { class: "q-focus-helper", tabindex: -1, ref: d })), m } return () => { const m = { ref: u, class: v.value, style: x.value, role: "listitem", onClick: _, onKeyup: A }; return h.value === !0 ? (m.tabindex = e.tabindex || "0", Object.assign(m, s.value)) : f.value === !0 && (m["aria-disabled"] = "true"), b(a.value, m, g()) } } }), Ky = qe({ name: "QItemSection", props: { avatar: Boolean, thumbnail: Boolean, side: Boolean, top: Boolean, noWrap: Boolean }, setup(e, { slots: t }) { const n = y(() => `q-item__section column q-item__section--${e.avatar === !0 || e.side === !0 || e.thumbnail === !0 ? "side" : "main"}` + (e.top === !0 ? " q-item__section--top justify-start" : " justify-center") + (e.avatar === !0 ? " q-item__section--avatar" : "") + (e.thumbnail === !0 ? " q-item__section--thumbnail" : "") + (e.noWrap === !0 ? " q-item__section--nowrap" : "")); return () => b("div", { class: n.value }, He(t.default)) } }), Uy = qe({ name: "QItemLabel", props: { overline: Boolean, caption: Boolean, header: Boolean, lines: [Number, String] }, setup(e, { slots: t }) { const n = y(() => parseInt(e.lines, 10)), o = y(() => "q-item__label" + (e.overline === !0 ? " q-item__label--overline text-overline" : "") + (e.caption === !0 ? " q-item__label--caption text-caption" : "") + (e.header === !0 ? " q-item__label--header" : "") + (n.value === 1 ? " ellipsis" : "")), r = y(() => e.lines !== void 0 && n.value > 1 ? { overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": n.value } : null); return () => b("div", { style: r.value, class: o.value }, He(t.default)) } }); function vf() { if (window.getSelection !== void 0) { const e = window.getSelection(); e.empty !== void 0 ? e.empty() : e.removeAllRanges !== void 0 && (e.removeAllRanges(), hi.is.mobile !== !0 && e.addRange(document.createRange())) } else document.selection !== void 0 && document.selection.empty() } const Wy = { target: { default: !0 }, noParentEvent: Boolean, contextMenu: Boolean }; function Qy({ showing: e, avoidEmit: t, configureAnchorEl: n }) { const { props: o, proxy: r, emit: i } = Ee(), s = z(null); let l = null; function a(h) { return s.value === null ? !1 : h === void 0 || h.touches === void 0 || h.touches.length <= 1 } const c = {}; n === void 0 && (Object.assign(c, { hide(h) { r.hide(h) }, toggle(h) { r.toggle(h), h.qAnchorHandled = !0 }, toggleKey(h) { en(h, 13) === !0 && c.toggle(h) }, contextClick(h) { r.hide(h), Ct(h), Ie(() => { r.show(h), h.qAnchorHandled = !0 }) }, prevent: Ct, mobileTouch(h) { if (c.mobileCleanup(h), a(h) !== !0) return; r.hide(h), s.value.classList.add("non-selectable"); const v = h.target; Nn(c, "anchor", [[v, "touchmove", "mobileCleanup", "passive"], [v, "touchend", "mobileCleanup", "passive"], [v, "touchcancel", "mobileCleanup", "passive"], [s.value, "contextmenu", "prevent", "notPassive"]]), l = setTimeout(() => { l = null, r.show(h), h.qAnchorHandled = !0 }, 300) }, mobileCleanup(h) { s.value.classList.remove("non-selectable"), l !== null && (clearTimeout(l), l = null), e.value === !0 && h !== void 0 && vf() } }), n = function (h = o.contextMenu) { if (o.noParentEvent === !0 || s.value === null) return; let v; h === !0 ? r.$q.platform.is.mobile === !0 ? v = [[s.value, "touchstart", "mobileTouch", "passive"]] : v = [[s.value, "mousedown", "hide", "passive"], [s.value, "contextmenu", "contextClick", "notPassive"]] : v = [[s.value, "click", "toggle", "passive"], [s.value, "keyup", "toggleKey", "passive"]], Nn(c, "anchor", v) }); function u() { sr(c, "anchor") } function d(h) { for (s.value = h; s.value.classList.contains("q-anchor--skip");)s.value = s.value.parentNode; n() } function f() { if (o.target === !1 || o.target === "" || r.$el.parentNode === null) s.value = null; else if (o.target === !0) d(r.$el.parentNode); else { let h = o.target; if (typeof o.target == "string") try { h = document.querySelector(o.target) } catch { h = void 0 } h != null ? (s.value = h.$el || h, n()) : (s.value = null, console.error(`Anchor: target "${o.target}" not found`)) } } return de(() => o.contextMenu, h => { s.value !== null && (u(), n(h)) }), de(() => o.target, () => { s.value !== null && u(), f() }), de(() => o.noParentEvent, h => { s.value !== null && (h === !0 ? u() : n()) }), et(() => { f(), t !== !0 && o.modelValue === !0 && s.value === null && i("update:modelValue", !1) }), Re(() => { l !== null && clearTimeout(l), u() }), { anchorEl: s, canShow: a, anchorEvents: c } } function Gy(e, t) { const n = z(null); let o; function r(l, a) { const c = `${a !== void 0 ? "add" : "remove"}EventListener`, u = a !== void 0 ? a : o; l !== window && l[c]("scroll", u, Je.passive), window[c]("scroll", u, Je.passive), o = a } function i() { n.value !== null && (r(n.value), n.value = null) } const s = de(() => e.noParentEvent, () => { n.value !== null && (i(), t()) }); return Re(s), { localScrollTarget: n, unconfigureScrollTarget: i, changeScrollEvent: r } } const pf = { modelValue: { type: Boolean, default: null }, "onUpdate:modelValue": [Function, Array] }, gf = ["beforeShow", "show", "beforeHide", "hide"]; function yf({ showing: e, canShow: t, hideOnRouteChange: n, handleShow: o, handleHide: r, processOnMount: i }) { const s = Ee(), { props: l, emit: a, proxy: c } = s; let u; function d(g) { e.value === !0 ? v(g) : f(g) } function f(g) { if (l.disable === !0 || g !== void 0 && g.qAnchorHandled === !0 || t !== void 0 && t(g) !== !0) return; const m = l["onUpdate:modelValue"] !== void 0; m === !0 && (a("update:modelValue", !0), u = g, Ie(() => { u === g && (u = void 0) })), (l.modelValue === null || m === !1) && h(g) } function h(g) { e.value !== !0 && (e.value = !0, a("beforeShow", g), o !== void 0 ? o(g) : a("show", g)) } function v(g) { if (l.disable === !0) return; const m = l["onUpdate:modelValue"] !== void 0; m === !0 && (a("update:modelValue", !1), u = g, Ie(() => { u === g && (u = void 0) })), (l.modelValue === null || m === !1) && x(g) } function x(g) { e.value !== !1 && (e.value = !1, a("beforeHide", g), r !== void 0 ? r(g) : a("hide", g)) } function _(g) { l.disable === !0 && g === !0 ? l["onUpdate:modelValue"] !== void 0 && a("update:modelValue", !1) : g === !0 !== e.value && (g === !0 ? h : x)(u) } de(() => l.modelValue, _), n !== void 0 && zl(s) === !0 && de(() => c.$route.fullPath, () => { n.value === !0 && e.value === !0 && v() }), i === !0 && et(() => { _(l.modelValue) }); const A = { show: f, hide: v, toggle: d }; return Object.assign(c, A), A } let Zy = 1, Yy = document.body; function Qi(e, t) { const n = document.createElement("div"); if (n.id = t !== void 0 ? `q-portal--${t}--${Zy++}` : e, pi.globalNodes !== void 0) { const o = pi.globalNodes.class; o !== void 0 && (n.className = o) } return Yy.appendChild(n), n } function Wl(e) { e.remove() } const go = []; function Jy(e) { return go.find(t => t.contentEl !== null && t.contentEl.contains(e)) } function bf(e, t) { do { if (e.$options.name === "QMenu") { if (e.hide(t), e.$props.separateClosePopup === !0) return ti(e) } else if (e.__qPortal === !0) { const n = ti(e); return n !== void 0 && n.$options.name === "QPopupProxy" ? (e.hide(t), n) : e } e = ti(e) } while (e != null) } function Xy(e, t, n) { for (; n !== 0 && e !== void 0 && e !== null;) { if (e.__qPortal === !0) { if (n--, e.$options.name === "QMenu") { e = bf(e, t); continue } e.hide(t) } e = ti(e) } } function eb(e) { for (e = e.parent; e != null;) { if (e.type.name === "QGlobalDialog") return !0; if (e.type.name === "QDialog" || e.type.name === "QMenu") return !1; e = e.parent } return !1 } function _f(e, t, n, o) { const r = z(!1), i = z(!1); let s = null; const l = {}, a = o === "dialog" && eb(e); function c(d) { if (d === !0) { Lu(l), i.value = !0; return } i.value = !1, r.value === !1 && (a === !1 && s === null && (s = Qi(!1, o)), r.value = !0, go.push(e.proxy), zy(l)) } function u(d) { if (i.value = !1, d !== !0) return; Lu(l), r.value = !1; const f = go.indexOf(e.proxy); f !== -1 && go.splice(f, 1), s !== null && (Wl(s), s = null) } return Fi(() => { u(!0) }), e.proxy.__qPortal = !0, Ro(e.proxy, "contentEl", () => t.value), { showPortal: c, hidePortal: u, portalIsActive: r, portalIsAccessible: i, renderPortal: () => a === !0 ? n() : r.value === !0 ? [b(hv, { to: s }, n())] : void 0 } } const wf = { transitionShow: { type: String, default: "fade" }, transitionHide: { type: String, default: "fade" }, transitionDuration: { type: [String, Number], default: 300 } }; function Cf(e, t = () => { }, n = () => { }) { return { transitionProps: y(() => { const o = `q-transition--${e.transitionShow || t()}`, r = `q-transition--${e.transitionHide || n()}`; return { appear: !0, enterFromClass: `${o}-enter-from`, enterActiveClass: `${o}-enter-active`, enterToClass: `${o}-enter-to`, leaveFromClass: `${r}-leave-from`, leaveActiveClass: `${r}-leave-active`, leaveToClass: `${r}-leave-to` } }), transitionStyle: y(() => `--q-transition-duration: ${e.transitionDuration}ms`) } } const Wn = []; let Eo; function tb(e) { Eo = e.keyCode === 27 } function nb() { Eo === !0 && (Eo = !1) } function ob(e) { Eo === !0 && (Eo = !1, en(e, 27) === !0 && Wn[Wn.length - 1](e)) } function xf(e) { window[e]("keydown", tb), window[e]("blur", nb), window[e]("keyup", ob), Eo = !1 } function kf(e) { Fe.is.desktop === !0 && (Wn.push(e), Wn.length === 1 && xf("addEventListener")) } function _i(e) { const t = Wn.indexOf(e); t > -1 && (Wn.splice(t, 1), Wn.length === 0 && xf("removeEventListener")) } const Qn = []; function Sf(e) { Qn[Qn.length - 1](e) } function Ef(e) { Fe.is.desktop === !0 && (Qn.push(e), Qn.length === 1 && document.body.addEventListener("focusin", Sf)) } function Zs(e) { const t = Qn.indexOf(e); t > -1 && (Qn.splice(t, 1), Qn.length === 0 && document.body.removeEventListener("focusin", Sf)) } const { notPassiveCapture: wi } = Je, Gn = []; function Ci(e) { const t = e.target; if (t === void 0 || t.nodeType === 8 || t.classList.contains("no-pointer-events") === !0) return; let n = go.length - 1; for (; n >= 0;) { const o = go[n].$; if (o.type.name !== "QDialog") break; if (o.props.seamless !== !0) return; n-- } for (let o = Gn.length - 1; o >= 0; o--) { const r = Gn[o]; if ((r.anchorEl.value === null || r.anchorEl.value.contains(t) === !1) && (t === document.body || r.innerRef.value !== null && r.innerRef.value.contains(t) === !1)) e.qClickOutside = !0, r.onClickOutside(e); else return } } function rb(e) { Gn.push(e), Gn.length === 1 && (document.addEventListener("mousedown", Ci, wi), document.addEventListener("touchstart", Ci, wi)) } function $u(e) { const t = Gn.findIndex(n => n === e); t > -1 && (Gn.splice(t, 1), Gn.length === 0 && (document.removeEventListener("mousedown", Ci, wi), document.removeEventListener("touchstart", Ci, wi))) } let Mu, Bu; function Iu(e) { const t = e.split(" "); return t.length !== 2 ? !1 : ["top", "center", "bottom"].includes(t[0]) !== !0 ? (console.error("Anchor/Self position must start with one of top/center/bottom"), !1) : ["left", "middle", "right", "start", "end"].includes(t[1]) !== !0 ? (console.error("Anchor/Self position must end with one of left/middle/right/start/end"), !1) : !0 } function ib(e) { return e ? !(e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number") : !0 } const Ys = { "start#ltr": "left", "start#rtl": "right", "end#ltr": "right", "end#rtl": "left" };["left", "middle", "right"].forEach(e => { Ys[`${e}#ltr`] = e, Ys[`${e}#rtl`] = e }); function Fu(e, t) { const n = e.split(" "); return { vertical: n[0], horizontal: Ys[`${n[1]}#${t === !0 ? "rtl" : "ltr"}`] } } function sb(e, t) { let { top: n, left: o, right: r, bottom: i, width: s, height: l } = e.getBoundingClientRect(); return t !== void 0 && (n -= t[1], o -= t[0], i += t[1], r += t[0], s += t[0], l += t[1]), { top: n, bottom: i, height: l, left: o, right: r, width: s, middle: o + (r - o) / 2, center: n + (i - n) / 2 } } function lb(e, t, n) { let { top: o, left: r } = e.getBoundingClientRect(); return o += t.top, r += t.left, n !== void 0 && (o += n[1], r += n[0]), { top: o, bottom: o + 1, height: 1, left: r, right: r + 1, width: 1, middle: r, center: o } } function ab(e) { return { top: 0, center: e.offsetHeight / 2, bottom: e.offsetHeight, left: 0, middle: e.offsetWidth / 2, right: e.offsetWidth } } function zu(e, t, n) { return { top: e[n.anchorOrigin.vertical] - t[n.selfOrigin.vertical], left: e[n.anchorOrigin.horizontal] - t[n.selfOrigin.horizontal] } } function ub(e) { if (Fe.is.ios === !0 && window.visualViewport !== void 0) { const l = document.body.style, { offsetLeft: a, offsetTop: c } = window.visualViewport; a !== Mu && (l.setProperty("--q-pe-left", a + "px"), Mu = a), c !== Bu && (l.setProperty("--q-pe-top", c + "px"), Bu = c) } const { scrollLeft: t, scrollTop: n } = e.el, o = e.absoluteOffset === void 0 ? sb(e.anchorEl, e.cover === !0 ? [0, 0] : e.offset) : lb(e.anchorEl, e.absoluteOffset, e.offset); let r = { maxHeight: e.maxHeight, maxWidth: e.maxWidth, visibility: "visible" }; (e.fit === !0 || e.cover === !0) && (r.minWidth = o.width + "px", e.cover === !0 && (r.minHeight = o.height + "px")), Object.assign(e.el.style, r); const i = ab(e.el); let s = zu(o, i, e); if (e.absoluteOffset === void 0 || e.offset === void 0) _s(s, o, i, e.anchorOrigin, e.selfOrigin); else { const { top: l, left: a } = s; _s(s, o, i, e.anchorOrigin, e.selfOrigin); let c = !1; if (s.top !== l) { c = !0; const u = 2 * e.offset[1]; o.center = o.top -= u, o.bottom -= u + 2 } if (s.left !== a) { c = !0; const u = 2 * e.offset[0]; o.middle = o.left -= u, o.right -= u + 2 } c === !0 && (s = zu(o, i, e), _s(s, o, i, e.anchorOrigin, e.selfOrigin)) } r = { top: s.top + "px", left: s.left + "px" }, s.maxHeight !== void 0 && (r.maxHeight = s.maxHeight + "px", o.height > s.maxHeight && (r.minHeight = r.maxHeight)), s.maxWidth !== void 0 && (r.maxWidth = s.maxWidth + "px", o.width > s.maxWidth && (r.minWidth = r.maxWidth)), Object.assign(e.el.style, r), e.el.scrollTop !== n && (e.el.scrollTop = n), e.el.scrollLeft !== t && (e.el.scrollLeft = t) } function _s(e, t, n, o, r) { const i = n.bottom, s = n.right, l = ni(), a = window.innerHeight - l, c = document.body.clientWidth; if (e.top < 0 || e.top + i > a) if (r.vertical === "center") e.top = t[o.vertical] > a / 2 ? Math.max(0, a - i) : 0, e.maxHeight = Math.min(i, a); else if (t[o.vertical] > a / 2) { const u = Math.min(a, o.vertical === "center" ? t.center : o.vertical === r.vertical ? t.bottom : t.top); e.maxHeight = Math.min(i, u), e.top = Math.max(0, u - i) } else e.top = Math.max(0, o.vertical === "center" ? t.center : o.vertical === r.vertical ? t.top : t.bottom), e.maxHeight = Math.min(i, a - e.top); if (e.left < 0 || e.left + s > c) if (e.maxWidth = Math.min(s, c), r.horizontal === "middle") e.left = t[o.horizontal] > c / 2 ? Math.max(0, c - s) : 0; else if (t[o.horizontal] > c / 2) { const u = Math.min(c, o.horizontal === "middle" ? t.middle : o.horizontal === r.horizontal ? t.right : t.left); e.maxWidth = Math.min(s, u), e.left = Math.max(0, u - e.maxWidth) } else e.left = Math.max(0, o.horizontal === "middle" ? t.middle : o.horizontal === r.horizontal ? t.left : t.right), e.maxWidth = Math.min(s, c - e.left) } var cb = qe({ name: "QMenu", inheritAttrs: !1, props: { ...Wy, ...pf, ...Ut, ...wf, persistent: Boolean, autoClose: Boolean, separateClosePopup: Boolean, noRouteDismiss: Boolean, noRefocus: Boolean, noFocus: Boolean, fit: Boolean, cover: Boolean, square: Boolean, anchor: { type: String, validator: Iu }, self: { type: String, validator: Iu }, offset: { type: Array, validator: ib }, scrollTarget: { default: void 0 }, touchPosition: Boolean, maxHeight: { type: String, default: null }, maxWidth: { type: String, default: null } }, emits: [...gf, "click", "escapeKey"], setup(e, { slots: t, emit: n, attrs: o }) { let r = null, i, s, l; const a = Ee(), { proxy: c } = a, { $q: u } = c, d = z(null), f = z(!1), h = y(() => e.persistent !== !0 && e.noRouteDismiss !== !0), v = Wt(e, u), { registerTick: x, removeTick: _ } = cr(), { registerTimeout: A } = yi(), { transitionProps: g, transitionStyle: m } = Cf(e), { localScrollTarget: w, changeScrollEvent: S, unconfigureScrollTarget: k } = Gy(e, ue), { anchorEl: T, canShow: q } = Qy({ showing: f }), { hide: F } = yf({ showing: f, canShow: q, handleShow: ne, handleHide: O, hideOnRouteChange: h, processOnMount: !0 }), { showPortal: B, hidePortal: j, renderPortal: $ } = _f(a, d, X, "menu"), M = { anchorEl: T, innerRef: d, onClickOutside(W) { if (e.persistent !== !0 && f.value === !0) return F(W), (W.type === "touchstart" || W.target.classList.contains("q-dialog__backdrop")) && Be(W), !0 } }, R = y(() => Fu(e.anchor || (e.cover === !0 ? "center middle" : "bottom start"), u.lang.rtl)), ee = y(() => e.cover === !0 ? R.value : Fu(e.self || "top start", u.lang.rtl)), fe = y(() => (e.square === !0 ? " q-menu--square" : "") + (v.value === !0 ? " q-menu--dark q-dark" : "")), D = y(() => e.autoClose === !0 ? { onClick: we } : {}), oe = y(() => f.value === !0 && e.persistent !== !0); de(oe, W => { W === !0 ? (kf(U), rb(M)) : (_i(U), $u(M)) }); function Ce() { Br(() => { let W = d.value; W && W.contains(document.activeElement) !== !0 && (W = W.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || W.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || W.querySelector("[autofocus], [data-autofocus]") || W, W.focus({ preventScroll: !0 })) }) } function ne(W) { if (r = e.noRefocus === !1 ? document.activeElement : null, Ef(N), B(), ue(), i = void 0, W !== void 0 && (e.touchPosition || e.contextMenu)) { const ye = mi(W); if (ye.left !== void 0) { const { top: ge, left: p } = T.value.getBoundingClientRect(); i = { left: ye.left - p, top: ye.top - ge } } } s === void 0 && (s = de(() => u.screen.width + "|" + u.screen.height + "|" + e.self + "|" + e.anchor + "|" + u.lang.rtl, L)), e.noFocus !== !0 && document.activeElement.blur(), x(() => { L(), e.noFocus !== !0 && Ce() }), A(() => { u.platform.is.ios === !0 && (l = e.autoClose, d.value.click()), L(), B(!0), n("show", W) }, e.transitionDuration) } function O(W) { _(), j(), J(!0), r !== null && (W === void 0 || W.qClickOutside !== !0) && (((W && W.type.indexOf("key") === 0 ? r.closest('[tabindex]:not([tabindex^="-"])') : void 0) || r).focus(), r = null), A(() => { j(!0), n("hide", W) }, e.transitionDuration) } function J(W) { i = void 0, s !== void 0 && (s(), s = void 0), (W === !0 || f.value === !0) && (Zs(N), k(), $u(M), _i(U)), W !== !0 && (r = null) } function ue() { (T.value !== null || e.scrollTarget !== void 0) && (w.value = af(T.value, e.scrollTarget), S(w.value, L)) } function we(W) { l !== !0 ? (bf(c, W), n("click", W)) : l = !1 } function N(W) { oe.value === !0 && e.noFocus !== !0 && sf(d.value, W.target) !== !0 && Ce() } function U(W) { n("escapeKey"), F(W) } function L() { const W = d.value; W === null || T.value === null || ub({ el: W, offset: e.offset, anchorEl: T.value, anchorOrigin: R.value, selfOrigin: ee.value, absoluteOffset: i, fit: e.fit, cover: e.cover, maxHeight: e.maxHeight, maxWidth: e.maxWidth }) } function X() { return b(fn, g.value, () => f.value === !0 ? b("div", { role: "menu", ...o, ref: d, tabindex: -1, class: ["q-menu q-position-engine scroll" + fe.value, o.class], style: [o.style, m.value], ...D.value }, He(t.default)) : null) } return Re(J), Object.assign(c, { focus: Ce, updatePosition: L }), $ } }); function db(e, t, n) { let o; function r() { o !== void 0 && (wr.remove(o), o = void 0) } return Re(() => { e.value === !0 && r() }), { removeFromHistory: r, addToHistory() { o = { condition: () => n.value === !0, handler: t }, wr.add(o) } } } let Ko = 0, ws, Cs, Xo, xs = !1, Vu, Nu, ju, Ln = null; function fb(e) { hb(e) && Be(e) } function hb(e) { if (e.target === document.body || e.target.classList.contains("q-layout__backdrop")) return !0; const t = fp(e), n = e.shiftKey && !e.deltaX, o = !n && Math.abs(e.deltaX) <= Math.abs(e.deltaY), r = n || o ? e.deltaY : e.deltaX; for (let i = 0; i < t.length; i++) { const s = t[i]; if (vy(s, o)) return o ? r < 0 && s.scrollTop === 0 ? !0 : r > 0 && s.scrollTop + s.clientHeight === s.scrollHeight : r < 0 && s.scrollLeft === 0 ? !0 : r > 0 && s.scrollLeft + s.clientWidth === s.scrollWidth } return !0 } function Du(e) { e.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop) } function Gr(e) { xs !== !0 && (xs = !0, requestAnimationFrame(() => { xs = !1; const { height: t } = e.target, { clientHeight: n, scrollTop: o } = document.scrollingElement; (Xo === void 0 || t !== window.innerHeight) && (Xo = n - t, document.scrollingElement.scrollTop = o), o > Xo && (document.scrollingElement.scrollTop -= Math.ceil((o - Xo) / 8)) })) } function Hu(e) { const t = document.body, n = window.visualViewport !== void 0; if (e === "add") { const { overflowY: o, overflowX: r } = window.getComputedStyle(t); ws = cf(window), Cs = uf(window), Vu = t.style.left, Nu = t.style.top, ju = window.location.href, t.style.left = `-${ws}px`, t.style.top = `-${Cs}px`, r !== "hidden" && (r === "scroll" || t.scrollWidth > window.innerWidth) && t.classList.add("q-body--force-scrollbar-x"), o !== "hidden" && (o === "scroll" || t.scrollHeight > window.innerHeight) && t.classList.add("q-body--force-scrollbar-y"), t.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = !0, Fe.is.ios === !0 && (n === !0 ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", Gr, Je.passiveCapture), window.visualViewport.addEventListener("scroll", Gr, Je.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", Du, Je.passiveCapture)) } Fe.is.desktop === !0 && Fe.is.mac === !0 && window[`${e}EventListener`]("wheel", fb, Je.notPassive), e === "remove" && (Fe.is.ios === !0 && (n === !0 ? (window.visualViewport.removeEventListener("resize", Gr, Je.passiveCapture), window.visualViewport.removeEventListener("scroll", Gr, Je.passiveCapture)) : window.removeEventListener("scroll", Du, Je.passiveCapture)), t.classList.remove("q-body--prevent-scroll"), t.classList.remove("q-body--force-scrollbar-x"), t.classList.remove("q-body--force-scrollbar-y"), document.qScrollPrevented = !1, t.style.left = Vu, t.style.top = Nu, window.location.href === ju && window.scrollTo(ws, Cs), Xo = void 0) } function Js(e) { let t = "add"; if (e === !0) { if (Ko++, Ln !== null) { clearTimeout(Ln), Ln = null; return } if (Ko > 1) return } else { if (Ko === 0 || (Ko--, Ko > 0)) return; if (t = "remove", Fe.is.ios === !0 && Fe.is.nativeMobile === !0) { Ln !== null && clearTimeout(Ln), Ln = setTimeout(() => { Hu(t), Ln = null }, 100); return } } Hu(t) } function mb() { let e; return { preventBodyScroll(t) { t !== e && (e !== void 0 || t === !0) && (e = t, Js(t)) } } } let Zr = 0; const vb = { standard: "fixed-full flex-center", top: "fixed-top justify-center", bottom: "fixed-bottom justify-center", right: "fixed-right items-center", left: "fixed-left items-center" }, Ku = { standard: ["scale", "scale"], top: ["slide-down", "slide-up"], bottom: ["slide-up", "slide-down"], right: ["slide-left", "slide-right"], left: ["slide-right", "slide-left"] }; var qo = qe({ name: "QDialog", inheritAttrs: !1, props: { ...pf, ...wf, transitionShow: String, transitionHide: String, persistent: Boolean, autoClose: Boolean, allowFocusOutside: Boolean, noEscDismiss: Boolean, noBackdropDismiss: Boolean, noRouteDismiss: Boolean, noRefocus: Boolean, noFocus: Boolean, noShake: Boolean, seamless: Boolean, maximized: Boolean, fullWidth: Boolean, fullHeight: Boolean, square: Boolean, position: { type: String, default: "standard", validator: e => e === "standard" || ["top", "bottom", "left", "right"].includes(e) } }, emits: [...gf, "shake", "click", "escapeKey"], setup(e, { slots: t, emit: n, attrs: o }) { const r = Ee(), { proxy: { $q: i } } = r, s = z(null), l = z(!1), a = z(!1); let c = null, u = null, d, f; const h = y(() => e.persistent !== !0 && e.noRouteDismiss !== !0 && e.seamless !== !0), { preventBodyScroll: v } = mb(), { registerTimeout: x } = yi(), { registerTick: _, removeTick: A } = cr(), { transitionProps: g, transitionStyle: m } = Cf(e, () => Ku[e.position][0], () => Ku[e.position][1]), { showPortal: w, hidePortal: S, portalIsAccessible: k, renderPortal: T } = _f(r, s, U, "dialog"), { hide: q } = yf({ showing: l, hideOnRouteChange: h, handleShow: ee, handleHide: fe, processOnMount: !0 }), { addToHistory: F, removeFromHistory: B } = db(l, q, h), j = y(() => `q-dialog__inner flex no-pointer-events q-dialog__inner--${e.maximized === !0 ? "maximized" : "minimized"} q-dialog__inner--${e.position} ${vb[e.position]}` + (a.value === !0 ? " q-dialog__inner--animating" : "") + (e.fullWidth === !0 ? " q-dialog__inner--fullwidth" : "") + (e.fullHeight === !0 ? " q-dialog__inner--fullheight" : "") + (e.square === !0 ? " q-dialog__inner--square" : "")), $ = y(() => l.value === !0 && e.seamless !== !0), M = y(() => e.autoClose === !0 ? { onClick: J } : {}), R = y(() => [`q-dialog fullscreen no-pointer-events q-dialog--${$.value === !0 ? "modal" : "seamless"}`, o.class]); de(() => e.maximized, L => { l.value === !0 && O(L) }), de($, L => { v(L), L === !0 ? (Ef(we), kf(Ce)) : (Zs(we), _i(Ce)) }); function ee(L) { F(), u = e.noRefocus === !1 && document.activeElement !== null ? document.activeElement : null, O(e.maximized), w(), a.value = !0, e.noFocus !== !0 ? (document.activeElement !== null && document.activeElement.blur(), _(D)) : A(), x(() => { if (r.proxy.$q.platform.is.ios === !0) { if (e.seamless !== !0 && document.activeElement) { const { top: X, bottom: W } = document.activeElement.getBoundingClientRect(), { innerHeight: ye } = window, ge = window.visualViewport !== void 0 ? window.visualViewport.height : ye; X > 0 && W > ge / 2 && (document.scrollingElement.scrollTop = Math.min(document.scrollingElement.scrollHeight - ge, W >= ye ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + W - ge / 2))), document.activeElement.scrollIntoView() } f = !0, s.value.click(), f = !1 } w(!0), a.value = !1, n("show", L) }, e.transitionDuration) } function fe(L) { A(), B(), ne(!0), a.value = !0, S(), u !== null && (((L && L.type.indexOf("key") === 0 ? u.closest('[tabindex]:not([tabindex^="-"])') : void 0) || u).focus(), u = null), x(() => { S(!0), a.value = !1, n("hide", L) }, e.transitionDuration) } function D(L) { Br(() => { let X = s.value; X === null || X.contains(document.activeElement) === !0 || (X = (L !== "" ? X.querySelector(L) : null) || X.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || X.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || X.querySelector("[autofocus], [data-autofocus]") || X, X.focus({ preventScroll: !0 })) }) } function oe(L) { L && typeof L.focus == "function" ? L.focus({ preventScroll: !0 }) : D(), n("shake"); const X = s.value; X !== null && (X.classList.remove("q-animate--scale"), X.classList.add("q-animate--scale"), c !== null && clearTimeout(c), c = setTimeout(() => { c = null, s.value !== null && (X.classList.remove("q-animate--scale"), D()) }, 170)) } function Ce() { e.seamless !== !0 && (e.persistent === !0 || e.noEscDismiss === !0 ? e.maximized !== !0 && e.noShake !== !0 && oe() : (n("escapeKey"), q())) } function ne(L) { c !== null && (clearTimeout(c), c = null), (L === !0 || l.value === !0) && (O(!1), e.seamless !== !0 && (v(!1), Zs(we), _i(Ce))), L !== !0 && (u = null) } function O(L) { L === !0 ? d !== !0 && (Zr < 1 && document.body.classList.add("q-body--dialog"), Zr++, d = !0) : d === !0 && (Zr < 2 && document.body.classList.remove("q-body--dialog"), Zr--, d = !1) } function J(L) { f !== !0 && (q(L), n("click", L)) } function ue(L) { e.persistent !== !0 && e.noBackdropDismiss !== !0 ? q(L) : e.noShake !== !0 && oe(L.relatedTarget) } function we(L) { e.allowFocusOutside !== !0 && k.value === !0 && sf(s.value, L.target) !== !0 && D('[tabindex]:not([tabindex="-1"])') } Object.assign(r.proxy, { focus: D, shake: oe, __updateRefocusTarget(L) { u = L || null } }), Re(ne); const N = i.platform.is.ios === !0 || i.platform.is.safari ? "onClick" : "onFocusin"; function U() { return b("div", { role: "dialog", "aria-modal": $.value === !0 ? "true" : "false", ...o, class: R.value }, [b(fn, { name: "q-transition--fade", appear: !0 }, () => $.value === !0 ? b("div", { class: "q-dialog__backdrop fixed-full", style: m.value, "aria-hidden": "true", tabindex: -1, [N]: ue }) : null), b(fn, g.value, () => l.value === !0 ? b("div", { ref: s, class: j.value, style: m.value, tabindex: -1, ...M.value }, He(t.default)) : null)]) } return T } }); const Vt = 1e3, pb = ["start", "center", "end", "start-force", "center-force", "end-force"], qf = Array.prototype.filter, gb = window.getComputedStyle(document.body).overflowAnchor === void 0 ? hn : function (e, t) { e !== null && (e._qOverflowAnimationFrame !== void 0 && cancelAnimationFrame(e._qOverflowAnimationFrame), e._qOverflowAnimationFrame = requestAnimationFrame(() => { if (e === null) return; e._qOverflowAnimationFrame = void 0; const n = e.children || []; qf.call(n, r => r.dataset && r.dataset.qVsAnchor !== void 0).forEach(r => { delete r.dataset.qVsAnchor }); const o = n[t]; o && o.dataset && (o.dataset.qVsAnchor = "") })) }; function yo(e, t) { return e + t } function ks(e, t, n, o, r, i, s, l) { const a = e === window ? document.scrollingElement || document.documentElement : e, c = r === !0 ? "offsetWidth" : "offsetHeight", u = { scrollStart: 0, scrollViewSize: -s - l, scrollMaxSize: 0, offsetStart: -s, offsetEnd: -l }; if (r === !0 ? (e === window ? (u.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, u.scrollViewSize += document.documentElement.clientWidth) : (u.scrollStart = a.scrollLeft, u.scrollViewSize += a.clientWidth), u.scrollMaxSize = a.scrollWidth, i === !0 && (u.scrollStart = (kr === !0 ? u.scrollMaxSize - u.scrollViewSize : 0) - u.scrollStart)) : (e === window ? (u.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0, u.scrollViewSize += document.documentElement.clientHeight) : (u.scrollStart = a.scrollTop, u.scrollViewSize += a.clientHeight), u.scrollMaxSize = a.scrollHeight), n !== null) for (let d = n.previousElementSibling; d !== null; d = d.previousElementSibling)d.classList.contains("q-virtual-scroll--skip") === !1 && (u.offsetStart += d[c]); if (o !== null) for (let d = o.nextElementSibling; d !== null; d = d.nextElementSibling)d.classList.contains("q-virtual-scroll--skip") === !1 && (u.offsetEnd += d[c]); if (t !== e) { const d = a.getBoundingClientRect(), f = t.getBoundingClientRect(); r === !0 ? (u.offsetStart += f.left - d.left, u.offsetEnd -= f.width) : (u.offsetStart += f.top - d.top, u.offsetEnd -= f.height), e !== window && (u.offsetStart += u.scrollStart), u.offsetEnd += u.scrollMaxSize - u.offsetStart } return u } function Uu(e, t, n, o) { t === "end" && (t = (e === window ? document.body : e)[n === !0 ? "scrollWidth" : "scrollHeight"]), e === window ? n === !0 ? (o === !0 && (t = (kr === !0 ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - t), window.scrollTo(t, window.pageYOffset || window.scrollY || document.body.scrollTop || 0)) : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, t) : n === !0 ? (o === !0 && (t = (kr === !0 ? e.scrollWidth - e.offsetWidth : 0) - t), e.scrollLeft = t) : e.scrollTop = t } function Uo(e, t, n, o) { if (n >= o) return 0; const r = t.length, i = Math.floor(n / Vt), s = Math.floor((o - 1) / Vt) + 1; let l = e.slice(i, s).reduce(yo, 0); return n % Vt !== 0 && (l -= t.slice(i * Vt, n).reduce(yo, 0)), o % Vt !== 0 && o !== r && (l -= t.slice(o, s * Vt).reduce(yo, 0)), l } const yb = { virtualScrollSliceSize: { type: [Number, String], default: null }, virtualScrollSliceRatioBefore: { type: [Number, String], default: 1 }, virtualScrollSliceRatioAfter: { type: [Number, String], default: 1 }, virtualScrollItemSize: { type: [Number, String], default: 24 }, virtualScrollStickySizeStart: { type: [Number, String], default: 0 }, virtualScrollStickySizeEnd: { type: [Number, String], default: 0 }, tableColspan: [Number, String] }, bb = { virtualScrollHorizontal: Boolean, onVirtualScroll: Function, ...yb }; function _b({ virtualScrollLength: e, getVirtualScrollTarget: t, getVirtualScrollEl: n, virtualScrollItemSizeComputed: o }) { const r = Ee(), { props: i, emit: s, proxy: l } = r, { $q: a } = l; let c, u, d, f = [], h; const v = z(0), x = z(0), _ = z({}), A = z(null), g = z(null), m = z(null), w = z({ from: 0, to: 0 }), S = y(() => i.tableColspan !== void 0 ? i.tableColspan : 100); o === void 0 && (o = y(() => i.virtualScrollItemSize)); const k = y(() => o.value + ";" + i.virtualScrollHorizontal), T = y(() => k.value + ";" + i.virtualScrollSliceRatioBefore + ";" + i.virtualScrollSliceRatioAfter); de(T, () => { fe() }), de(k, q); function q() { ee(u, !0) } function F(O) { ee(O === void 0 ? u : O) } function B(O, J) { const ue = t(); if (ue == null || ue.nodeType === 8) return; const we = ks(ue, n(), A.value, g.value, i.virtualScrollHorizontal, a.lang.rtl, i.virtualScrollStickySizeStart, i.virtualScrollStickySizeEnd); d !== we.scrollViewSize && fe(we.scrollViewSize), $(ue, we, Math.min(e.value - 1, Math.max(0, parseInt(O, 10) || 0)), 0, pb.indexOf(J) > -1 ? J : u > -1 && O > u ? "end" : "start") } function j() { const O = t(); if (O == null || O.nodeType === 8) return; const J = ks(O, n(), A.value, g.value, i.virtualScrollHorizontal, a.lang.rtl, i.virtualScrollStickySizeStart, i.virtualScrollStickySizeEnd), ue = e.value - 1, we = J.scrollMaxSize - J.offsetStart - J.offsetEnd - x.value; if (c === J.scrollStart) return; if (J.scrollMaxSize <= 0) { $(O, J, 0, 0); return } d !== J.scrollViewSize && fe(J.scrollViewSize), M(w.value.from); const N = Math.floor(J.scrollMaxSize - Math.max(J.scrollViewSize, J.offsetEnd) - Math.min(h[ue], J.scrollViewSize / 2)); if (N > 0 && Math.ceil(J.scrollStart) >= N) { $(O, J, ue, J.scrollMaxSize - J.offsetEnd - f.reduce(yo, 0)); return } let U = 0, L = J.scrollStart - J.offsetStart, X = L; if (L <= we && L + J.scrollViewSize >= v.value) L -= v.value, U = w.value.from, X = L; else for (let W = 0; L >= f[W] && U < ue; W++)L -= f[W], U += Vt; for (; L > 0 && U < ue;)L -= h[U], L > -J.scrollViewSize ? (U++, X = L) : X = h[U] + L; $(O, J, U, X) } function $(O, J, ue, we, N) { const U = typeof N == "string" && N.indexOf("-force") > -1, L = U === !0 ? N.replace("-force", "") : N, X = L !== void 0 ? L : "start"; let W = Math.max(0, ue - _.value[X]), ye = W + _.value.total; ye > e.value && (ye = e.value, W = Math.max(0, ye - _.value.total)), c = J.scrollStart; const ge = W !== w.value.from || ye !== w.value.to; if (ge === !1 && L === void 0) { oe(ue); return } const { activeElement: p } = document, C = m.value; ge === !0 && C !== null && C !== p && C.contains(p) === !0 && (C.addEventListener("focusout", R), setTimeout(() => { C !== null && C.removeEventListener("focusout", R) })), gb(C, ue - W); const I = L !== void 0 ? h.slice(W, ue).reduce(yo, 0) : 0; if (ge === !0) { const H = ye >= w.value.from && W <= w.value.to ? w.value.to : ye; w.value = { from: W, to: H }, v.value = Uo(f, h, 0, W), x.value = Uo(f, h, ye, e.value), requestAnimationFrame(() => { w.value.to !== ye && c === J.scrollStart && (w.value = { from: w.value.from, to: ye }, x.value = Uo(f, h, ye, e.value)) }) } requestAnimationFrame(() => { if (c !== J.scrollStart) return; ge === !0 && M(W); const H = h.slice(W, ue).reduce(yo, 0), G = H + J.offsetStart + v.value, re = G + h[ue]; let se = G + we; if (L !== void 0) { const te = H - I, Y = J.scrollStart + te; se = U !== !0 && Y < G && re < Y + J.scrollViewSize ? Y : L === "end" ? re - J.scrollViewSize : G - (L === "start" ? 0 : Math.round((J.scrollViewSize - h[ue]) / 2)) } c = se, Uu(O, se, i.virtualScrollHorizontal, a.lang.rtl), oe(ue) }) } function M(O) { const J = m.value; if (J) { const ue = qf.call(J.children, W => W.classList && W.classList.contains("q-virtual-scroll--skip") === !1), we = ue.length, N = i.virtualScrollHorizontal === !0 ? W => W.getBoundingClientRect().width : W => W.offsetHeight; let U = O, L, X; for (let W = 0; W < we;) { for (L = N(ue[W]), W++; W < we && ue[W].classList.contains("q-virtual-scroll--with-prev") === !0;)L += N(ue[W]), W++; X = L - h[U], X !== 0 && (h[U] += X, f[Math.floor(U / Vt)] += X), U++ } } } function R() { m.value !== null && m.value !== void 0 && m.value.focus() } function ee(O, J) { const ue = 1 * o.value; (J === !0 || Array.isArray(h) === !1) && (h = []); const we = h.length; h.length = e.value; for (let U = e.value - 1; U >= we; U--)h[U] = ue; const N = Math.floor((e.value - 1) / Vt); f = []; for (let U = 0; U <= N; U++) { let L = 0; const X = Math.min((U + 1) * Vt, e.value); for (let W = U * Vt; W < X; W++)L += h[W]; f.push(L) } u = -1, c = void 0, v.value = Uo(f, h, 0, w.value.from), x.value = Uo(f, h, w.value.to, e.value), O >= 0 ? (M(w.value.from), Ie(() => { B(O) })) : Ce() } function fe(O) { if (O === void 0 && typeof window != "undefined") { const L = t(); L != null && L.nodeType !== 8 && (O = ks(L, n(), A.value, g.value, i.virtualScrollHorizontal, a.lang.rtl, i.virtualScrollStickySizeStart, i.virtualScrollStickySizeEnd).scrollViewSize) } d = O; const J = parseFloat(i.virtualScrollSliceRatioBefore) || 0, ue = parseFloat(i.virtualScrollSliceRatioAfter) || 0, we = 1 + J + ue, N = O === void 0 || O <= 0 ? 1 : Math.ceil(O / o.value), U = Math.max(1, N, Math.ceil((i.virtualScrollSliceSize > 0 ? i.virtualScrollSliceSize : 10) / we)); _.value = { total: Math.ceil(U * we), start: Math.ceil(U * J), center: Math.ceil(U * (.5 + J)), end: Math.ceil(U * (1 + J)), view: N } } function D(O, J) { const ue = i.virtualScrollHorizontal === !0 ? "width" : "height", we = { ["--q-virtual-scroll-item-" + ue]: o.value + "px" }; return [O === "tbody" ? b(O, { class: "q-virtual-scroll__padding", key: "before", ref: A }, [b("tr", [b("td", { style: { [ue]: `${v.value}px`, ...we }, colspan: S.value })])]) : b(O, { class: "q-virtual-scroll__padding", key: "before", ref: A, style: { [ue]: `${v.value}px`, ...we } }), b(O, { class: "q-virtual-scroll__content", key: "content", ref: m, tabindex: -1 }, J.flat()), O === "tbody" ? b(O, { class: "q-virtual-scroll__padding", key: "after", ref: g }, [b("tr", [b("td", { style: { [ue]: `${x.value}px`, ...we }, colspan: S.value })])]) : b(O, { class: "q-virtual-scroll__padding", key: "after", ref: g, style: { [ue]: `${x.value}px`, ...we } })] } function oe(O) { u !== O && (i.onVirtualScroll !== void 0 && s("virtualScroll", { index: O, from: w.value.from, to: w.value.to - 1, direction: O < u ? "decrease" : "increase", ref: l }), u = O) } fe(); const Ce = $l(j, a.platform.is.ios === !0 ? 120 : 35); ql(() => { fe() }); let ne = !1; return Yn(() => { ne = !0 }), Rr(() => { if (ne !== !0) return; const O = t(); c !== void 0 && O !== void 0 && O !== null && O.nodeType !== 8 ? Uu(O, c, i.virtualScrollHorizontal, a.lang.rtl) : B(u) }), Re(() => { Ce.cancel() }), Object.assign(l, { scrollTo: B, reset: q, refresh: F }), { virtualScrollSliceRange: w, virtualScrollSliceSizeComputed: _, setVirtualScrollSize: fe, onVirtualScrollEvt: Ce, localResetVirtualScroll: ee, padVirtualScroll: D, scrollTo: B, reset: q, refresh: F } } const Gi = { name: String }; function Tf(e = {}) { return (t, n, o) => { t[n](b("input", { class: "hidden" + (o || ""), ...e.value })) } } function Pf(e) { return y(() => e.name || e.for) } const wb = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/, Cb = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u, xb = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/, kb = /[a-z0-9_ -]$/i; function Af(e) { return function (n) { if (n.type === "compositionend" || n.type === "change") { if (n.target.qComposing !== !0) return; n.target.qComposing = !1, e(n) } else n.type === "compositionupdate" && n.target.qComposing !== !0 && typeof n.data == "string" && (Fe.is.firefox === !0 ? kb.test(n.data) === !1 : wb.test(n.data) === !0 || Cb.test(n.data) === !0 || xb.test(n.data) === !0) === !0 && (n.target.qComposing = !0) } } function Wu(e, t, n) { if (n <= t) return t; const o = n - t + 1; let r = t + (e - t) % o; return r < t && (r = o + r), r === 0 ? 0 : r } const Qu = e => ["add", "add-unique", "toggle"].includes(e), Sb = ".*+?^${}()|[]\\", Eb = Object.keys(Wi); var qb = qe({ name: "QSelect", inheritAttrs: !1, props: { ...bb, ...Gi, ...Wi, modelValue: { required: !0 }, multiple: Boolean, displayValue: [String, Number], displayValueHtml: Boolean, dropdownIcon: String, options: { type: Array, default: () => [] }, optionValue: [Function, String], optionLabel: [Function, String], optionDisable: [Function, String], hideSelected: Boolean, hideDropdownIcon: Boolean, fillInput: Boolean, maxValues: [Number, String], optionsDense: Boolean, optionsDark: { type: Boolean, default: null }, optionsSelectedClass: String, optionsHtml: Boolean, optionsCover: Boolean, menuShrink: Boolean, menuAnchor: String, menuSelf: String, menuOffset: Array, popupContentClass: String, popupContentStyle: [String, Array, Object], useInput: Boolean, useChips: Boolean, newValueMode: { type: String, validator: Qu }, mapOptions: Boolean, emitValue: Boolean, inputDebounce: { type: [Number, String], default: 500 }, inputClass: [Array, String, Object], inputStyle: [Array, String, Object], tabindex: { type: [String, Number], default: 0 }, autocomplete: String, transitionShow: String, transitionHide: String, transitionDuration: [String, Number], behavior: { type: String, validator: e => ["default", "menu", "dialog"].includes(e), default: "default" }, virtualScrollItemSize: { type: [Number, String], default: void 0 }, onNewValue: Function, onFilter: Function }, emits: [...Hl, "add", "remove", "inputValue", "newValue", "keyup", "keypress", "keydown", "filterAbort"], setup(e, { slots: t, emit: n }) { const { proxy: o } = Ee(), { $q: r } = o, i = z(!1), s = z(!1), l = z(-1), a = z(""), c = z(!1), u = z(!1); let d = null, f, h, v, x = null, _, A, g, m; const w = z(null), S = z(null), k = z(null), T = z(null), q = z(null), F = Pf(e), B = Af(sa), j = y(() => Array.isArray(e.options) ? e.options.length : 0), $ = y(() => e.virtualScrollItemSize === void 0 ? e.optionsDense === !0 ? 24 : 48 : e.virtualScrollItemSize), { virtualScrollSliceRange: M, virtualScrollSliceSizeComputed: R, localResetVirtualScroll: ee, padVirtualScroll: fe, onVirtualScrollEvt: D, scrollTo: oe, setVirtualScrollSize: Ce } = _b({ virtualScrollLength: j, getVirtualScrollTarget: ph, getVirtualScrollEl: ra, virtualScrollItemSizeComputed: $ }), ne = Kl(), O = y(() => { const E = e.mapOptions === !0 && e.multiple !== !0, ve = e.modelValue !== void 0 && (e.modelValue !== null || E === !0) ? e.multiple === !0 && Array.isArray(e.modelValue) ? e.modelValue : [e.modelValue] : []; if (e.mapOptions === !0 && Array.isArray(e.options) === !0) { const ce = e.mapOptions === !0 && f !== void 0 ? f : [], xe = ve.map(Ve => Jn(Ve, ce)); return e.modelValue === null && E === !0 ? xe.filter(Ve => Ve !== null) : xe } return ve }), J = y(() => { const E = {}; return Eb.forEach(ve => { const ce = e[ve]; ce !== void 0 && (E[ve] = ce) }), E }), ue = y(() => e.optionsDark === null ? ne.isDark.value : e.optionsDark), we = y(() => Er(O.value)), N = y(() => { let E = "q-field__input q-placeholder col"; return e.hideSelected === !0 || O.value.length === 0 ? [E, e.inputClass] : (E += " q-field__input--padding", e.inputClass === void 0 ? E : [E, e.inputClass]) }), U = y(() => (e.virtualScrollHorizontal === !0 ? "q-virtual-scroll--horizontal" : "") + (e.popupContentClass ? " " + e.popupContentClass : "")), L = y(() => j.value === 0), X = y(() => O.value.map(E => P.value(E)).join(", ")), W = y(() => e.displayValue !== void 0 ? e.displayValue : X.value), ye = y(() => e.optionsHtml === !0 ? () => !0 : E => E != null && E.html === !0), ge = y(() => e.displayValueHtml === !0 || e.displayValue === void 0 && (e.optionsHtml === !0 || O.value.some(ye.value))), p = y(() => ne.focused.value === !0 ? e.tabindex : -1), C = y(() => { const E = { tabindex: e.tabindex, role: "combobox", "aria-label": e.label, "aria-readonly": e.readonly === !0 ? "true" : "false", "aria-autocomplete": e.useInput === !0 ? "list" : "none", "aria-expanded": i.value === !0 ? "true" : "false", "aria-controls": `${ne.targetUid.value}_lb` }; return l.value >= 0 && (E["aria-activedescendant"] = `${ne.targetUid.value}_${l.value}`), E }), I = y(() => ({ id: `${ne.targetUid.value}_lb`, role: "listbox", "aria-multiselectable": e.multiple === !0 ? "true" : "false" })), H = y(() => O.value.map((E, ve) => ({ index: ve, opt: E, html: ye.value(E), selected: !0, removeAtIndex: pe, toggleOption: Te, tabindex: p.value }))), G = y(() => { if (j.value === 0) return []; const { from: E, to: ve } = M.value; return e.options.slice(E, ve).map((ce, xe) => { const Ve = Q.value(ce) === !0, $e = E + xe, Ge = { clickable: !0, active: !1, activeClass: te.value, manualFocus: !0, focused: !1, disable: Ve, tabindex: -1, dense: e.optionsDense, dark: ue.value, role: "option", id: `${ne.targetUid.value}_${$e}`, onClick: () => { Te(ce) } }; return Ve !== !0 && (mt(ce) === !0 && (Ge.active = !0), l.value === $e && (Ge.focused = !0), Ge["aria-selected"] = Ge.active === !0 ? "true" : "false", r.platform.is.desktop === !0 && (Ge.onMousemove = () => { i.value === !0 && Ke($e) })), { index: $e, opt: ce, html: ye.value(ce), label: P.value(ce), selected: Ge.active, focused: Ge.focused, toggleOption: Te, setOptionIndex: Ke, itemProps: Ge } }) }), re = y(() => e.dropdownIcon !== void 0 ? e.dropdownIcon : r.iconSet.arrow.dropdown), se = y(() => e.optionsCover === !1 && e.outlined !== !0 && e.standout !== !0 && e.borderless !== !0 && e.rounded !== !0), te = y(() => e.optionsSelectedClass !== void 0 ? e.optionsSelectedClass : e.color !== void 0 ? `text-${e.color}` : ""), Y = y(() => bt(e.optionValue, "value")), P = y(() => bt(e.optionLabel, "label")), Q = y(() => bt(e.optionDisable, "disable")), Z = y(() => O.value.map(E => Y.value(E))), le = y(() => { const E = { onInput: sa, onChange: B, onKeydown: oa, onKeyup: zo, onKeypress: na, onFocus: dt, onClick(ve) { h === !0 && Gt(ve) } }; return E.onCompositionstart = E.onCompositionupdate = E.onCompositionend = B, E }); de(O, E => { f = E, e.useInput === !0 && e.fillInput === !0 && e.multiple !== !0 && ne.innerLoading.value !== !0 && (s.value !== !0 && i.value !== !0 || we.value !== !0) && (v !== !0 && no(), (s.value === !0 || i.value === !0) && Xn("")) }, { immediate: !0 }), de(() => e.fillInput, no), de(i, Xi), de(j, Th); function he(E) { return e.emitValue === !0 ? Y.value(E) : E } function me(E) { if (E > -1 && E < O.value.length) if (e.multiple === !0) { const ve = e.modelValue.slice(); n("remove", { index: E, value: ve.splice(E, 1)[0] }), n("update:modelValue", ve) } else n("update:modelValue", null) } function pe(E) { me(E), ne.focus() } function be(E, ve) { const ce = he(E); if (e.multiple !== !0) { e.fillInput === !0 && Vo(P.value(E), !0, !0), n("update:modelValue", ce); return } if (O.value.length === 0) { n("add", { index: 0, value: ce }), n("update:modelValue", e.multiple === !0 ? [ce] : ce); return } if (ve === !0 && mt(E) === !0 || e.maxValues !== void 0 && e.modelValue.length >= e.maxValues) return; const xe = e.modelValue.slice(); n("add", { index: xe.length, value: ce }), xe.push(ce), n("update:modelValue", xe) } function Te(E, ve) { if (ne.editable.value !== !0 || E === void 0 || Q.value(E) === !0) return; const ce = Y.value(E); if (e.multiple !== !0) { ve !== !0 && (Vo(e.fillInput === !0 ? P.value(E) : "", !0, !0), Pn()), S.value !== null && S.value.focus(), (O.value.length === 0 || un(Y.value(O.value[0]), ce) !== !0) && n("update:modelValue", e.emitValue === !0 ? ce : E); return } if ((h !== !0 || c.value === !0) && ne.focus(), dt(), O.value.length === 0) { const $e = e.emitValue === !0 ? ce : E; n("add", { index: 0, value: $e }), n("update:modelValue", e.multiple === !0 ? [$e] : $e); return } const xe = e.modelValue.slice(), Ve = Z.value.findIndex($e => un($e, ce)); if (Ve > -1) n("remove", { index: Ve, value: xe.splice(Ve, 1)[0] }); else { if (e.maxValues !== void 0 && xe.length >= e.maxValues) return; const $e = e.emitValue === !0 ? ce : E; n("add", { index: xe.length, value: $e }), xe.push($e) } n("update:modelValue", xe) } function Ke(E) { if (r.platform.is.desktop !== !0) return; const ve = E > -1 && E < j.value ? E : -1; l.value !== ve && (l.value = ve) } function yt(E = 1, ve) { if (i.value === !0) { let ce = l.value; do ce = Wu(ce + E, -1, j.value - 1); while (ce !== -1 && ce !== l.value && Q.value(e.options[ce]) === !0); l.value !== ce && (Ke(ce), oe(ce), ve !== !0 && e.useInput === !0 && e.fillInput === !0 && Ir(ce >= 0 ? P.value(e.options[ce]) : _)) } } function Jn(E, ve) { const ce = xe => un(Y.value(xe), E); return e.options.find(ce) || ve.find(ce) || E } function bt(E, ve) { const ce = E !== void 0 ? E : ve; return typeof ce == "function" ? ce : xe => xe !== null && typeof xe == "object" && ce in xe ? xe[ce] : xe } function mt(E) { const ve = Y.value(E); return Z.value.find(ce => un(ce, ve)) !== void 0 } function dt(E) { e.useInput === !0 && S.value !== null && (E === void 0 || S.value === E.target && E.target.value === X.value) && S.value.select() } function _t(E) { en(E, 27) === !0 && i.value === !0 && (Gt(E), Pn(), no()), n("keyup", E) } function zo(E) { const { value: ve } = E.target; if (E.keyCode !== void 0) { _t(E); return } if (E.target.value = "", d !== null && (clearTimeout(d), d = null), no(), typeof ve == "string" && ve.length > 0) { const ce = ve.toLocaleLowerCase(), xe = $e => { const Ge = e.options.find(vt => $e.value(vt).toLocaleLowerCase() === ce); return Ge === void 0 ? !1 : (O.value.indexOf(Ge) === -1 ? Te(Ge) : Pn(), !0) }, Ve = $e => { xe(Y) !== !0 && (xe(P) === !0 || $e === !0 || Xn(ve, !0, () => Ve(!0))) }; Ve() } else ne.clearValue(E) } function na(E) { n("keypress", E) } function oa(E) { if (n("keydown", E), Hi(E) === !0) return; const ve = a.value.length > 0 && (e.newValueMode !== void 0 || e.onNewValue !== void 0), ce = E.shiftKey !== !0 && e.multiple !== !0 && (l.value > -1 || ve === !0); if (E.keyCode === 27) { Ct(E); return } if (E.keyCode === 9 && ce === !1) { eo(); return } if (E.target === void 0 || E.target.id !== ne.targetUid.value) return; if (E.keyCode === 40 && ne.innerLoading.value !== !0 && i.value === !1) { Be(E), to(); return } if (E.keyCode === 8 && e.hideSelected !== !0 && a.value.length === 0) { e.multiple === !0 && Array.isArray(e.modelValue) === !0 ? me(e.modelValue.length - 1) : e.multiple !== !0 && e.modelValue !== null && n("update:modelValue", null); return } (E.keyCode === 35 || E.keyCode === 36) && (typeof a.value != "string" || a.value.length === 0) && (Be(E), l.value = -1, yt(E.keyCode === 36 ? 1 : -1, e.multiple)), (E.keyCode === 33 || E.keyCode === 34) && R.value !== void 0 && (Be(E), l.value = Math.max(-1, Math.min(j.value, l.value + (E.keyCode === 33 ? -1 : 1) * R.value.view)), yt(E.keyCode === 33 ? 1 : -1, e.multiple)), (E.keyCode === 38 || E.keyCode === 40) && (Be(E), yt(E.keyCode === 38 ? -1 : 1, e.multiple)); const xe = j.value; if ((g === void 0 || m < Date.now()) && (g = ""), xe > 0 && e.useInput !== !0 && E.key !== void 0 && E.key.length === 1 && E.altKey === !1 && E.ctrlKey === !1 && E.metaKey === !1 && (E.keyCode !== 32 || g.length > 0)) { i.value !== !0 && to(E); const Ve = E.key.toLocaleLowerCase(), $e = g.length === 1 && g[0] === Ve; m = Date.now() + 1500, $e === !1 && (Be(E), g += Ve); const Ge = new RegExp("^" + g.split("").map(es => Sb.indexOf(es) > -1 ? "\\" + es : es).join(".*"), "i"); let vt = l.value; if ($e === !0 || vt < 0 || Ge.test(P.value(e.options[vt])) !== !0) do vt = Wu(vt + 1, -1, xe - 1); while (vt !== l.value && (Q.value(e.options[vt]) === !0 || Ge.test(P.value(e.options[vt])) !== !0)); l.value !== vt && Ie(() => { Ke(vt), oe(vt), vt >= 0 && e.useInput === !0 && e.fillInput === !0 && Ir(P.value(e.options[vt])) }); return } if (!(E.keyCode !== 13 && (E.keyCode !== 32 || e.useInput === !0 || g !== "") && (E.keyCode !== 9 || ce === !1))) { if (E.keyCode !== 9 && Be(E), l.value > -1 && l.value < xe) { Te(e.options[l.value]); return } if (ve === !0) { const Ve = ($e, Ge) => { if (Ge) { if (Qu(Ge) !== !0) return } else Ge = e.newValueMode; if ($e == null) return; Vo("", e.multiple !== !0, !0), (Ge === "toggle" ? Te : be)($e, Ge === "add-unique"), e.multiple !== !0 && (S.value !== null && S.value.focus(), Pn()) }; if (e.onNewValue !== void 0 ? n("newValue", a.value, Ve) : Ve(a.value), e.multiple !== !0) return } i.value === !0 ? eo() : ne.innerLoading.value !== !0 && to() } } function ra() { return h === !0 ? q.value : k.value !== null && k.value.contentEl !== null ? k.value.contentEl : void 0 } function ph() { return ra() } function gh() { return e.hideSelected === !0 ? [] : t["selected-item"] !== void 0 ? H.value.map(E => t["selected-item"](E)).slice() : t.selected !== void 0 ? [].concat(t.selected()) : e.useChips === !0 ? H.value.map((E, ve) => b(Dy, { key: "option-" + ve, removable: ne.editable.value === !0 && Q.value(E.opt) !== !0, dense: !0, textColor: e.color, tabindex: p.value, onRemove() { E.removeAtIndex(ve) } }, () => b("span", { class: "ellipsis", [E.html === !0 ? "innerHTML" : "textContent"]: P.value(E.opt) }))) : [b("span", { [ge.value === !0 ? "innerHTML" : "textContent"]: W.value })] } function ia() { if (L.value === !0) return t["no-option"] !== void 0 ? t["no-option"]({ inputValue: a.value }) : void 0; const E = t.option !== void 0 ? t.option : ce => b(Hy, { key: ce.index, ...ce.itemProps }, () => b(Ky, () => b(Uy, () => b("span", { [ce.html === !0 ? "innerHTML" : "textContent"]: ce.label })))); let ve = fe("div", G.value.map(E)); return t["before-options"] !== void 0 && (ve = t["before-options"]().concat(ve)), Lt(t["after-options"], ve) } function yh(E, ve) { const ce = ve === !0 ? { ...C.value, ...ne.splitAttrs.attributes.value } : void 0, xe = { ref: ve === !0 ? S : void 0, key: "i_t", class: N.value, style: e.inputStyle, value: a.value !== void 0 ? a.value : "", type: "search", ...ce, id: ve === !0 ? ne.targetUid.value : void 0, maxlength: e.maxlength, autocomplete: e.autocomplete, "data-autofocus": E === !0 || e.autofocus === !0 || void 0, disabled: e.disable === !0, readonly: e.readonly === !0, ...le.value }; return E !== !0 && h === !0 && (Array.isArray(xe.class) === !0 ? xe.class = [...xe.class, "no-pointer-events"] : xe.class += " no-pointer-events"), b("input", xe) } function sa(E) { d !== null && (clearTimeout(d), d = null), !(E && E.target && E.target.qComposing === !0) && (Ir(E.target.value || ""), v = !0, _ = a.value, ne.focused.value !== !0 && (h !== !0 || c.value === !0) && ne.focus(), e.onFilter !== void 0 && (d = setTimeout(() => { d = null, Xn(a.value) }, e.inputDebounce))) } function Ir(E) { a.value !== E && (a.value = E, n("inputValue", E)) } function Vo(E, ve, ce) { v = ce !== !0, e.useInput === !0 && (Ir(E), (ve === !0 || ce !== !0) && (_ = E), ve !== !0 && Xn(E)) } function Xn(E, ve, ce) { if (e.onFilter === void 0 || ve !== !0 && ne.focused.value !== !0) return; ne.innerLoading.value === !0 ? n("filterAbort") : (ne.innerLoading.value = !0, u.value = !0), E !== "" && e.multiple !== !0 && O.value.length > 0 && v !== !0 && E === P.value(O.value[0]) && (E = ""); const xe = setTimeout(() => { i.value === !0 && (i.value = !1) }, 10); x !== null && clearTimeout(x), x = xe, n("filter", E, (Ve, $e) => { (ve === !0 || ne.focused.value === !0) && x === xe && (clearTimeout(x), typeof Ve == "function" && Ve(), u.value = !1, Ie(() => { ne.innerLoading.value = !1, ne.editable.value === !0 && (ve === !0 ? i.value === !0 && Pn() : i.value === !0 ? Xi(!0) : i.value = !0), typeof $e == "function" && Ie(() => { $e(o) }), typeof ce == "function" && Ie(() => { ce(o) }) })) }, () => { ne.focused.value === !0 && x === xe && (clearTimeout(x), ne.innerLoading.value = !1, u.value = !1), i.value === !0 && (i.value = !1) }) } function bh() { return b(cb, { ref: k, class: U.value, style: e.popupContentStyle, modelValue: i.value, fit: e.menuShrink !== !0, cover: e.optionsCover === !0 && L.value !== !0 && e.useInput !== !0, anchor: e.menuAnchor, self: e.menuSelf, offset: e.menuOffset, dark: ue.value, noParentEvent: !0, noRefocus: !0, noFocus: !0, square: se.value, transitionShow: e.transitionShow, transitionHide: e.transitionHide, transitionDuration: e.transitionDuration, separateClosePopup: !0, ...I.value, onScrollPassive: D, onBeforeShow: aa, onBeforeHide: _h, onShow: wh }, ia) } function _h(E) { ua(E), eo() } function wh() { Ce() } function Ch(E) { Gt(E), S.value !== null && S.value.focus(), c.value = !0, window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0) } function xh(E) { Gt(E), Ie(() => { c.value = !1 }) } function kh() { const E = [b(Ny, { class: `col-auto ${ne.fieldClass.value}`, ...J.value, for: ne.targetUid.value, dark: ue.value, square: !0, loading: u.value, itemAligned: !1, filled: !0, stackLabel: a.value.length > 0, ...ne.splitAttrs.listeners.value, onFocus: Ch, onBlur: xh }, { ...t, rawControl: () => ne.getControl(!0), before: void 0, after: void 0 })]; return i.value === !0 && E.push(b("div", { ref: q, class: U.value + " scroll", style: e.popupContentStyle, ...I.value, onClick: Ct, onScrollPassive: D }, ia())), b(qo, { ref: T, modelValue: s.value, position: e.useInput === !0 ? "top" : void 0, transitionShow: A, transitionHide: e.transitionHide, transitionDuration: e.transitionDuration, onBeforeShow: aa, onBeforeHide: Sh, onHide: Eh, onShow: qh }, () => b("div", { class: "q-select__dialog" + (ue.value === !0 ? " q-select__dialog--dark q-dark" : "") + (c.value === !0 ? " q-select__dialog--focused" : "") }, E)) } function Sh(E) { ua(E), T.value !== null && T.value.__updateRefocusTarget(ne.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")), ne.focused.value = !1 } function Eh(E) { Pn(), ne.focused.value === !1 && n("blur", E), no() } function qh() { const E = document.activeElement; (E === null || E.id !== ne.targetUid.value) && S.value !== null && S.value !== E && S.value.focus(), Ce() } function eo() { s.value !== !0 && (l.value = -1, i.value === !0 && (i.value = !1), ne.focused.value === !1 && (x !== null && (clearTimeout(x), x = null), ne.innerLoading.value === !0 && (n("filterAbort"), ne.innerLoading.value = !1, u.value = !1))) } function to(E) { ne.editable.value === !0 && (h === !0 ? (ne.onControlFocusin(E), s.value = !0, Ie(() => { ne.focus() })) : ne.focus(), e.onFilter !== void 0 ? Xn(a.value) : (L.value !== !0 || t["no-option"] !== void 0) && (i.value = !0)) } function Pn() { s.value = !1, eo() } function no() { e.useInput === !0 && Vo(e.multiple !== !0 && e.fillInput === !0 && O.value.length > 0 && P.value(O.value[0]) || "", !0, !0) } function Xi(E) { let ve = -1; if (E === !0) { if (O.value.length > 0) { const ce = Y.value(O.value[0]); ve = e.options.findIndex(xe => un(Y.value(xe), ce)) } ee(ve) } Ke(ve) } function Th(E, ve) { i.value === !0 && ne.innerLoading.value === !1 && (ee(-1, !0), Ie(() => { i.value === !0 && ne.innerLoading.value === !1 && (E > ve ? ee() : Xi(!0)) })) } function la() { s.value === !1 && k.value !== null && k.value.updatePosition() } function aa(E) { E !== void 0 && Gt(E), n("popupShow", E), ne.hasPopupOpen = !0, ne.onControlFocusin(E) } function ua(E) { E !== void 0 && Gt(E), n("popupHide", E), ne.hasPopupOpen = !1, ne.onControlFocusout(E) } function ca() { h = r.platform.is.mobile !== !0 && e.behavior !== "dialog" ? !1 : e.behavior !== "menu" && (e.useInput === !0 ? t["no-option"] !== void 0 || e.onFilter !== void 0 || L.value === !1 : !0), A = r.platform.is.ios === !0 && h === !0 && e.useInput === !0 ? "fade" : e.transitionShow } return Tl(ca), Ii(la), ca(), Re(() => { d !== null && clearTimeout(d) }), Object.assign(o, { showPopup: to, hidePopup: Pn, removeAtIndex: me, add: be, toggleOption: Te, getOptionIndex: () => l.value, setOptionIndex: Ke, moveOptionSelection: yt, filter: Xn, updateMenuPosition: la, updateInputValue: Vo, isOptionSelected: mt, getEmittingOptionValue: he, isOptionDisabled: (...E) => Q.value.apply(null, E) === !0, getOptionValue: (...E) => Y.value.apply(null, E), getOptionLabel: (...E) => P.value.apply(null, E) }), Object.assign(ne, { innerValue: O, fieldClass: y(() => `q-select q-field--auto-height q-select--with${e.useInput !== !0 ? "out" : ""}-input q-select--with${e.useChips !== !0 ? "out" : ""}-chips q-select--${e.multiple === !0 ? "multiple" : "single"}`), inputRef: w, targetRef: S, hasValue: we, showPopup: to, floatingLabel: y(() => e.hideSelected !== !0 && we.value === !0 || typeof a.value == "number" || a.value.length > 0 || Er(e.displayValue)), getControlChild: () => { if (ne.editable.value !== !1 && (s.value === !0 || L.value !== !0 || t["no-option"] !== void 0)) return h === !0 ? kh() : bh(); ne.hasPopupOpen === !0 && (ne.hasPopupOpen = !1) }, controlEvents: { onFocusin(E) { ne.onControlFocusin(E) }, onFocusout(E) { ne.onControlFocusout(E, () => { no(), eo() }) }, onClick(E) { if (Ct(E), h !== !0 && i.value === !0) { eo(), S.value !== null && S.value.focus(); return } to(E) } }, getControl: E => { const ve = gh(), ce = E === !0 || s.value !== !0 || h !== !0; if (e.useInput === !0) ve.push(yh(E, ce)); else if (ne.editable.value === !0) { const Ve = ce === !0 ? C.value : void 0; ve.push(b("input", { ref: ce === !0 ? S : void 0, key: "d_t", class: "q-select__focus-target", id: ce === !0 ? ne.targetUid.value : void 0, value: W.value, readonly: !0, "data-autofocus": E === !0 || e.autofocus === !0 || void 0, ...Ve, onKeydown: oa, onKeyup: _t, onKeypress: na })), ce === !0 && typeof e.autocomplete == "string" && e.autocomplete.length > 0 && ve.push(b("input", { class: "q-select__autocomplete-input", autocomplete: e.autocomplete, tabindex: -1, onKeyup: zo })) } if (F.value !== void 0 && e.disable !== !0 && Z.value.length > 0) { const Ve = Z.value.map($e => b("option", { value: $e, selected: !0 })); ve.push(b("select", { class: "hidden", name: F.value, multiple: e.multiple }, Ve)) } const xe = e.useInput === !0 || ce !== !0 ? void 0 : ne.splitAttrs.attributes.value; return b("div", { class: "q-field__native row items-center", ...xe }, ve) }, getInnerAppend: () => e.loading !== !0 && u.value !== !0 && e.hideDropdownIcon !== !0 ? [b(ct, { class: "q-select__dropdown-icon" + (i.value === !0 ? " rotate-180" : ""), name: re.value })] : null }), Ul(ne) } }), qr = qe({ name: "QCardActions", props: { ...ff, vertical: Boolean }, setup(e, { slots: t }) { const n = hf(e), o = y(() => `q-card__actions ${n.value} q-card__actions--${e.vertical === !0 ? "vert column" : "horiz row"}`); return () => b("div", { class: o.value }, He(t.default)) } }), xi = qe({ name: "QForm", props: { autofocus: Boolean, noErrorFocus: Boolean, noResetFocus: Boolean, greedy: Boolean, onSubmit: Function }, emits: ["reset", "validationSuccess", "validationError"], setup(e, { slots: t, emit: n }) { const o = Ee(), r = z(null); let i = 0; const s = []; function l(h) { const v = typeof h == "boolean" ? h : e.noErrorFocus !== !0, x = ++i, _ = (m, w) => { n("validation" + (m === !0 ? "Success" : "Error"), w) }, A = m => { const w = m.validate(); return typeof w.then == "function" ? w.then(S => ({ valid: S, comp: m }), S => ({ valid: !1, comp: m, err: S })) : Promise.resolve({ valid: w, comp: m }) }; return (e.greedy === !0 ? Promise.all(s.map(A)).then(m => m.filter(w => w.valid !== !0)) : s.reduce((m, w) => m.then(() => A(w).then(S => { if (S.valid === !1) return Promise.reject(S) })), Promise.resolve()).catch(m => [m])).then(m => { if (m === void 0 || m.length === 0) return x === i && _(!0), !0; if (x === i) { const { comp: w, err: S } = m[0]; if (S !== void 0 && console.error(S), _(!1, w), v === !0) { const k = m.find(({ comp: T }) => typeof T.focus == "function" && Vl(T.$) === !1); k !== void 0 && k.comp.focus() } } return !1 }) } function a() { i++, s.forEach(h => { typeof h.resetValidation == "function" && h.resetValidation() }) } function c(h) { h !== void 0 && Be(h); const v = i + 1; l().then(x => { v === i && x === !0 && (e.onSubmit !== void 0 ? n("submit", h) : h !== void 0 && h.target !== void 0 && typeof h.target.submit == "function" && h.target.submit()) }) } function u(h) { h !== void 0 && Be(h), n("reset"), Ie(() => { a(), e.autofocus === !0 && e.noResetFocus !== !0 && d() }) } function d() { Br(() => { if (r.value === null) return; const h = r.value.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || r.value.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || r.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(r.value.querySelectorAll("[tabindex]"), v => v.tabIndex > -1); h != null && h.focus({ preventScroll: !0 }) }) } xt(Ld, { bindComponent(h) { s.push(h) }, unbindComponent(h) { const v = s.indexOf(h); v > -1 && s.splice(v, 1) } }); let f = !1; return Yn(() => { f = !0 }), Rr(() => { f === !0 && e.autofocus === !0 && d() }), et(() => { e.autofocus === !0 && d() }), Object.assign(o.proxy, { validate: l, resetValidation: a, submit: c, reset: u, focus: d, getValidationComponents: () => s }), () => b("form", { class: "q-form", ref: r, onSubmit: c, onReset: u }, He(t.default)) } }), St = qe({ name: "QCard", props: { ...Ut, tag: { type: String, default: "div" }, square: Boolean, flat: Boolean, bordered: Boolean }, setup(e, { slots: t }) { const { proxy: { $q: n } } = Ee(), o = Wt(e, n), r = y(() => "q-card" + (o.value === !0 ? " q-card--dark q-dark" : "") + (e.bordered === !0 ? " q-card--bordered" : "") + (e.square === !0 ? " q-card--square no-border-radius" : "") + (e.flat === !0 ? " q-card--flat no-shadow" : "")); return () => b(e.tag, { class: r.value }, He(t.default)) } }); const Tb = { ratio: [String, Number] }; function Pb(e, t) { return y(() => { const n = Number(e.ratio || (t !== void 0 ? t.value : void 0)); return isNaN(n) !== !0 && n > 0 ? { paddingBottom: `${100 / n}%` } : null }) } var Zi = qe({ name: "QVideo", props: { ...Tb, src: { type: String, required: !0 }, title: String, fetchpriority: { type: String, default: "auto" }, loading: { type: String, default: "eager" }, referrerpolicy: { type: String, default: "strict-origin-when-cross-origin" } }, setup(e) { const t = Pb(e), n = y(() => "q-video" + (e.ratio !== void 0 ? " q-video--responsive" : "")); return () => b("div", { class: n.value, style: t.value }, [b("iframe", { src: e.src, title: e.title, fetchpriority: e.fetchpriority, loading: e.loading, referrerpolicy: e.referrerpolicy, frameborder: "0", allowfullscreen: !0 })]) } }), nn = qe({ name: "QPage", props: { padding: Boolean, styleFn: Function }, setup(e, { slots: t }) { const { proxy: { $q: n } } = Ee(), o = Le(Mr, ot); if (o === ot) return console.error("QPage needs to be a deep child of QLayout"), ot; if (Le(Rd, ot) === ot) return console.error("QPage needs to be child of QPageContainer"), ot; const i = y(() => { const l = (o.header.space === !0 ? o.header.size : 0) + (o.footer.space === !0 ? o.footer.size : 0); if (typeof e.styleFn == "function") { const a = o.isContainer.value === !0 ? o.containerHeight.value : n.screen.height; return e.styleFn(l, a) } return { minHeight: o.isContainer.value === !0 ? o.containerHeight.value - l + "px" : n.screen.height === 0 ? l !== 0 ? `calc(100vh - ${l}px)` : "100vh" : n.screen.height - l + "px" } }), s = y(() => `q-page${e.padding === !0 ? " q-layout-padding" : ""}`); return () => b("main", { class: s.value, style: i.value }, He(t.default)) } }); function Gu(e) { if (e === !1) return 0; if (e === !0 || e === void 0) return 1; const t = parseInt(e, 10); return isNaN(t) ? 0 : t } var xn = Fl({ name: "close-popup", beforeMount(e, { value: t }) { const n = { depth: Gu(t), handler(o) { n.depth !== 0 && setTimeout(() => { const r = Jy(e); r !== void 0 && Xy(r, o, n.depth) }) }, handlerKey(o) { en(o, 13) === !0 && n.handler(o) } }; e.__qclosepopup = n, e.addEventListener("click", n.handler), e.addEventListener("keyup", n.handlerKey) }, updated(e, { value: t, oldValue: n }) { t !== n && (e.__qclosepopup.depth = Gu(t)) }, beforeUnmount(e) { const t = e.__qclosepopup; e.removeEventListener("click", t.handler), e.removeEventListener("keyup", t.handlerKey), delete e.__qclosepopup } }); let Mo = Symbol("map"), Bo = Symbol("api"), Of = Symbol("marker"), Rf = Symbol("markerCluster"), ki = Symbol("CustomMarker"), Lf = Symbol("mapTilesLoaded"), To = "click dblclick drag dragend dragstart mousedown mousemove mouseout mouseover mouseup rightclick".split(" "); var Ab = function e(t, n) { if (t === n) return !0; if (t && n && typeof t == "object" && typeof n == "object") { if (t.constructor !== n.constructor) return !1; var o; if (Array.isArray(t)) { var r = t.length; if (r != n.length) return !1; for (o = r; o-- !== 0;)if (!e(t[o], n[o])) return !1; return !0 } if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags; if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf(); if (t.toString !== Object.prototype.toString) return t.toString() === n.toString(); var i = Object.keys(t); if (r = i.length, r !== Object.keys(n).length) return !1; for (o = r; o-- !== 0;)if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1; for (o = r; o-- !== 0;)if (r = i[o], !e(t[r], n[r])) return !1; return !0 } return t !== t && n !== n }; class zn { constructor({ apiKey: t, channel: n, client: o, id: r = "__googleMapsScriptId", libraries: i = [], language: s, region: l, version: a, mapIds: c, nonce: u, retries: d = 3, url: f = "https://maps.googleapis.com/maps/api/js" }) { if (this.CALLBACK = "__googleMapsCallback", this.callbacks = [], this.loading = this.done = !1, this.errors = [], this.version = a, this.apiKey = t, this.channel = n, this.client = o, this.id = r || "__googleMapsScriptId", this.libraries = i, this.language = s, this.region = l, this.mapIds = c, this.nonce = u, this.retries = d, this.url = f, zn.instance) { if (!Ab(this.options, zn.instance.options)) throw Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(zn.instance.options)}`); return zn.instance } zn.instance = this } get options() { return { version: this.version, apiKey: this.apiKey, channel: this.channel, client: this.client, id: this.id, libraries: this.libraries, language: this.language, region: this.region, mapIds: this.mapIds, nonce: this.nonce, url: this.url } } get failed() { return this.done && !this.loading && this.errors.length >= this.retries + 1 } createUrl() { let t = this.url; return t += `?callback=${this.CALLBACK}`, this.apiKey && (t += `&key=${this.apiKey}`), this.channel && (t += `&channel=${this.channel}`), this.client && (t += `&client=${this.client}`), 0 < this.libraries.length && (t += `&libraries=${this.libraries.join(",")}`), this.language && (t += `&language=${this.language}`), this.region && (t += `&region=${this.region}`), this.version && (t += `&v=${this.version}`), this.mapIds && (t += `&map_ids=${this.mapIds.join(",")}`), t } deleteScript() { let t = document.getElementById(this.id); t && t.remove() } load() { return this.loadPromise() } loadPromise() { return new Promise((t, n) => { this.loadCallback(o => { o ? n(o.error) : t(window.google) }) }) } loadCallback(t) { this.callbacks.push(t), this.execute() } setScript() { if (document.getElementById(this.id)) this.callback(); else { var t = this.createUrl(), n = document.createElement("script"); n.id = this.id, n.type = "text/javascript", n.src = t, n.onerror = this.loadErrorCallback.bind(this), n.defer = !0, n.async = !0, this.nonce && (n.nonce = this.nonce), document.head.appendChild(n) } } reset() { this.deleteScript(), this.loading = this.done = !1, this.errors = [], this.onerrorEvent = null } resetIfRetryingFailed() { this.failed && this.reset() } loadErrorCallback(t) { this.errors.push(t), this.errors.length <= this.retries ? (t = this.errors.length * Math.pow(2, this.errors.length), console.log(`Failed to load Google Maps script, retrying in ${t} ms.`), setTimeout(() => { this.deleteScript(), this.setScript() }, t)) : (this.onerrorEvent = t, this.callback()) } setCallback() { window.__googleMapsCallback = this.callback.bind(this) } callback() { this.done = !0, this.loading = !1, this.callbacks.forEach(t => { t(this.onerrorEvent) }), this.callbacks = [] } execute() { this.resetIfRetryingFailed(), this.done ? this.callback() : window.google && window.google.maps && window.google.maps.version ? (console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match."), this.callback()) : this.loading || (this.loading = !0, this.setCallback(), this.setScript()) } } function Ob(e) { return class extends e.OverlayView { constructor(t) { super(); let { element: n, ...o } = t; this.element = n, this.opts = o, this.opts.map && this.setMap(this.opts.map) } getPosition() { return this.opts.position ? this.opts.position instanceof e.LatLng ? this.opts.position : new e.LatLng(this.opts.position) : null } getVisible() { if (!this.element) return !1; let t = this.element; return t.style.display !== "none" && t.style.visibility !== "hidden" && (t.style.opacity === "" || .01 < Number(t.style.opacity)) } onAdd() { if (this.element) { var t = this.getPanes(); t && t.overlayMouseTarget.appendChild(this.element) } } draw() { if (this.element) { var t = this.getProjection().fromLatLngToDivPixel(this.getPosition()); if (t) { this.element.style.position = "absolute"; let o = this.element.offsetHeight; var n = this.element.offsetWidth; switch (this.opts.anchorPoint) { case "TOP_CENTER": n = t.x - n / 2, t = t.y; break; case "BOTTOM_CENTER": n = t.x - n / 2, t = t.y - o; break; case "LEFT_CENTER": n = t.x, t = t.y - o / 2; break; case "RIGHT_CENTER": n = t.x - n, t = t.y - o / 2; break; case "TOP_LEFT": n = t.x, t = t.y; break; case "TOP_RIGHT": n = t.x - n, t = t.y; break; case "BOTTOM_LEFT": n = t.x, t = t.y - o; break; case "BOTTOM_RIGHT": n = t.x - n, t = t.y - o; break; default: n = t.x - n / 2, t = t.y - o / 2 }this.element.style.left = n + "px", this.element.style.top = t + "px", this.element.style.transform = `translateX(${this.opts.offsetX || 0}px) translateY(${this.opts.offsetY || 0}px)`, this.opts.zIndex && (this.element.style.zIndex = this.opts.zIndex.toString()) } } } onRemove() { this.element && this.element.remove() } setOptions(t) { this.opts = t, this.draw() } } } let Zu, Yu = "bounds_changed center_changed click dblclick drag dragend dragstart heading_changed idle maptypeid_changed mousemove mouseout mouseover projection_changed resize rightclick tilesloaded tilt_changed zoom_changed".split(" "); var Yi = Ne({ props: { apiPromise: { type: Promise }, apiKey: { type: String, default: "" }, version: { type: String, default: "weekly" }, libraries: { type: Array, default: () => ["places"] }, region: { type: String, required: !1 }, language: { type: String, required: !1 }, backgroundColor: { type: String, required: !1 }, center: { type: Object, default: () => ({ lat: 0, lng: 0 }) }, clickableIcons: { type: Boolean, required: !1, default: void 0 }, controlSize: { type: Number, required: !1 }, disableDefaultUi: { type: Boolean, required: !1, default: void 0 }, disableDoubleClickZoom: { type: Boolean, required: !1, default: void 0 }, draggable: { type: Boolean, required: !1, default: void 0 }, draggableCursor: { type: String, required: !1 }, draggingCursor: { type: String, required: !1 }, fullscreenControl: { type: Boolean, required: !1, default: void 0 }, fullscreenControlPosition: { type: String, required: !1 }, gestureHandling: { type: String, required: !1 }, heading: { type: Number, required: !1 }, keyboardShortcuts: { type: Boolean, required: !1, default: void 0 }, mapTypeControl: { type: Boolean, required: !1, default: void 0 }, mapTypeControlOptions: { type: Object, required: !1 }, mapTypeId: { type: [Number, String], required: !1 }, mapId: { type: String, required: !1 }, maxZoom: { type: Number, required: !1 }, minZoom: { type: Number, required: !1 }, noClear: { type: Boolean, required: !1, default: void 0 }, panControl: { type: Boolean, required: !1, default: void 0 }, panControlPosition: { type: String, required: !1 }, restriction: { type: Object, required: !1 }, rotateControl: { type: Boolean, required: !1, default: void 0 }, rotateControlPosition: { type: String, required: !1 }, scaleControl: { type: Boolean, required: !1, default: void 0 }, scaleControlStyle: { type: Number, required: !1 }, scrollwheel: { type: Boolean, required: !1, default: void 0 }, streetView: { type: Object, required: !1 }, streetViewControl: { type: Boolean, required: !1, default: void 0 }, streetViewControlPosition: { type: String, required: !1 }, styles: { type: Array, required: !1 }, tilt: { type: Number, required: !1 }, zoom: { type: Number, required: !1 }, zoomControl: { type: Boolean, required: !1, default: void 0 }, zoomControlPosition: { type: String, required: !1 } }, emits: Yu, setup(e, { emit: t }) { let n = z(), o = z(!1), r = z(), i = z(), s = z(!1); xt(Mo, r), xt(Bo, i), xt(Lf, s); let l = () => { const u = { ...e }; Object.keys(u).forEach(f => { u[f] === void 0 && delete u[f] }); var d = f => { var h; return f ? { position: (h = i.value) === null || h === void 0 ? void 0 : h.ControlPosition[f] } : {} }; return d = { scaleControlOptions: e.scaleControlStyle ? { style: e.scaleControlStyle } : {}, panControlOptions: d(e.panControlPosition), zoomControlOptions: d(e.zoomControlPosition), rotateControlOptions: d(e.rotateControlPosition), streetViewControlOptions: d(e.streetViewControlPosition), fullscreenControlOptions: d(e.fullscreenControlPosition), disableDefaultUI: e.disableDefaultUi }, { ...u, ...d } }, a = de([i, r], ([u, d]) => { u && d && (u.event.addListenerOnce(d, "tilesloaded", () => { s.value = !0 }), setTimeout(a, 0)) }, { immediate: !0 }), c = u => { i.value = it(u.maps), r.value = it(new u.maps.Map(n.value, l())), u = Ob(i.value), i.value[ki] = u, Yu.forEach(d => { var f; (f = r.value) === null || f === void 0 || f.addListener(d, h => t(d, h)) }), o.value = !0, u = Object.keys(e).filter(d => !"apiPromise apiKey version libraries region language center zoom".split(" ").includes(d)).map(d => Zn(e, d)), de([() => e.center, () => e.zoom, ...u], ([d, f], [h, v]) => { var x, _, A; const { center: g, zoom: m, ...w } = l(); (x = r.value) === null || x === void 0 || x.setOptions(w), f !== void 0 && f !== v && ((_ = r.value) === null || _ === void 0 || _.setZoom(f)), f = !h || d.lng !== h.lng || d.lat !== h.lat, d && f && ((A = r.value) === null || A === void 0 || A.panTo(d)) }) }; return et(() => { if (e.apiPromise && e.apiPromise instanceof Promise) e.apiPromise.then(c); else { try { const { apiKey: u, region: d, version: f, language: h, libraries: v } = e; Zu = new zn({ apiKey: u, region: d, version: f, language: h, libraries: v }) } catch (u) { console.error(u) } Zu.load().then(c) } }), Re(() => { var u; s.value = !1, r.value && ((u = i.value) === null || u === void 0 || u.event.clearInstanceListeners(r.value)) }), { mapRef: n, ready: o, map: r, api: i, mapTilesLoaded: s } } }); function Ql(e, t) { if (t === void 0 && (t = {}), t = t.insertAt, e && typeof document != "undefined") { var n = document.head || document.getElementsByTagName("head")[0], o = document.createElement("style"); o.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(o, n.firstChild) : n.appendChild(o), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(document.createTextNode(e)) } } Ql(`
.mapdiv[data-v-177d06e3] {
  width: 100%;
  height: 100%;
}
`); let Rb = Sl(); xl("data-v-177d06e3"); let Lb = { ref: "mapRef", class: "mapdiv" }; kl(); let $b = Rb(e => (Oe(), Qe("div", null, [K("div", Lb, null, 512), zi(e.$slots, "default", { ready: e.ready, map: e.map, api: e.api, mapTilesLoaded: e.mapTilesLoaded }, void 0, !0)]))); Yi.render = $b; Yi.__scopeId = "data-v-177d06e3"; var Tr = function e(t, n) { if (t === n) return !0; if (t && n && typeof t == "object" && typeof n == "object") { if (t.constructor !== n.constructor) return !1; var o; if (Array.isArray(t)) { var r = t.length; if (r != n.length) return !1; for (o = r; o-- !== 0;)if (!e(t[o], n[o])) return !1; return !0 } if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags; if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf(); if (t.toString !== Object.prototype.toString) return t.toString() === n.toString(); var i = Object.keys(t); if (r = i.length, r !== Object.keys(n).length) return !1; for (o = r; o-- !== 0;)if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1; for (o = r; o-- !== 0;)if (r = i[o], !e(t[r], n[r])) return !1; return !0 } return t !== t && n !== n }; let Io = (e, t, n, o) => { const r = z(), i = Le(Mo, z()), s = Le(Bo, z()), l = Le(Rf, z()), a = y(() => !!(l.value && s.value && (r.value instanceof s.value.Marker || r.value instanceof s.value[ki]))); return de([i, n], (c, [u, d]) => { var f, h, v; c = !Tr(n.value, d) || i.value !== u, i.value && s.value && c && (r.value ? (r.value.setOptions(n.value), a.value && ((f = l.value) === null || f === void 0 || f.removeMarker(r.value), (h = l.value) === null || h === void 0 || h.addMarker(r.value))) : (r.value = it(e === "Marker" ? new s.value[e](n.value) : e === ki ? new s.value[e](n.value) : new s.value[e]({ ...n.value, map: i.value })), a.value ? (v = l.value) === null || v === void 0 || v.addMarker(r.value) : r.value.setMap(i.value), t.forEach(x => { var _; (_ = r.value) === null || _ === void 0 || _.addListener(x, A => o(x, A)) }))) }, { immediate: !0 }), Re(() => { var c, u; r.value && ((c = s.value) === null || c === void 0 || c.event.clearInstanceListeners(r.value), a.value ? (u = l.value) === null || u === void 0 || u.removeMarker(r.value) : r.value.setMap(null)) }), r }, Ju = "animation_changed click dblclick rightclick dragstart dragend drag mouseover mousedown mouseout mouseup draggable_changed clickable_changed contextmenu cursor_changed flat_changed rightclick zindex_changed icon_changed position_changed shape_changed title_changed visible_changed".split(" "); var $f = Ne({ name: "Marker", props: { options: { type: Object, required: !0 } }, emits: Ju, setup(e, { emit: t, expose: n, slots: o }) { return e = Zn(e, "options"), t = Io("Marker", Ju, e, t), xt(Of, t), n({ marker: t }), () => { var r; return (r = o.default) === null || r === void 0 ? void 0 : r.call(o) } } }), Mf = Ne({ name: "Polyline", props: { options: { type: Object, required: !0 } }, emits: To, setup(e, { emit: t }) { return e = Zn(e, "options"), { polyline: Io("Polyline", To, e, t) } }, render: () => null }); Ne({ name: "Polygon", props: { options: { type: Object, required: !0 } }, emits: To, setup(e, { emit: t }) { return e = Zn(e, "options"), { polygon: Io("Polygon", To, e, t) } }, render: () => null }); let Xu = To.concat(["bounds_changed"]); Ne({ name: "Rectangle", props: { options: { type: Object, required: !0 } }, emits: Xu, setup(e, { emit: t }) { return e = Zn(e, "options"), { rectangle: Io("Rectangle", Xu, e, t) } }, render: () => null }); let ec = To.concat(["center_changed", "radius_changed"]); Ne({ name: "Circle", props: { options: { type: Object, required: !0 } }, emits: ec, setup(e, { emit: t }) { return e = Zn(e, "options"), { circle: Io("Circle", ec, e, t) } }, render: () => null }); var Gl = Ne({ props: { position: { type: String, required: !0 }, index: { type: Number, default: 1 } }, emits: ["content:loaded"], setup(e, { emit: t }) { let n = z(null), o = Le(Mo, z()), r = Le(Bo, z()), i = Le(Lf, z(!1)), s = z(!1), l = de([i, r, n], ([u, d, f]) => { d && u && f && (a(e.position), s.value = !0, t("content:loaded"), setTimeout(l, 0)) }, { immediate: !0 }), a = u => { o.value && r.value && n.value && o.value.controls[r.value.ControlPosition[u]].push(n.value) }, c = u => { if (o.value && r.value) { let d = null; u = r.value.ControlPosition[u], o.value.controls[u].forEach((f, h) => { f === n.value && (d = h) }), d !== null && o.value.controls[u].removeAt(d) } }; return Re(() => c(e.position)), de(() => e.position, (u, d) => { c(d), a(u) }), de(() => e.index, u => { u && n.value && (n.value.index = e.index) }), { controlRef: n, showContent: s } } }); let Mb = { ref: "controlRef" }; Gl.render = function (e) {
    return Oe(), Qe(Ue, null, [Lr(`
    v-show must be used instead of v-if otherwise there
    would be no rendered content pushed to the map controls
  `), Rt(K("div", Mb, [zi(e.$slots, "default")], 512), [[np, e.showContent]])], 2112)
}; let tc = "closeclick content_changed domready position_changed visible zindex_changed".split(" "); var Bf = Ne({ inheritAttrs: !1, props: { options: { type: Object, default: () => ({}) } }, emits: tc, setup(e, { slots: t, emit: n }) { let o = z(), r = z(), i = Le(Mo, z()), s = Le(Bo, z()), l = Le(Of, z()), a, c = y(() => { var u; return (u = t.default) === null || u === void 0 ? void 0 : u.call(t).some(d => d.type !== gt) }); return et(() => { de([i, () => e.options], ([, u], [d, f]) => { d = !Tr(u, f) || i.value !== d, i.value && s.value && d && (o.value ? (o.value.setOptions({ ...u, content: c.value ? r.value : u.content }), l.value || o.value.open({ map: i.value })) : (o.value = it(new s.value.InfoWindow({ ...u, content: c.value ? r.value : u.content })), l.value ? a = l.value.addListener("click", () => { o.value && o.value.open({ map: i.value, anchor: l.value }) }) : o.value.open({ map: i.value }), tc.forEach(h => { var v; (v = o.value) === null || v === void 0 || v.addListener(h, x => n(h, x)) }))) }, { immediate: !0 }) }), Re(() => { var u; a && a.remove(), o.value && ((u = s.value) === null || u === void 0 || u.event.clearInstanceListeners(o.value), o.value.close()) }), { infoWindow: o, infoWindowRef: r, hasSlotContent: c } } }); Ql(`
.info-window-wrapper[data-v-5b373d6e] {
  display: none;
}
.mapdiv .info-window-wrapper[data-v-5b373d6e] {
  display: inline-block;
}
`); let Bb = Sl(); xl("data-v-5b373d6e"); let Ib = { key: 0, class: "info-window-wrapper" }; kl(); let Fb = Bb(e => e.hasSlotContent ? (Oe(), Qe("div", Ib, [K("div", Ll({ ref: "infoWindowRef" }, e.$attrs), [zi(e.$slots, "default", {}, void 0, !0)], 16)])) : Lr("v-if", !0)); Bf.render = Fb; Bf.__scopeId = "data-v-5b373d6e"; function Xs(e, t, n, o, r, i) { if (!(r - o <= n)) { var s = o + r >> 1; If(e, t, s, o, r, i % 2), Xs(e, t, n, o, s - 1, i + 1), Xs(e, t, n, s + 1, r, i + 1) } } function If(e, t, n, o, r, i) { for (; r > o;) { if (600 < r - o) { var s = r - o + 1, l = n - o + 1, a = Math.log(s), c = .5 * Math.exp(2 * a / 3); a = .5 * Math.sqrt(a * c * (s - c) / s) * (0 > l - s / 2 ? -1 : 1), If(e, t, n, Math.max(o, Math.floor(n - l * c / s + a)), Math.min(r, Math.floor(n + (s - l) * c / s + a)), i) } for (s = t[2 * n + i], l = o, c = r, Wo(e, t, o, n), t[2 * r + i] > s && Wo(e, t, o, r); l < c;) { for (Wo(e, t, l, c), l++, c--; t[2 * l + i] < s;)l++; for (; t[2 * c + i] > s;)c-- } t[2 * o + i] === s ? Wo(e, t, o, c) : (c++, Wo(e, t, c, r)), c <= n && (o = c + 1), n <= c && (r = c - 1) } } function Wo(e, t, n, o) { Ss(e, n, o), Ss(t, 2 * n, 2 * o), Ss(t, 2 * n + 1, 2 * o + 1) } function Ss(e, t, n) { let o = e[t]; e[t] = e[n], e[n] = o } let zb = e => e[0], Vb = e => e[1]; class nc { constructor(t, n = zb, o = Vb, r = 64, i = Float64Array) { this.nodeSize = r, this.points = t; let s = this.ids = new (65536 > t.length ? Uint16Array : Uint32Array)(t.length); i = this.coords = new i(2 * t.length); for (let l = 0; l < t.length; l++)s[l] = l, i[2 * l] = n(t[l]), i[2 * l + 1] = o(t[l]); Xs(s, i, r, 0, s.length - 1, 0) } range(t, n, o, r) { { var i = this.ids, s = this.coords, l = this.nodeSize; let c = [0, i.length - 1, 0], u = [], d, f; for (; c.length;) { var a = c.pop(); let h = c.pop(), v = c.pop(); if (h - v <= l) { for (a = v; a <= h; a++)d = s[2 * a], f = s[2 * a + 1], d >= t && d <= o && f >= n && f <= r && u.push(i[a]); continue } let x = Math.floor((v + h) / 2); d = s[2 * x], f = s[2 * x + 1], d >= t && d <= o && f >= n && f <= r && u.push(i[x]); let _ = (a + 1) % 2; (a === 0 ? t <= d : n <= f) && (c.push(v), c.push(x - 1), c.push(_)), (a === 0 ? o >= d : r >= f) && (c.push(x + 1), c.push(h), c.push(_)) } t = u } return t } within(t, n, o) { { var r = this.ids, i = this.coords, s = this.nodeSize; let d = [0, r.length - 1, 0], f = [], h = o * o; for (; d.length;) { var l = d.pop(); let v = d.pop(); var a = d.pop(); if (v - a <= s) { for (l = a; l <= v; l++) { a = i[2 * l] - t; var c = i[2 * l + 1] - n; a = a * a + c * c, a <= h && f.push(r[l]) } continue } c = Math.floor((a + v) / 2); let x = i[2 * c], _ = i[2 * c + 1]; { var u = x - t; let A = _ - n; u = u * u + A * A } u <= h && f.push(r[c]), u = (l + 1) % 2, (l === 0 ? t - o <= x : n - o <= _) && (d.push(a), d.push(c - 1), d.push(u)), (l === 0 ? t + o >= x : n + o >= _) && (d.push(c + 1), d.push(v), d.push(u)) } t = f } return t } } let Nb = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: e => e }, Si = Math.fround || (e => t => (e[0] = +t, e[0]))(new Float32Array(1)); class jb { constructor(t) { this.options = dr(Object.create(Nb), t), this.trees = Array(this.options.maxZoom + 1) } load(t) { let { log: n, minZoom: o, maxZoom: r, nodeSize: i } = this.options; n && console.time("total time"); var s = `prepare ${t.length} points`; n && console.time(s), this.points = t; let l = []; for (let a = 0; a < t.length; a++)t[a].geometry && l.push(Hb(t[a], a)); for (this.trees[r + 1] = new nc(l, rc, ic, i, Float32Array), n && console.timeEnd(s), t = r; t >= o; t--)s = +Date.now(), l = this._cluster(l, t), this.trees[t] = new nc(l, rc, ic, i, Float32Array), n && console.log("z%d: %d clusters in %dms", t, l.length, +Date.now() - s); return n && console.timeEnd("total time"), this } getClusters(t, n) { let o = ((t[0] + 180) % 360 + 360) % 360 - 180; var r = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180; let s = Math.max(-90, Math.min(90, t[3])); if (360 <= t[2] - t[0]) o = -180, i = 180; else if (o > i) { var l = this.getClusters([o, r, 180, s], n); return r = this.getClusters([-180, r, i, s], n), l.concat(r) } n = this.trees[this._limitZoom(n)], i = n.range(o / 360 + .5, oi(s), i / 360 + .5, oi(r)), r = []; for (l of i) i = n.points[l], r.push(i.numPoints ? oc(i) : this.points[i.index]); return r } getChildren(t) { var n = this._getOriginId(t), o = this._getOriginZoom(t); let r = this.trees[o]; if (!r || (n = r.points[n], !n)) throw Error("No cluster with the specified id."); n = r.within(n.x, n.y, this.options.radius / (this.options.extent * Math.pow(2, o - 1))), o = []; for (let i of n) n = r.points[i], n.parentId === t && o.push(n.numPoints ? oc(n) : this.points[n.index]); if (o.length === 0) throw Error("No cluster with the specified id."); return o } getLeaves(t, n, o) { let r = []; return this._appendLeaves(r, t, n || 10, o || 0, 0), r } getTile(t, n, o) { let r = this.trees[this._limitZoom(t)]; t = Math.pow(2, t); let { extent: i, radius: s } = this.options, l = s / i, a = (o - l) / t, c = (o + 1 + l) / t, u = { features: [] }; return this._addTileFeatures(r.range((n - l) / t, a, (n + 1 + l) / t, c), r.points, n, o, t, u), n === 0 && this._addTileFeatures(r.range(1 - l / t, a, 1, c), r.points, t, o, t, u), n === t - 1 && this._addTileFeatures(r.range(0, a, l / t, c), r.points, -1, o, t, u), u.features.length ? u : null } getClusterExpansionZoom(t) { let n = this._getOriginZoom(t) - 1; for (; n <= this.options.maxZoom && (t = this.getChildren(t), n++, t.length === 1);)t = t[0].properties.cluster_id; return n } _appendLeaves(t, n, o, r, i) { n = this.getChildren(n); for (let s of n) if ((n = s.properties) && n.cluster ? i = i + n.point_count <= r ? i + n.point_count : this._appendLeaves(t, n.cluster_id, o, r, i) : i < r ? i++ : t.push(s), t.length === o) break; return i } _addTileFeatures(t, n, o, r, i, s) { for (let c of t) { t = n[c]; let u = t.numPoints; var l = void 0; let d; var a = void 0; u ? (l = Ff(t), d = t.x, a = t.y) : (a = this.points[t.index], l = a.properties, d = a.geometry.coordinates[0] / 360 + .5, a = oi(a.geometry.coordinates[1])), l = { type: 1, geometry: [[Math.round(this.options.extent * (d * i - o)), Math.round(this.options.extent * (a * i - r))]], tags: l }; let f; u ? f = t.id : this.options.generateId ? f = t.index : this.points[t.index].id && (f = this.points[t.index].id), f !== void 0 && (l.id = f), s.features.push(l) } } _limitZoom(t) { return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1)) } _cluster(t, n) { let o = [], { radius: r, extent: i, reduce: s, minPoints: l } = this.options, a = r / (i * Math.pow(2, n)); for (let h = 0; h < t.length; h++) { var c = t[h]; if (c.zoom <= n) continue; c.zoom = n; let v = this.trees[n + 1]; var u = v.within(c.x, c.y, a), d = c.numPoints || 1; let x = d; for (let _ of u) { var f = v.points[_]; f.zoom > n && (x += f.numPoints || 1) } if (x > d && x >= l) { f = c.x * d; let _ = c.y * d; d = s && 1 < d ? this._map(c, !0) : null; let A = (h << 5) + (n + 1) + this.points.length; for (let g of u) { if (u = v.points[g], u.zoom <= n) continue; u.zoom = n; let m = u.numPoints || 1; f += u.x * m, _ += u.y * m, u.parentId = A, s && (d || (d = this._map(c, !0)), s(d, this._map(u))) } c.parentId = A, o.push(Db(f / x, _ / x, A, x, d)) } else if (o.push(c), 1 < x) for (let _ of u) c = v.points[_], c.zoom <= n || (c.zoom = n, o.push(c)) } return o } _getOriginId(t) { return t - this.points.length >> 5 } _getOriginZoom(t) { return (t - this.points.length) % 32 } _map(t, n) { if (t.numPoints) return n ? dr({}, t.properties) : t.properties; t = this.points[t.index].properties; let o = this.options.map(t); return n && o === t ? dr({}, o) : o } } function Db(e, t, n, o, r) { return { x: Si(e), y: Si(t), zoom: 1 / 0, id: n, parentId: -1, numPoints: o, properties: r } } function Hb(e, t) { let [n, o] = e.geometry.coordinates; return { x: Si(n / 360 + .5), y: Si(oi(o)), zoom: 1 / 0, index: t, parentId: -1 } } function oc(e) { var t = e.id, n = Ff(e); return { type: "Feature", id: t, properties: n, geometry: { type: "Point", coordinates: [360 * (e.x - .5), 360 * Math.atan(Math.exp((180 - 360 * e.y) * Math.PI / 180)) / Math.PI - 90] } } } function Ff(e) { let t = e.numPoints, n = 1e4 <= t ? `${Math.round(t / 1e3)}k` : 1e3 <= t ? `${Math.round(t / 100) / 10}k` : t; return dr(dr({}, e.properties), { cluster: !0, cluster_id: e.id, point_count: t, point_count_abbreviated: n }) } function oi(e) { return e = Math.sin(e * Math.PI / 180), e = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI, 0 > e ? 0 : 1 < e ? 1 : e } function dr(e, t) { for (let n in t) e[n] = t[n]; return e } function rc(e) { return e.x } function ic(e) { return e.y } class el { constructor({ markers: t, position: n }) { this.markers = t, n && (this._position = n instanceof google.maps.LatLng ? n : new google.maps.LatLng(n)) } get bounds() { if (this.markers.length !== 0 || this._position) return this.markers.reduce((t, n) => t.extend(n.getPosition()), new google.maps.LatLngBounds(this._position, this._position)) } get position() { return this._position || this.bounds.getCenter() } get count() { return this.markers.filter(t => t.getVisible()).length } push(t) { this.markers.push(t) } delete() { this.marker && (this.marker.setMap(null), delete this.marker), this.markers.length = 0 } } class Kb { constructor({ maxZoom: t = 16 }) { this.maxZoom = t } noop({ markers: t }) { return Ub(t) } } let Ub = e => e.map(t => new el({ position: t.getPosition(), markers: [t] })); class Wb extends Kb { constructor(t) { var { maxZoom: n, radius: o = 60 } = t, r = ["maxZoom", "radius"], i = {}, s; for (s in t) Object.prototype.hasOwnProperty.call(t, s) && 0 > r.indexOf(s) && (i[s] = t[s]); if (t != null && typeof Object.getOwnPropertySymbols == "function") { var l = 0; for (s = Object.getOwnPropertySymbols(t); l < s.length; l++)0 > r.indexOf(s[l]) && Object.prototype.propertyIsEnumerable.call(t, s[l]) && (i[s[l]] = t[s[l]]) } super({ maxZoom: n }), this.superCluster = new jb(Object.assign({ maxZoom: this.maxZoom, radius: o }, i)), this.state = { zoom: null } } calculate(t) { let n = !1; if (!Tr(t.markers, this.markers)) { n = !0, this.markers = [...t.markers]; var o = this.markers.map(r => ({ type: "Feature", geometry: { type: "Point", coordinates: [r.getPosition().lng(), r.getPosition().lat()] }, properties: { marker: r } })); this.superCluster.load(o) } return o = { zoom: t.map.getZoom() }, n || this.state.zoom > this.maxZoom && o.zoom > this.maxZoom || (n = n || !Tr(this.state, o)), this.state = o, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n } } cluster({ map: t }) { return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map(this.transformCluster.bind(this)) } transformCluster({ geometry: { coordinates: [t, n] }, properties: o }) { return o.cluster ? new el({ markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map(r => r.properties.marker), position: new google.maps.LatLng({ lat: n, lng: t }) }) : (t = o.marker, new el({ markers: [t], position: t.getPosition() })) } } class Qb { constructor(t, n) { this.markers = { sum: t.length }, t = n.map(r => r.count); let o = t.reduce((r, i) => r + i, 0); this.clusters = { count: n.length, markers: { mean: o / n.length, sum: o, min: Math.min(...t), max: Math.max(...t) } } } } class Gb {
    render({ count: t, position: n }, o) {
        return o = window.btoa(`
  <svg fill="${t > Math.max(10, o.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
    <circle cx="120" cy="120" opacity=".6" r="70" />
    <circle cx="120" cy="120" opacity=".3" r="90" />
    <circle cx="120" cy="120" opacity=".2" r="110" />
  </svg>`), new google.maps.Marker({ position: n, icon: { url: `data:image/svg+xml;base64,${o}`, scaledSize: new google.maps.Size(45, 45) }, label: { text: String(t), color: "rgba(255,255,255,0.9)", fontSize: "12px" }, title: `Cluster of ${t} markers`, zIndex: Number(google.maps.Marker.MAX_ZINDEX) + t })
    }
} class Zl { constructor() { var t = Zl, n = google.maps.OverlayView; for (let o in n.prototype) t.prototype[o] = n.prototype[o] } } var bo, Yl = bo || (bo = {}); Yl.CLUSTERING_BEGIN = "clusteringbegin"; Yl.CLUSTERING_END = "clusteringend"; Yl.CLUSTER_CLICK = "click"; let Zb = (e, t, n) => { n.fitBounds(t.bounds) }; class Yb extends Zl { constructor({ map: t, markers: n = [], algorithm: o = new Wb({}), renderer: r = new Gb, onClusterClick: i = Zb }) { super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = r, this.onClusterClick = i, t && this.setMap(t) } addMarker(t, n) { this.markers.includes(t) || (this.markers.push(t), n || this.render()) } addMarkers(t, n) { t.forEach(o => { this.addMarker(o, !0) }), n || this.render() } removeMarker(t, n) { let o = this.markers.indexOf(t); return o === -1 ? !1 : (t.setMap(null), this.markers.splice(o, 1), n || this.render(), !0) } removeMarkers(t, n) { let o = !1; return t.forEach(r => { o = this.removeMarker(r, !0) || o }), o && !n && this.render(), o } clearMarkers(t) { this.markers.length = 0, t || this.render() } render() { let t = this.getMap(); if (t instanceof google.maps.Map && this.getProjection()) { google.maps.event.trigger(this, bo.CLUSTERING_BEGIN, this); let { clusters: n, changed: o } = this.algorithm.calculate({ markers: this.markers, map: t, mapCanvasProjection: this.getProjection() }); (o || o == null) && (this.reset(), this.clusters = n, this.renderClusters()), google.maps.event.trigger(this, bo.CLUSTERING_END, this) } } onAdd() { this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render() } onRemove() { google.maps.event.removeListener(this.idleListener), this.reset() } reset() { this.markers.forEach(t => t.setMap(null)), this.clusters.forEach(t => t.delete()), this.clusters = [] } renderClusters() { let t = new Qb(this.markers, this.clusters), n = this.getMap(); this.clusters.forEach(o => { o.markers.length === 1 ? o.marker = o.markers[0] : (o.marker = this.renderer.render(o, t), this.onClusterClick && o.marker.addListener("click", r => { google.maps.event.trigger(this, bo.CLUSTER_CLICK, o), this.onClusterClick(r, o, n) })), o.marker.setMap(n) }) } } let sc = Object.values(bo); Ne({ name: "MarkerCluster", props: { options: { type: Object, default: () => ({}) } }, emits: sc, setup(e, { emit: t, expose: n, slots: o }) { let r = z(), i = Le(Mo, z()), s = Le(Bo, z()); return xt(Rf, r), de(i, () => { i.value && (r.value = it(new Yb({ map: i.value, ...e.options })), sc.forEach(l => { var a; (a = r.value) === null || a === void 0 || a.addListener(l, c => t(l, c)) })) }, { immediate: !0 }), Re(() => { var l; r.value && ((l = s.value) === null || l === void 0 || l.event.clearInstanceListeners(r.value), r.value.clearMarkers(), r.value.setMap(null)) }), n({ markerCluster: r }), () => { var l; return (l = o.default) === null || l === void 0 ? void 0 : l.call(o) } } }); var zf = Ne({ inheritAttrs: !1, props: { options: { type: Object, required: !0 } }, setup(e, { slots: t, emit: n }) { let o = z(), r = z(), i = y(() => { var l; return (l = t.default) === null || l === void 0 ? void 0 : l.call(t).some(a => a.type !== gt) }), s = y(() => ({ ...e.options, element: o.value })); return et(() => { r = Io(ki, [], s, n) }), { customMarkerRef: o, customMarker: r, hasSlotContent: i } } }); Ql(`
.custom-marker-wrapper[data-v-b9d5ec8a] {
  display: none;
}
.mapdiv .custom-marker-wrapper[data-v-b9d5ec8a] {
  display: inline-block;
}
`); 
let Jb = Sl(); 
xl("data-v-b9d5ec8a"); 
let Xb = { key: 0, class: "custom-marker-wrapper" }; 
kl(); 
let e0 = Jb(e => e.hasSlotContent ? (Oe(), Qe("div", Xb, [K("div", Ll({ ref: "customMarkerRef", style: { cursor: e.$attrs.onClick ? "pointer" : void 0 } }, 
e.$attrs), 
[zi(e.$slots, "default", {}, void 0, !0)], 16)])) : Lr("v-if", !0)); 
zf.render = e0; zf.__scopeId = "data-v-b9d5ec8a"; 
Ne({ name: "HeatmapLayer", props: { options: { type: Object, default: () => ({}) } }, 
setup(e) { 
    let t = z(), n = Le(Mo, z()), o = Le(Bo, z()); 
    return de([n, () => e.options], ([, r], [i, s]) => { var l; if (i = !Tr(r, s) || n.value !== i, n.value && o.value && i) { 
        if (r = structuredClone(r), r.data && !(r.data instanceof o.value.MVCArray)) { 
            let a = o.value.LatLng; r.data = (l = r.data) === null || l === void 0 ? void 0 : l.map(c => c instanceof a || "location" in c && (c.location instanceof a || c.location === null) ? c : "location" in c ? { ...c, location: new a(c.location) } : new a(c)) } t.value ? t.value.setOptions(r) : t.value = it(new o.value.visualization.HeatmapLayer({ ...r, map: n.value })) } }, { immediate: !0 }), Re(() => { t.value && t.value.setMap(null) }), { heatmapLayer: t } }, render: () => null }); const tn = Object.create(null); tn.open = "0"; tn.close = "1"; tn.ping = "2"; tn.pong = "3"; tn.message = "4"; tn.upgrade = "5"; tn.noop = "6"; const ri = Object.create(null); Object.keys(tn).forEach(e => { ri[tn[e]] = e }); const t0 = { type: "error", data: "parser error" }, n0 = typeof Blob == "function" || typeof Blob != "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", o0 = typeof ArrayBuffer == "function", r0 = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer, Vf = ({ type: e, data: t }, n, o) => n0 && t instanceof Blob ? n ? o(t) : lc(t, o) : o0 && (t instanceof ArrayBuffer || r0(t)) ? n ? o(t) : lc(new Blob([t]), o) : o(tn[e] + (t || "")), lc = (e, t) => { const n = new FileReader; return n.onload = function () { const o = n.result.split(",")[1]; t("b" + (o || "")) }, n.readAsDataURL(e) }, ac = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", er = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256); for (let e = 0; e < ac.length; e++)er[ac.charCodeAt(e)] = e; const i0 = e => { let t = e.length * .75, n = e.length, o, r = 0, i, s, l, a; e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--); const c = new ArrayBuffer(t), u = new Uint8Array(c); for (o = 0; o < n; o += 4)i = er[e.charCodeAt(o)], s = er[e.charCodeAt(o + 1)], l = er[e.charCodeAt(o + 2)], a = er[e.charCodeAt(o + 3)], u[r++] = i << 2 | s >> 4, u[r++] = (s & 15) << 4 | l >> 2, u[r++] = (l & 3) << 6 | a & 63; return c }, s0 = typeof ArrayBuffer == "function", Nf = (e, t) => { if (typeof e != "string") return { type: "message", data: jf(e, t) }; const n = e.charAt(0); return n === "b" ? { type: "message", data: l0(e.substring(1), t) } : ri[n] ? e.length > 1 ? { type: ri[n], data: e.substring(1) } : { type: ri[n] } : t0 }, l0 = (e, t) => { if (s0) { const n = i0(e); return jf(n, t) } else return { base64: !0, data: e } }, jf = (e, t) => { switch (t) { case "blob": return e instanceof ArrayBuffer ? new Blob([e]) : e; case "arraybuffer": default: return e } }, Df = String.fromCharCode(30), a0 = (e, t) => { const n = e.length, o = new Array(n); let r = 0; e.forEach((i, s) => { Vf(i, !1, l => { o[s] = l, ++r === n && t(o.join(Df)) }) }) }, u0 = (e, t) => { const n = e.split(Df), o = []; for (let r = 0; r < n.length; r++) { const i = Nf(n[r], t); if (o.push(i), i.type === "error") break } return o }, Hf = 4; function Xe(e) { if (e) return c0(e) } function c0(e) { for (var t in Xe.prototype) e[t] = Xe.prototype[t]; return e } Xe.prototype.on = Xe.prototype.addEventListener = function (e, t) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this }; Xe.prototype.once = function (e, t) { function n() { this.off(e, n), t.apply(this, arguments) } return n.fn = t, this.on(e, n), this }; Xe.prototype.off = Xe.prototype.removeListener = Xe.prototype.removeAllListeners = Xe.prototype.removeEventListener = function (e, t) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var n = this._callbacks["$" + e]; if (!n) return this; if (arguments.length == 1) return delete this._callbacks["$" + e], this; for (var o, r = 0; r < n.length; r++)if (o = n[r], o === t || o.fn === t) { n.splice(r, 1); break } return n.length === 0 && delete this._callbacks["$" + e], this }; Xe.prototype.emit = function (e) { this._callbacks = this._callbacks || {}; for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], o = 1; o < arguments.length; o++)t[o - 1] = arguments[o]; if (n) { n = n.slice(0); for (var o = 0, r = n.length; o < r; ++o)n[o].apply(this, t) } return this }; Xe.prototype.emitReserved = Xe.prototype.emit; Xe.prototype.listeners = function (e) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [] }; Xe.prototype.hasListeners = function (e) { return !!this.listeners(e).length }; const kn = (() => typeof self != "undefined" ? self : typeof window != "undefined" ? window : Function("return this")())(); function Kf(e, ...t) { return t.reduce((n, o) => (e.hasOwnProperty(o) && (n[o] = e[o]), n), {}) } const d0 = setTimeout, f0 = clearTimeout; function Ji(e, t) { t.useNativeTimers ? (e.setTimeoutFn = d0.bind(kn), e.clearTimeoutFn = f0.bind(kn)) : (e.setTimeoutFn = setTimeout.bind(kn), e.clearTimeoutFn = clearTimeout.bind(kn)) } const h0 = 1.33; function m0(e) { return typeof e == "string" ? v0(e) : Math.ceil((e.byteLength || e.size) * h0) } function v0(e) { let t = 0, n = 0; for (let o = 0, r = e.length; o < r; o++)t = e.charCodeAt(o), t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (o++, n += 4); return n } class p0 extends Error { constructor(t, n, o) { super(t), this.description = n, this.context = o, this.type = "TransportError" } } class Uf extends Xe { constructor(t) { super(), this.writable = !1, Ji(this, t), this.opts = t, this.query = t.query, this.readyState = "", this.socket = t.socket } onError(t, n, o) { return super.emitReserved("error", new p0(t, n, o)), this } open() { return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(t) { this.readyState === "open" && this.write(t) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(t) { const n = Nf(t, this.socket.binaryType); this.onPacket(n) } onPacket(t) { super.emitReserved("packet", t) } onClose(t) { this.readyState = "closed", super.emitReserved("close", t) } } const Wf = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), tl = 64, g0 = {}; let uc = 0, Yr = 0, cc; function dc(e) { let t = ""; do t = Wf[e % tl] + t, e = Math.floor(e / tl); while (e > 0); return t } function Qf() { const e = dc(+new Date); return e !== cc ? (uc = 0, cc = e) : e + "." + dc(uc++) } for (; Yr < tl; Yr++)g0[Wf[Yr]] = Yr; function Gf(e) { let t = ""; for (let n in e) e.hasOwnProperty(n) && (t.length && (t += "&"), t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n])); return t } function y0(e) { let t = {}, n = e.split("&"); for (let o = 0, r = n.length; o < r; o++) { let i = n[o].split("="); t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]) } return t } let Zf = !1; try { Zf = typeof XMLHttpRequest != "undefined" && "withCredentials" in new XMLHttpRequest } catch { } const b0 = Zf; function Yf(e) { const t = e.xdomain; try { if (typeof XMLHttpRequest != "undefined" && (!t || b0)) return new XMLHttpRequest } catch { } if (!t) try { return new kn[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch { } } function _0() { } const w0 = function () { return new Yf({ xdomain: !1 }).responseType != null }(); class C0 extends Uf { constructor(t) { if (super(t), this.polling = !1, typeof location != "undefined") { const o = location.protocol === "https:"; let r = location.port; r || (r = o ? "443" : "80"), this.xd = typeof location != "undefined" && t.hostname !== location.hostname || r !== t.port, this.xs = t.secure !== o } const n = t && t.forceBase64; this.supportsBinary = w0 && !n } get name() { return "polling" } doOpen() { this.poll() } pause(t) { this.readyState = "pausing"; const n = () => { this.readyState = "paused", t() }; if (this.polling || !this.writable) { let o = 0; this.polling && (o++, this.once("pollComplete", function () { --o || n() })), this.writable || (o++, this.once("drain", function () { --o || n() })) } else n() } poll() { this.polling = !0, this.doPoll(), this.emitReserved("poll") } onData(t) { const n = o => { if (this.readyState === "opening" && o.type === "open" && this.onOpen(), o.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(o) }; u0(t, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll()) } doClose() { const t = () => { this.write([{ type: "close" }]) }; this.readyState === "open" ? t() : this.once("open", t) } write(t) { this.writable = !1, a0(t, n => { this.doWrite(n, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { let t = this.query || {}; const n = this.opts.secure ? "https" : "http"; let o = ""; this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Qf()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (n === "https" && Number(this.opts.port) !== 443 || n === "http" && Number(this.opts.port) !== 80) && (o = ":" + this.opts.port); const r = Gf(t), i = this.opts.hostname.indexOf(":") !== -1; return n + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + o + this.opts.path + (r.length ? "?" + r : "") } request(t = {}) { return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Jt(this.uri(), t) } doWrite(t, n) { const o = this.request({ method: "POST", data: t }); o.on("success", n), o.on("error", (r, i) => { this.onError("xhr post error", r, i) }) } doPoll() { const t = this.request(); t.on("data", this.onData.bind(this)), t.on("error", (n, o) => { this.onError("xhr poll error", n, o) }), this.pollXhr = t } } class Jt extends Xe { constructor(t, n) { super(), Ji(this, n), this.opts = n, this.method = n.method || "GET", this.uri = t, this.async = n.async !== !1, this.data = n.data !== void 0 ? n.data : null, this.create() } create() { const t = Kf(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs; const n = this.xhr = new Yf(t); try { n.open(this.method, this.uri, this.async); try { if (this.opts.extraHeaders) { n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0); for (let o in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(o) && n.setRequestHeader(o, this.opts.extraHeaders[o]) } } catch { } if (this.method === "POST") try { n.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch { } try { n.setRequestHeader("Accept", "*/*") } catch { } "withCredentials" in n && (n.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout), n.onreadystatechange = () => { n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => { this.onError(typeof n.status == "number" ? n.status : 0) }, 0)) }, n.send(this.data) } catch (o) { this.setTimeoutFn(() => { this.onError(o) }, 0); return } typeof document != "undefined" && (this.index = Jt.requestsCount++, Jt.requests[this.index] = this) } onError(t) { this.emitReserved("error", t, this.xhr), this.cleanup(!0) } cleanup(t) { if (!(typeof this.xhr == "undefined" || this.xhr === null)) { if (this.xhr.onreadystatechange = _0, t) try { this.xhr.abort() } catch { } typeof document != "undefined" && delete Jt.requests[this.index], this.xhr = null } } onLoad() { const t = this.xhr.responseText; t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup()) } abort() { this.cleanup() } } Jt.requestsCount = 0; Jt.requests = {}; if (typeof document != "undefined") { if (typeof attachEvent == "function") attachEvent("onunload", fc); else if (typeof addEventListener == "function") { const e = "onpagehide" in kn ? "pagehide" : "unload"; addEventListener(e, fc, !1) } } function fc() { for (let e in Jt.requests) Jt.requests.hasOwnProperty(e) && Jt.requests[e].abort() } const Jf = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? t => Promise.resolve().then(t) : (t, n) => n(t, 0))(), Jr = kn.WebSocket || kn.MozWebSocket, hc = !0, x0 = "arraybuffer", mc = typeof navigator != "undefined" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative"; class k0 extends Uf { constructor(t) { super(t), this.supportsBinary = !t.forceBase64 } get name() { return "websocket" } doOpen() { if (!this.check()) return; const t = this.uri(), n = this.opts.protocols, o = mc ? {} : Kf(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (o.headers = this.opts.extraHeaders); try { this.ws = hc && !mc ? n ? new Jr(t, n) : new Jr(t) : new Jr(t, n, o) } catch (r) { return this.emitReserved("error", r) } this.ws.binaryType = this.socket.binaryType || x0, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = t => this.onClose({ description: "websocket connection closed", context: t }), this.ws.onmessage = t => this.onData(t.data), this.ws.onerror = t => this.onError("websocket error", t) } write(t) { this.writable = !1; for (let n = 0; n < t.length; n++) { const o = t[n], r = n === t.length - 1; Vf(o, this.supportsBinary, i => { const s = {}; try { hc && this.ws.send(i) } catch { } r && Jf(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws != "undefined" && (this.ws.close(), this.ws = null) } uri() { let t = this.query || {}; const n = this.opts.secure ? "wss" : "ws"; let o = ""; this.opts.port && (n === "wss" && Number(this.opts.port) !== 443 || n === "ws" && Number(this.opts.port) !== 80) && (o = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = Qf()), this.supportsBinary || (t.b64 = 1); const r = Gf(t), i = this.opts.hostname.indexOf(":") !== -1; return n + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + o + this.opts.path + (r.length ? "?" + r : "") } check() { return !!Jr } } const S0 = { websocket: k0, polling: C0 }, E0 = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, q0 = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function nl(e) { const t = e, n = e.indexOf("["), o = e.indexOf("]"); n != -1 && o != -1 && (e = e.substring(0, n) + e.substring(n, o).replace(/:/g, ";") + e.substring(o, e.length)); let r = E0.exec(e || ""), i = {}, s = 14; for (; s--;)i[q0[s]] = r[s] || ""; return n != -1 && o != -1 && (i.source = t, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = T0(i, i.path), i.queryKey = P0(i, i.query), i } function T0(e, t) { const n = /\/{2,9}/g, o = t.replace(n, "/").split("/"); return (t.slice(0, 1) == "/" || t.length === 0) && o.splice(0, 1), t.slice(-1) == "/" && o.splice(o.length - 1, 1), o } function P0(e, t) { const n = {}; return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (o, r, i) { r && (n[r] = i) }), n } class Cn extends Xe { constructor(t, n = {}) { super(), t && typeof t == "object" && (n = t, t = null), t ? (t = nl(t), n.hostname = t.host, n.secure = t.protocol === "https" || t.protocol === "wss", n.port = t.port, t.query && (n.query = t.query)) : n.host && (n.hostname = nl(n.host).host), Ji(this, n), this.secure = n.secure != null ? n.secure : typeof location != "undefined" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location != "undefined" ? location.hostname : "localhost"), this.port = n.port || (typeof location != "undefined" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = y0(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => { this.onClose("transport close", { description: "network connection lost" }) }, addEventListener("offline", this.offlineEventListener, !1))), this.open() } createTransport(t) { const n = Object.assign({}, this.opts.query); n.EIO = Hf, n.transport = t, this.id && (n.sid = this.id); const o = Object.assign({}, this.opts.transportOptions[t], this.opts, { query: n, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }); return new S0[t](o) } open() { let t; if (this.opts.rememberUpgrade && Cn.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) t = "websocket"; else if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } else t = this.transports[0]; this.readyState = "opening"; try { t = this.createTransport(t) } catch { this.transports.shift(), this.open(); return } t.open(), this.setTransport(t) } setTransport(t) { this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n => this.onClose("transport close", n)) } probe(t) { let n = this.createTransport(t), o = !1; Cn.priorWebsocketSuccess = !1; const r = () => { o || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", d => { if (!o) if (d.type === "pong" && d.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", n), !n) return; Cn.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => { o || this.readyState !== "closed" && (u(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush()) }) } else { const f = new Error("probe error"); f.transport = n.name, this.emitReserved("upgradeError", f) } })) }; function i() { o || (o = !0, u(), n.close(), n = null) } const s = d => { const f = new Error("probe error: " + d); f.transport = n.name, i(), this.emitReserved("upgradeError", f) }; function l() { s("transport closed") } function a() { s("socket closed") } function c(d) { n && d.name !== n.name && i() } const u = () => { n.removeListener("open", r), n.removeListener("error", s), n.removeListener("close", l), this.off("close", a), this.off("upgrading", c) }; n.once("open", r), n.once("error", s), n.once("close", l), this.once("close", a), this.once("upgrading", c), n.open() } onOpen() { if (this.readyState = "open", Cn.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) { let t = 0; const n = this.upgrades.length; for (; t < n; t++)this.probe(this.upgrades[t]) } } onPacket(t) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) { case "open": this.onHandshake(JSON.parse(t.data)); break; case "ping": this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"); break; case "error": const n = new Error("server error"); n.code = t.data, this.onError(n); break; case "message": this.emitReserved("data", t.data), this.emitReserved("message", t.data); break } } onHandshake(t) { this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout() } resetPingTimeout() { this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => { this.onClose("ping timeout") }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() } onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const t = this.getWritablePackets(); this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush") } } getWritablePackets() { if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let n = 1; for (let o = 0; o < this.writeBuffer.length; o++) { const r = this.writeBuffer[o].data; if (r && (n += m0(r)), o > 0 && n > this.maxPayload) return this.writeBuffer.slice(0, o); n += 2 } return this.writeBuffer } write(t, n, o) { return this.sendPacket("message", t, n, o), this } send(t, n, o) { return this.sendPacket("message", t, n, o), this } sendPacket(t, n, o, r) { if (typeof n == "function" && (r = n, n = void 0), typeof o == "function" && (r = o, o = null), this.readyState === "closing" || this.readyState === "closed") return; o = o || {}, o.compress = o.compress !== !1; const i = { type: t, data: n, options: o }; this.emitReserved("packetCreate", i), this.writeBuffer.push(i), r && this.once("flush", r), this.flush() } close() { const t = () => { this.onClose("forced close"), this.transport.close() }, n = () => { this.off("upgrade", n), this.off("upgradeError", n), t() }, o = () => { this.once("upgrade", n), this.once("upgradeError", n) }; return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? o() : t() }) : this.upgrading ? o() : t()), this } onError(t) { Cn.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t) } onClose(t, n) { (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, n), this.writeBuffer = [], this.prevBufferLen = 0) } filterUpgrades(t) { const n = []; let o = 0; const r = t.length; for (; o < r; o++)~this.transports.indexOf(t[o]) && n.push(t[o]); return n } } Cn.protocol = Hf; function A0(e, t = "", n) { let o = e; n = n || typeof location != "undefined" && location, e == null && (e = n.protocol + "//" + n.host), typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e), /^(https?|wss?):\/\//.test(e) || (typeof n != "undefined" ? e = n.protocol + "//" + e : e = "https://" + e), o = nl(e)), o.port || (/^(http|ws)$/.test(o.protocol) ? o.port = "80" : /^(http|ws)s$/.test(o.protocol) && (o.port = "443")), o.path = o.path || "/"; const i = o.host.indexOf(":") !== -1 ? "[" + o.host + "]" : o.host; return o.id = o.protocol + "://" + i + ":" + o.port + t, o.href = o.protocol + "://" + i + (n && n.port === o.port ? "" : ":" + o.port), o } const O0 = typeof ArrayBuffer == "function", R0 = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer, Xf = Object.prototype.toString, L0 = typeof Blob == "function" || typeof Blob != "undefined" && Xf.call(Blob) === "[object BlobConstructor]", $0 = typeof File == "function" || typeof File != "undefined" && Xf.call(File) === "[object FileConstructor]"; function Jl(e) { return O0 && (e instanceof ArrayBuffer || R0(e)) || L0 && e instanceof Blob || $0 && e instanceof File } function ii(e, t) { if (!e || typeof e != "object") return !1; if (Array.isArray(e)) { for (let n = 0, o = e.length; n < o; n++)if (ii(e[n])) return !0; return !1 } if (Jl(e)) return !0; if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1) return ii(e.toJSON(), !0); for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && ii(e[n])) return !0; return !1 } function M0(e) { const t = [], n = e.data, o = e; return o.data = ol(n, t), o.attachments = t.length, { packet: o, buffers: t } } function ol(e, t) { if (!e) return e; if (Jl(e)) { const n = { _placeholder: !0, num: t.length }; return t.push(e), n } else if (Array.isArray(e)) { const n = new Array(e.length); for (let o = 0; o < e.length; o++)n[o] = ol(e[o], t); return n } else if (typeof e == "object" && !(e instanceof Date)) { const n = {}; for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && (n[o] = ol(e[o], t)); return n } return e } function B0(e, t) { return e.data = rl(e.data, t), delete e.attachments, e } function rl(e, t) { if (!e) return e; if (e && e._placeholder === !0) { if (typeof e.num == "number" && e.num >= 0 && e.num < t.length) return t[e.num]; throw new Error("illegal attachments") } else if (Array.isArray(e)) for (let n = 0; n < e.length; n++)e[n] = rl(e[n], t); else if (typeof e == "object") for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (e[n] = rl(e[n], t)); return e } const I0 = 5; var Pe; (function (e) { e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK" })(Pe || (Pe = {})); class F0 { constructor(t) { this.replacer = t } encode(t) { return (t.type === Pe.EVENT || t.type === Pe.ACK) && ii(t) ? this.encodeAsBinary({ type: t.type === Pe.EVENT ? Pe.BINARY_EVENT : Pe.BINARY_ACK, nsp: t.nsp, data: t.data, id: t.id }) : [this.encodeAsString(t)] } encodeAsString(t) { let n = "" + t.type; return (t.type === Pe.BINARY_EVENT || t.type === Pe.BINARY_ACK) && (n += t.attachments + "-"), t.nsp && t.nsp !== "/" && (n += t.nsp + ","), t.id != null && (n += t.id), t.data != null && (n += JSON.stringify(t.data, this.replacer)), n } encodeAsBinary(t) { const n = M0(t), o = this.encodeAsString(n.packet), r = n.buffers; return r.unshift(o), r } } class Xl extends Xe { constructor(t) { super(), this.reviver = t } add(t) { let n; if (typeof t == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); n = this.decodeString(t); const o = n.type === Pe.BINARY_EVENT; o || n.type === Pe.BINARY_ACK ? (n.type = o ? Pe.EVENT : Pe.ACK, this.reconstructor = new z0(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n) } else if (Jl(t) || t.base64) if (this.reconstructor) n = this.reconstructor.takeBinaryData(t), n && (this.reconstructor = null, super.emitReserved("decoded", n)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + t) } decodeString(t) { let n = 0; const o = { type: Number(t.charAt(0)) }; if (Pe[o.type] === void 0) throw new Error("unknown packet type " + o.type); if (o.type === Pe.BINARY_EVENT || o.type === Pe.BINARY_ACK) { const i = n + 1; for (; t.charAt(++n) !== "-" && n != t.length;); const s = t.substring(i, n); if (s != Number(s) || t.charAt(n) !== "-") throw new Error("Illegal attachments"); o.attachments = Number(s) } if (t.charAt(n + 1) === "/") { const i = n + 1; for (; ++n && !(t.charAt(n) === "," || n === t.length);); o.nsp = t.substring(i, n) } else o.nsp = "/"; const r = t.charAt(n + 1); if (r !== "" && Number(r) == r) { const i = n + 1; for (; ++n;) { const s = t.charAt(n); if (s == null || Number(s) != s) { --n; break } if (n === t.length) break } o.id = Number(t.substring(i, n + 1)) } if (t.charAt(++n)) { const i = this.tryParse(t.substr(n)); if (Xl.isPayloadValid(o.type, i)) o.data = i; else throw new Error("invalid payload") } return o } tryParse(t) { try { return JSON.parse(t, this.reviver) } catch { return !1 } } static isPayloadValid(t, n) { switch (t) { case Pe.CONNECT: return typeof n == "object"; case Pe.DISCONNECT: return n === void 0; case Pe.CONNECT_ERROR: return typeof n == "string" || typeof n == "object"; case Pe.EVENT: case Pe.BINARY_EVENT: return Array.isArray(n) && n.length > 0; case Pe.ACK: case Pe.BINARY_ACK: return Array.isArray(n) } } destroy() { this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null) } } class z0 { constructor(t) { this.packet = t, this.buffers = [], this.reconPack = t } takeBinaryData(t) { if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) { const n = B0(this.reconPack, this.buffers); return this.finishedReconstruction(), n } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } } var V0 = Object.freeze(Object.defineProperty({ __proto__: null, protocol: I0, get PacketType() { return Pe }, Encoder: F0, Decoder: Xl }, Symbol.toStringTag, { value: "Module" })); function Ft(e, t, n) { return e.on(t, n), function () { e.off(t, n) } } const N0 = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class eh extends Xe { constructor(t, n, o) { super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = n, o && o.auth && (this.auth = o.auth), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const t = this.io; this.subs = [Ft(t, "open", this.onopen.bind(this)), Ft(t, "packet", this.onpacket.bind(this)), Ft(t, "error", this.onerror.bind(this)), Ft(t, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...t) { return t.unshift("message"), this.emit.apply(this, t), this } emit(t, ...n) { if (N0.hasOwnProperty(t)) throw new Error('"' + t.toString() + '" is a reserved event name'); n.unshift(t); const o = { type: Pe.EVENT, data: n }; if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") { const s = this.ids++, l = n.pop(); this._registerAckCallback(s, l), o.id = s } const r = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return this.flags.volatile && (!r || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this } _registerAckCallback(t, n) { const o = this.flags.timeout; if (o === void 0) { this.acks[t] = n; return } const r = this.io.setTimeoutFn(() => { delete this.acks[t]; for (let i = 0; i < this.sendBuffer.length; i++)this.sendBuffer[i].id === t && this.sendBuffer.splice(i, 1); n.call(this, new Error("operation has timed out")) }, o); this.acks[t] = (...i) => { this.io.clearTimeoutFn(r), n.apply(this, [null, ...i]) } } packet(t) { t.nsp = this.nsp, this.io._packet(t) } onopen() { typeof this.auth == "function" ? this.auth(t => { this.packet({ type: Pe.CONNECT, data: t }) }) : this.packet({ type: Pe.CONNECT, data: this.auth }) } onerror(t) { this.connected || this.emitReserved("connect_error", t) } onclose(t, n) { this.connected = !1, delete this.id, this.emitReserved("disconnect", t, n) } onpacket(t) { if (t.nsp === this.nsp) switch (t.type) { case Pe.CONNECT: if (t.data && t.data.sid) { const r = t.data.sid; this.onconnect(r) } else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case Pe.EVENT: case Pe.BINARY_EVENT: this.onevent(t); break; case Pe.ACK: case Pe.BINARY_ACK: this.onack(t); break; case Pe.DISCONNECT: this.ondisconnect(); break; case Pe.CONNECT_ERROR: this.destroy(); const o = new Error(t.data.message); o.data = t.data.data, this.emitReserved("connect_error", o); break } } onevent(t) { const n = t.data || []; t.id != null && n.push(this.ack(t.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n)) } emitEvent(t) { if (this._anyListeners && this._anyListeners.length) { const n = this._anyListeners.slice(); for (const o of n) o.apply(this, t) } super.emit.apply(this, t) } ack(t) { const n = this; let o = !1; return function (...r) { o || (o = !0, n.packet({ type: Pe.ACK, id: t, data: r })) } } onack(t) { const n = this.acks[t.id]; typeof n == "function" && (n.apply(this, t.data), delete this.acks[t.id]) } onconnect(t) { this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect") } emitBuffered() { this.receiveBuffer.forEach(t => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach(t => { this.notifyOutgoingListeners(t), this.packet(t) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(t => t()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: Pe.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(t) { return this.flags.compress = t, this } get volatile() { return this.flags.volatile = !0, this } timeout(t) { return this.flags.timeout = t, this } onAny(t) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this } prependAny(t) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this } offAny(t) { if (!this._anyListeners) return this; if (t) { const n = this._anyListeners; for (let o = 0; o < n.length; o++)if (t === n[o]) return n.splice(o, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(t) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this } prependAnyOutgoing(t) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this } offAnyOutgoing(t) { if (!this._anyOutgoingListeners) return this; if (t) { const n = this._anyOutgoingListeners; for (let o = 0; o < n.length; o++)if (t === n[o]) return n.splice(o, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(t) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const n = this._anyOutgoingListeners.slice(); for (const o of n) o.apply(this, t.data) } } } function Fo(e) { e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0 } Fo.prototype.duration = function () { var e = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var t = Math.random(), n = Math.floor(t * this.jitter * e); e = (Math.floor(t * 10) & 1) == 0 ? e - n : e + n } return Math.min(e, this.max) | 0 }; Fo.prototype.reset = function () { this.attempts = 0 }; Fo.prototype.setMin = function (e) { this.ms = e }; Fo.prototype.setMax = function (e) { this.max = e }; Fo.prototype.setJitter = function (e) { this.jitter = e }; class il extends Xe { constructor(t, n) { var o; super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (n = t, t = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, Ji(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((o = n.randomizationFactor) !== null && o !== void 0 ? o : .5), this.backoff = new Fo({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = t; const r = n.parser || V0; this.encoder = new r.Encoder, this.decoder = new r.Decoder, this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open() } reconnection(t) { return arguments.length ? (this._reconnection = !!t, this) : this._reconnection } reconnectionAttempts(t) { return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this) } reconnectionDelay(t) { var n; return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (n = this.backoff) === null || n === void 0 || n.setMin(t), this) } randomizationFactor(t) { var n; return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (n = this.backoff) === null || n === void 0 || n.setJitter(t), this) } reconnectionDelayMax(t) { var n; return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (n = this.backoff) === null || n === void 0 || n.setMax(t), this) } timeout(t) { return arguments.length ? (this._timeout = t, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(t) { if (~this._readyState.indexOf("open")) return this; this.engine = new Cn(this.uri, this.opts); const n = this.engine, o = this; this._readyState = "opening", this.skipReconnect = !1; const r = Ft(n, "open", function () { o.onopen(), t && t() }), i = Ft(n, "error", s => { o.cleanup(), o._readyState = "closed", this.emitReserved("error", s), t ? t(s) : o.maybeReconnectOnOpen() }); if (this._timeout !== !1) { const s = this._timeout; s === 0 && r(); const l = this.setTimeoutFn(() => { r(), n.close(), n.emit("error", new Error("timeout")) }, s); this.opts.autoUnref && l.unref(), this.subs.push(function () { clearTimeout(l) }) } return this.subs.push(r), this.subs.push(i), this } connect(t) { return this.open(t) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); const t = this.engine; this.subs.push(Ft(t, "ping", this.onping.bind(this)), Ft(t, "data", this.ondata.bind(this)), Ft(t, "error", this.onerror.bind(this)), Ft(t, "close", this.onclose.bind(this)), Ft(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(t) { try { this.decoder.add(t) } catch (n) { this.onclose("parse error", n) } } ondecoded(t) { Jf(() => { this.emitReserved("packet", t) }, this.setTimeoutFn) } onerror(t) { this.emitReserved("error", t) } socket(t, n) { let o = this.nsps[t]; return o || (o = new eh(this, t, n), this.nsps[t] = o), o } _destroy(t) { const n = Object.keys(this.nsps); for (const o of n) if (this.nsps[o].active) return; this._close() } _packet(t) { const n = this.encoder.encode(t); for (let o = 0; o < n.length; o++)this.engine.write(n[o], t.options) } cleanup() { this.subs.forEach(t => t()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close() } disconnect() { return this._close() } onclose(t, n) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, n), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const t = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const n = this.backoff.duration(); this._reconnecting = !0; const o = this.setTimeoutFn(() => { t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open(r => { r ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", r)) : t.onreconnect() })) }, n); this.opts.autoUnref && o.unref(), this.subs.push(function () { clearTimeout(o) }) } } onreconnect() { const t = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t) } } const Qo = {}; function fr(e, t) { typeof e == "object" && (t = e, e = void 0), t = t || {}; const n = A0(e, t.path || "/socket.io"), o = n.source, r = n.id, i = n.path, s = Qo[r] && i in Qo[r].nsps, l = t.forceNew || t["force new connection"] || t.multiplex === !1 || s; let a; return l ? a = new il(o, t) : (Qo[r] || (Qo[r] = new il(o, t)), a = Qo[r]), n.query && !t.query && (t.query = n.queryKey), a.socket(n.path, t) } Object.assign(fr, { Manager: il, Socket: eh, io: fr, connect: fr }); const on = zp("counter", { state: () => ({ counter: 0, setShow: !1 }), getters: { doubleCount: e => e.counter * 2 }, actions: { increment() { this.counter++ } } }); const j0 = Ne({ components: { GoogleMap: Yi, Polyline: Mf, Marker: $f, CustomControl: Gl }, setup() { const e = { url: "https://ruta.carnavaldeoruroacfo.org/", title: "Ruta del Carnaval de Oruro 2023", description: "Vive la experiencia del Carnaval de Oruro 2023", quote: "Vive la experiencia del Carnaval de Oruro 2023", hashtags: "Ruta,Carnaval,Oruro", twitterUser: "adimer" }, t = [{ network: "email", name: "Email", icon: "far fah fa-lg fa-envelope", color: "#333333" }, { network: "facebook", name: "Facebook", icon: "fab fah fa-lg fa-facebook-f", color: "#1877f2" }, { network: "skype", name: "Skype", icon: "fab fah fa-lg fa-skype", color: "#00aff0" }, { network: "sms", name: "SMS", icon: "far fah fa-lg fa-comment-dots", color: "#333333" }, { network: "telegram", name: "Telegram", icon: "fab fah fa-lg fa-telegram-plane", color: "#0088cc" }, { network: "twitter", name: "Twitter", icon: "fab fah fa-lg fa-twitter", color: "#1da1f2" }, { network: "whatsapp", name: "Whatsapp", icon: "fab fah fa-lg fa-whatsapp", color: "#25d366" }], n = on(), o = z([]), r = z([]), i = z([]), s = z({}), l = z(0), a = z(0), c = z(""), d = fr("https://sruta.carnavaldeoruroacfo.org/"), f = z(!1), h = z(!1), v = "https://bruta.carnavaldeoruroacfo.org/api/", x = { lat: -17.97, lng: -67.1111 }, A = { path: [{ lat: -17.9612296067391, lng: -67.10803475010364 }, { lat: -17.961445119004555, lng: -67.10603530174386 }, { lat: -17.96232282916619, lng: -67.10629282032106 }, { lat: -17.968323800452232, lng: -67.10788085154705 }, { lat: -17.971662120760836, lng: -67.10897768934925 }, { lat: -17.971242566549805, lng: -67.11073501577758 }, { lat: -17.970119969911718, lng: -67.11444757526542 }, { lat: -17.969288170678904, lng: -67.11418543294249 }, { lat: -17.96916065440438, lng: -67.11502699206409 }, { lat: -17.969895449728007, lng: -67.11526305075984 }, { lat: -17.969201476446962, lng: -67.11785969641318 }, { lat: -17.968323800452232, lng: -67.11760217783599 }, { lat: -17.968038044536293, lng: -67.1180742952275 }, { lat: -17.967323652515017, lng: -67.11785951304016 }, { lat: -17.96709912898689, lng: -67.11809575510893 }, { lat: -17.967242007761914, lng: -67.11841765333043 }, { lat: -17.967446120097293, lng: -67.11873955155191 }], geodesic: !1, clickable: !1, strokeColor: "#4998FB", strokeOpacity: .8, strokeWeight: 10 }, g = z(""), m = z(!1); return { keyApi: "AIzaSyDodySSKALGcAIxLK3Zo2tKa3pSbpbrGmw", type: g, boolAdmin: m, center: x, flightPath: A, sets: o, sets2: r, lat: l, lng: a, url: v, setDialog: f, set: s, sets1: i, store: n, sharing: e, networks: t, socket: d, setShowDialog: h, address: c } }, created() { this.$route.params.admin === "admin" && (this.boolAdmin = !0), this.store.setShow || (this.store.setShow = !0, this.socket.on("setChange", e => { console.log(e), this.setsGet() })), this.setsGet(), this.$api.get("sets").then(e => { this.sets2 = [], this.sets1 = [], e.data.forEach(t => { this.sets1.push({ label: t.name, value: t.id }), this.sets2.push({ lat: parseFloat(t.lat), lng: parseFloat(t.lng) }) }), this.set = this.sets1[0] }) }, methods: { setUpdate() { this.$q.loading.show(), this.$api.put(`sets/${this.set.value}`, { lat: this.lat, lng: this.lng }).then(e => { console.log(e.data), this.$q.loading.hide(), this.setDialog = !1 }) }, mapClick(e) { this.boolAdmin && (this.lat = e.latLng.lat(), this.lng = e.latLng.lng(), this.setDialog = !0) }, onDrag(e, t) { e.lat = t.latLng.lat(), e.lng = t.latLng.lng(), this.$api.put("sets/" + e.id, { lat: t.latLng.lat(), lng: t.latLng.lng() }) }, setsGet() { this.$api.get("sets").then(e => { this.sets = e.data }) }, onClick(e) { console.log(e); const t = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${e.lat},${e.lng}&key=AIzaSyDodySSKALGcAIxLK3Zo2tKa3pSbpbrGmw`; console.log(t), this.$api.get(t).then(n => { this.address = n.data.results }), this.setShowDialog = !0, this.set = e } } }), D0 = V("div", { class: "text-h6" }, "Colocar conjunto", -1), H0 = { class: "text-subtitle2" }; function K0(e, t, n, o, r, i) { const s = Pt("Polyline"), l = Pt("Marker"), a = Pt("ShareNetwork"), c = Pt("CustomControl"), u = Pt("GoogleMap"); return Oe(), Qe(nn, null, { default: ae(() => [K(u, { onClick: e.mapClick, "api-key": e.keyApi, style: { width: "100%", height: "85vh" }, center: e.center, zoom: 15 }, { default: ae(() => [K(s, { options: e.flightPath }, null, 8, ["options"]), (Oe(!0), Yt(Ue, null, po(e.sets, d => (Oe(), Qe(l, { onDragend: f => e.onDrag(d, f), onClick: f => e.onClick(d), class: "q-pa-none q-ma-none", key: d.id, options: { icon: { url: `${e.url}../${d.imagen}`, scaledSize: { width: 45, height: 45 } }, draggable: e.boolAdmin, position: { lat: parseFloat(d.lat), lng: parseFloat(d.lng) } } }, null, 8, ["onDragend", "onClick", "options"]))), 128)), K(c, { position: "TOP_RIGHT" }, { default: ae(() => [(Oe(!0), Yt(Ue, null, po(e.networks, d => (Oe(), Qe(a, { network: d.network, key: d.network, style: Ar([{ backgroundColor: d.color }, { "text-decoration": "none", border: "0px", margin: "0px", padding: "0px" }]), url: e.sharing.url, title: e.sharing.title, description: e.sharing.description, quote: e.sharing.quote, hashtags: e.sharing.hashtags, twitterUser: e.sharing.twitterUser }, { default: ae(() => [V("i", { class: Or(d.icon) }, null, 2)]), _: 2 }, 1032, ["network", "style", "url", "title", "description", "quote", "hashtags", "twitterUser"]))), 128))]), _: 1 })]), _: 1 }, 8, ["onClick", "api-key", "center"]), K(qo, { modelValue: e.setDialog, "onUpdate:modelValue": t[1] || (t[1] = d => e.setDialog = d) }, { default: ae(() => [K(St, null, { default: ae(() => [K(xi, { onSubmit: fi(e.setUpdate, ["prevent"]) }, { default: ae(() => [K(ze, { class: "row items-center q-pb-none" }, { default: ae(() => [D0, K(bi), Rt(K(We, { flat: "", icon: "close" }, null, 512), [[xn]])]), _: 1 }), K(ze, { class: "q-pt-none" }, { default: ae(() => [K(qb, { outlined: "", modelValue: e.set, "onUpdate:modelValue": t[0] || (t[0] = d => e.set = d), options: e.sets1, label: "Conjunto" }, null, 8, ["modelValue", "options"])]), _: 1 }), K(qr, { align: "right" }, { default: ae(() => [Rt(K(We, { flat: "", label: "Cancelar", color: "primary" }, null, 512), [[xn]]), K(We, { label: "Guardar", color: "primary", type: "submit" })]), _: 1 })]), _: 1 }, 8, ["onSubmit"])]), _: 1 })]), _: 1 }, 8, ["modelValue"]), K(qo, { modelValue: e.setShowDialog, "onUpdate:modelValue": t[2] || (t[2] = d => e.setShowDialog = d) }, { default: ae(() => [K(St, null, { default: ae(() => [K(xi, { onSubmit: fi(e.setUpdate, ["prevent"]) }, { default: ae(() => [K(ze, { class: "row items-center q-pb-none" }, { default: ae(() => [V("div", H0, tr(e.set.name), 1), K(bi), Rt(K(We, { flat: "", icon: "close" }, null, 512), [[xn]])]), _: 1 }), K(ze, { class: "q-pt-none" }, { default: ae(() => [K(Zi, { src: e.set.video }, null, 8, ["src"]), (Oe(!0), Yt(Ue, null, po(e.address, (d, f) => (Oe(), Yt("div", { class: "text-subtitle2", key: f }, [f <= 2 ? (Oe(), Yt(Ue, { key: 0 }, [ie(tr(d.formatted_address), 1)], 64)) : Lr("", !0)]))), 128))]), _: 1 }), K(qr, { align: "right" }, { default: ae(() => [Rt(K(We, { flat: "", label: "Cerrar", "text-color": "red", "no-caps": "", color: "primary" }, null, 512), [[xn]])]), _: 1 })]), _: 1 }, 8, ["onSubmit"])]), _: 1 })]), _: 1 }, 8, ["modelValue"])]), _: 1 }) } var U0 = Mt(j0, [["render", K0]]); const W0 = Ne({ name: "CarnavalItem", setup() { return { counterStore: on() } } }), Q0 = { class: "row" }, G0 = V("div", { class: "col-12 col-md-2" }, null, -1), Z0 = { class: "col-12 col-md-8" }, Y0 = V("div", { class: "col-12 col-md-2" }, null, -1), J0 = { class: "col-12" }, X0 = V("div", { class: "text-h6" }, "Carnaval de Oruro", -1), e_ = V("div", { class: "text-body1" }, " El Carnaval de Oruro es una fiesta de origen ind\xEDgena que se celebra en la ciudad de Oruro, Bolivia, en el mes de febrero. Es considerado como el carnaval m\xE1s grande del mundo, con una duraci\xF3n de 10 d\xEDas, y es declarado Patrimonio Cultural Inmaterial de la Humanidad por la UNESCO en 2001. ", -1); function t_(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", Q0, [G0, V("div", Z0, [K(Zi, { ratio: 16 / 9, src: "https://www.youtube.com/embed/WCfXj2_dj_U" })]), Y0, V("div", J0, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [X0]), _: 1 }), K(ze, null, { default: ae(() => [e_]), _: 1 })]), _: 1 })])])]), _: 1 }) } var n_ = Mt(W0, [["render", t_]]); const o_ = Ne({ name: "EspeciailidadesItem", setup() { return { counterStore: on() } } }), r_ = { class: "row" }, i_ = V("div", { class: "col-12 col-md-2" }, null, -1), s_ = { class: "col-12 col-md-8" }, l_ = V("div", { class: "col-12 col-md-2" }, null, -1), a_ = { class: "col-12" }, u_ = V("div", { class: "text-h6" }, "18 especialidades del carnaval de oruro", -1), c_ = V("div", { class: "text-body1" }, [V("div", { class: "text-h6" }, "La Diablada"), ie(" es un baile que se origin\xF3 en Oruro y es una manifestaci\xF3n material de profunda inspiraci\xF3n religiosa. Esta inspiraci\xF3n vino del descubrimiento de la imagen m\xE1gica del candelero de la Virgen al abrigo de una famosa ladrona llamada Nina, probablemente en el siglo XVIII. Para no enfadar al \u201Ct\xEDo\u201D de la mina, los mineros de Oruro decidieron declarar la virgen patrona del trabajador y los bailarines disfrazados de demonios. La coreograf\xEDa de Diablada representa la lucha entre el bien y el mal y el fracaso de los siete pecados capitales. Este baile se realiza en todas las expresiones art\xEDsticas y folkl\xF3ricas de Bolivia, especialmente en Oruro durante el carnaval. "), V("div", { class: "text-h6" }, "Kantu"), ie(" El kantu es uno de los bailes m\xE1s importantes del peque\xF1o pueblo de La Paz y tambi\xE9n se realiza durante el Carnaval de Oruro. La m\xFAsica y la danza se caracterizan por la melod\xEDa ritual, por lo que se relacionan con diferentes rituales kallawayas. La danza Kantu es b\xE1sicamente un d\xFAo, pero tambi\xE9n pueden participar bailarines solteros. Los movimientos y pasos de baile son similares a los de las kataris (serpientes). La compa\xF1\xEDa de danza m\xE1s importante de Kantu es Kantus Sartananis. "), V("div", { class: "text-h6" }, "Morenada"), ie(" La danza morenada se burla de los blancos, que son retratados como l\xEDderes de esclavos importados en \xC1frica. Algunos trajes muy bordados y coloridos imitan trajes precolombinos. Tambi\xE9n es uno de los bailes de monta\xF1a m\xE1s populares y tambi\xE9n se realiza durante el Carnaval de Oruro. La Morenada se inspir\xF3 en el sufrimiento de los esclavos africanos que fueron llevados a Bolivia para trabajar en las minas de plata de Potos\xED. La enorme lengua de la m\xE1scara oscura est\xE1 destinada a representar el estado f\xEDsico de estos mineros, y el traqueteo de las \u201D Matracas\u201D se asocia a menudo con el sonido de las cadenas de esclavos. cultura a flor de piel en el Carnaval de Oruro "), V("div", { class: "text-h6" }, "Tobas"), ie(" Tobas es una actuaci\xF3n especial de energ\xEDa, un baile \xFAnico, y el impresionante salto realizado por los bailarines dej\xF3 una profunda impresi\xF3n en el p\xFAblico. Este baile \xFAnico se realiza durante las celebraciones religiosas y de otro tipo y durante el Carnaval de Oruro. Mujeres y hombres visten trajes especiales hechos de plumas y telas de colores y bailan en diferentes barrios. Los tobas llevan falda, poncho peque\xF1o y turbante de plumas grande. Los pasos de baile tienen nombres especiales: Bol\xEDvar (salto r\xE1pido y regular); camba (muy \xE1gil, saltando un metro de altura); chucu-chucu (para entretener a la multitud a un ritmo m\xE1s r\xE1pido, de puntillas, casi de rodillas); y cullahui. salto. "), V("div", { class: "text-h6" }, "Capolales"), ie(" Los Caporales es el legado de la danza t\xEDpica boliviana en Espa\xF1a. Este baile es muy popular, especialmente durante los carnavales y celebraciones, como el Carnaval de Oruro. El traje de cabo masculino representar\xE1 a una antigua guardia militar espa\xF1ola. Los bailarines llevan botas de tac\xF3n alto con grandes campanillas, un sombrero en la mano izquierda y un l\xE1tigo en la derecha. Una falda larga femenina est\xE1 compuesta por una minifalda y bragas a juego, pantimedias al tono de piel, zapatos elegantes y un bomb\xEDn atado al cabello. Se utilizan muchas lentejuelas de colores en la ropa Caporal. Los hombres y las mujeres a menudo bailan por separado en bailes de marcha progresivos. Un sinf\xEDn de colores y resplandores iluminan las calles, acompa\xF1ados de la vitalidad y sonrisas de los bailarines. Debido a sus necesidades f\xEDsicas, los Caporales son m\xE1s populares entre los hombres y mujeres j\xF3venes de entre 20 y 30 a\xF1os. La m\xFAsica de Caporales es contagiosa y r\xEDtmica: las personas que ven el espect\xE1culo celebran el baile con palmadas especiales y movimientos de hombros. "), V("div", { class: "text-h6" }, "Incas"), ie(" La danza de los incas representa la antigua \u201Cwanka\u201D (cuento, tragedia) en quechua, y los espa\xF1oles la llevan a cabo desde 1871. El domingo de Carnaval frente al espl\xE9ndido Inti (Dios del Sol), el Hijo del Sol recuerda el tr\xE1gico final de Atahualpa. Hay s\xEDmbolos que representan la nobleza en la ropa. culturadanzas t\xEDpicas de Bolivia "), V("div", { class: "text-h6" }, "Tinkus"), ie(" Tinkus es el nombre de la batalla ritual entre Alasaya y Majasaya. La danza tinku representa el encuentro de dos elementos con direcciones y or\xEDgenes opuestos. La danza se origin\xF3 en Potos\xED. Movimientos coloridos y poderosos, separan a hombres y mujeres, bailan a la ligera con m\xFAsica contagiosa. El grupo m\xE1s importante de bailarines de tinku participa en el Carnaval de Oruro. "), V("div", { class: "text-h6" }, "Kullawada"), ie(" La danza Kullawada recuerda el ritual de un tejedor. Este es un baile festivo popular entre los tejedores aymaras. Participaron hombres y mujeres liderados por Waphuri. Waphuri es una persona importante, grit\xF3 cuando la palabra \u201C\xA1Waphur!\u201D Cambi\xF3 la coreograf\xEDa. Los Wapuri usan una m\xE1scara de yeso y una gran rueca. "), V("div", { class: "text-h6" }, "Llamerada"), ie(" La danza llamerada se llama \u201Cqarwani\u201D en aymara. La danza que realizan los criadores de llamas, alpacas y vicu\xF1as en La Paz tiene un significado religioso para el festival. La danza de la Llamerada es representativa del largo viaje de Sheppard de intercambio de mercanc\xEDas. Carnaval de Oruro Danza devoci\xF3n y oraciones "), V("div", { class: "text-h6" }, "Pujllay"), ie(" Pujllay es un baile de larga data realizado localmente por los lugare\xF1os, llamado Tarabucos. La palabra tarabuco proviene de Tarka Phuku, que significa \u201Clos que soplan o tocan tarkas o moxenos (instrumentos de viento). La figura, el pelo en trenzas y coletas, y la exhibici\xF3n de sus trajes festivos son la elegancia del pasado\u201D. Carnaval, lo llaman Es la temporada de Pujllay. "), V("div", { class: "text-h6" }, "Doctorcitos"), ie(" El baile del peque\xF1o doctor es una s\xE1tira utilizada para los abogados coloniales y sus secretarios. La ropa de los hombres es sombrero de copa, traje negro, camisa blanca, pajarita y bast\xF3n. Las damas vest\xEDan faldas oscuras, chalecos y bastones. "), V("div", { class: "text-h6" }, "Potolos"), ie(" La danza potolos se origin\xF3 en los pueblos de Potolo y Potobamba, la primera en Chuquisaca y la otra en Potos\xED. La danza es una mezcla de movimientos r\xEDtmicos e interesantes movimientos de cadera. Tiene lugar durante el Carnaval de Oruro y otras importantes fiestas religiosas. Tarqueada. La tarqueada es el baile m\xE1s famoso de la regi\xF3n aymara de Bolivia. La danza est\xE1 acompa\xF1ada por el sonido del instrumento de madera Tarqa. Tiene un sonido especial. En la comunidad de Marcas, hay varias formas de coreograf\xEDas diferentes para bailar tarqueada. "), V("div", { class: "text-h6" }, "Waka Tokori"), ie(" La danza de waka tokoris (danza del toro) satiriza la tauromaquia y representa sat\xEDricamente a los conquistadores espa\xF1oles. La danza se origin\xF3 en la localidad de Humara en la provincia de Camacho de La Paz. Umala fue construida como un lugar de descanso para que los espa\xF1oles fueran al Oc\xE9ano Pac\xEDfico mientras transportaban plata. Los bailarines visten muchas polleras (faldas tradicionales) y mueven sus caderas en un ritmo contagioso e hipn\xF3tico, moviendo aproximadamente 10 kilogramos de ropa. Este baile tiene diferentes caracter\xEDsticas, entre ellas: -Un hombre waka con un disfraz de toro (khawas) alrededor de su cintura y colgando una campana alrededor del cuello del toro. \u2013 lechera o gu\xEDas. \u2013 Las k\u2019aisillas o pastora. -J\xF3venes kusillos saltando y gente divertida. -Las jilakatas o bailarinas m\xE1s antiguas. -kausallas o toreros. "), V("div", { class: "text-h6" }, "Kallawayas"), ie(" La danza Kallawayas expresa la relevancia de los \u201Cyatiri\u201D (curanderos) en la comunidad y el profundo respeto en el mundo andino a trav\xE9s de ricas coreograf\xEDas y coloridos trajes. La coreograf\xEDa se conoce como la \u201Cllantucha\u201D en \u201Csuri\u201D, un dosel de plumas de avestruz que utilizan los m\xE9dicos itinerantes para protegerse de las quemaduras solares o las gotas de lluvia en los viajes largos, trayendo as\xED salud espiritual y material a los ayllus. "), V("div", { class: "text-h6" }, "Negritos"), ie(" La danza de Negritos en Bolivia se origin\xF3 a partir de la apreciaci\xF3n mutua de aymaras y negros y la intersecci\xF3n de la cultura y la historia de toda la colonia. Tiene lugar durante el Carnaval de Oruro y otras fiestas importantes. Esta danza es una variante del tundunqui, originaria de las regiones subtropicales de Bolivia. El baile de Negritos atrae y entretiene a los turistas con giros, ritmos, ropa colorida y sombreros. ")], -1); function d_(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", r_, [i_, V("div", s_, [K(Zi, { ratio: 16 / 9, src: "https://www.youtube.com/embed/YsNwaffqxQg" })]), l_, V("div", a_, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [u_]), _: 1 }), K(ze, null, { default: ae(() => [c_]), _: 1 })]), _: 1 })])])]), _: 1 }) } var f_ = Mt(o_, [["render", d_]]); const h_ = Ne({ name: "CarnavalItem", setup() { return { counterStore: on() } } }), m_ = { class: "row" }, v_ = { class: "col-12" }, p_ = V("div", { class: "text-h6" }, "52 conjuntos del carnaval de oruro", -1), g_ = V("div", { class: "text-body1" }, [V("div", { class: "text-bold" }, "La siguiente es una lista de los conjuntos de danzas que fueron documentados en el formulario de candidatura del Carnaval de Oruro a obra maestra del patrimonio oral e intangible de la Humanidad en el a\xF1o 2001, ante la UNESCO."), ie(" Gran Tradicional Aut\xE9ntica Diablada Oruro 1904"), V("br"), ie(' Fraternidad Art\xEDstica y Cultural "La Diablada", 1944'), V("br"), ie(" Conjunto Tradicional Folkl\xF3rico \u201CDiablada Oruro\u201D, 1944"), V("br"), ie(' Diablada "Ferroviaria de Oruro", 1956'), V("br"), ie(' Diablada Art\xEDstica "Urus", 1960'), V("br"), ie(' Conjunto Tradicional Llamerada "Zona Norte", 1921'), V("br"), ie(' Fraternidad Cultural Reyes Morenos "COMIBOL", 1978'), V("br"), ie(' Conjunto Folcl\xF3rico Morenada "Zona Norte", 1913. Inicialmente denominado "Morenada de Oruro"'), V("br"), ie(' Fraternidad Morenada "Central" Oruro, 1924.'), V("br"), ie(' Conjunto Morenada "Mejillones", 1977'), V("br"), ie(' Morenada Metal\xFArgica "ENAF", 1980'), V("br"), ie(" Conjunto Universitario \u201CSURI\u201D U.T.O., 1986"), V("br"), ie(' Zampo\xF1eros "Kory Majthas", 1968'), V("br"), ie(' Centro Tradicional Folcl\xF3rico Cultural "Negritos del Pagador", 1956'), V("br"), ie(' Caporales Infantil "Ignacio Le\xF3n", 1977. Se cre\xF3 por iniciativa de la profesora Martha Gonzales Monta\xF1o, que impart\xEDa el curso de Educaci\xF3n Musical, en el colegio del mismo nombre.'), V("br"), ie(' Fraternidad "Caporales Centralistas", 1975'), V("br"), ie(' Fraternidad Art\xEDstica de Zampo\xF1eros "Hijos del Pagador", 1954'), V("br"), ie(' Fraternidad "Hijos del Sol", 1906'), V("br"), ie(' Conjunto "Khantus Sarta\xF1ani", 1985'), V("br"), ie(" Centro Cultural Aut\xF3ctono \u201CSarta\xF1ani Wasuru Q\u2019ananpi\u201D, 1985"), V("br"), ie(` Tarqueada "Jatun Jall'pa", 1983. Creada`), V("br"), ie(' Gran Tradicional Aut\xE9ntica "Diablada Oruro", 1944'), V("br"), ie(' Conjunto Art\xEDstico Tobas "Uru Uru", 1976'), V("br"), ie(' Gran Conjunto Tradicional "Tobas Zona Sud", 1917'), V("br"), ie(' Conjunto Folcl\xF3rico y Cultural "Phujllay de Oruro", 1982. Fundado por los trabajadores fabriles de la Empresa Textil Rockett.'), V("br"), ie(' Fraternidad Folcl\xF3rica "Cullaguada Oruro", 1968. Su banda "S\xFAper Esta\xF1o" est\xE1 integrada por 50 ejecutantes.'), V("br"), ie(' Centro Cultural "Rikjchary Llajta", 1983'), V("br"), ie(' Conjunto Folcl\xF3rico "Incas Kollasuyo", 1978'), V("br"), ie(' Grupo de Danza Estilizada moderna "Suri Sicuri", 1974'), V("br"), ie(" Fraternidad \u201CHijos del Sol los Incas\u201D, 1906"), V("br"), ie(' Conjunto Negritos "Unidos de la Saya", 1957'), V("br"), ie(' Conjunto Folcl\xF3rico "Llamerada Socav\xF3n", 1968'), V("br"), ie(' Conjunto Folcl\xF3rico "Ahuatiris", 1971'), V("br"), ie(" Conjunto \u201CCullaguada Quirquincho\u201D, 1972"), V("br"), ie(' Conjunto Folcl\xF3rico "Antawara", 1974'), V("br"), ie(' Conjunto Folcl\xF3rico "Sambos Caporales", 1976'), V("br"), ie(' Caporales Reyes de la Tuntuna "ENAF" Reyes Morenos "Ferrari Ghezzi" Conjunto Caporales "San Sim\xF3n", 1978'), V("br"), ie(' Conjunto Aut\xF3ctono "Wititis", 1980'), V("br"), ie(' Fraternidad "Kallawayas Bolivia", 1980'), V("br"), ie(' Conjunto Tinkus "Los Jairas de Oruro", 1981'), V("br"), ie(' Conjunto Folcl\xF3rico Tinkus "Los Tolkas", 1981'), V("br"), ie(' Conjunto Folcl\xF3rico "Doctorcitos Itos", 1981'), V("br"), ie(" Conjunto Folcl\xF3rico \u201CPujllay Oruro\u201D, 1982"), V("br"), ie(' Conjunto Tinkus "Huajchas", 1982'), V("br"), ie(' Conjunto "Potolos Chayanta Jhilancos", 1983'), V("br"), ie(' Fraternidad de Danza Estilizada Moderna "Inti Llajta", 1986'), V("br"), ie(' Fraternidad Caporales "C.B.N.", 1990'), V("br"), ie(' Fraternidad Caporales Modernos "San Jos\xE9" ')], -1); function y_(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", m_, [V("div", v_, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [p_]), _: 1 }), K(ze, null, { default: ae(() => [g_]), _: 1 })]), _: 1 })])])]), _: 1 }) } var b_ = Mt(h_, [["render", y_]]); const ea = { left: !0, right: !0, up: !0, down: !0, horizontal: !0, vertical: !0 }, __ = Object.keys(ea); ea.all = !0; function vc(e) { const t = {}; for (const n of __) e[n] === !0 && (t[n] = !0); return Object.keys(t).length === 0 ? ea : (t.horizontal === !0 ? t.left = t.right = !0 : t.left === !0 && t.right === !0 && (t.horizontal = !0), t.vertical === !0 ? t.up = t.down = !0 : t.up === !0 && t.down === !0 && (t.vertical = !0), t.horizontal === !0 && t.vertical === !0 && (t.all = !0), t) } function pc(e, t) { return t.event === void 0 && e.target !== void 0 && e.target.draggable !== !0 && typeof t.handler == "function" && e.target.nodeName.toUpperCase() !== "INPUT" && (e.qClonedBy === void 0 || e.qClonedBy.indexOf(t.uid) === -1) } function w_(e) { const t = [.06, 6, 50]; return typeof e == "string" && e.length && e.split(":").forEach((n, o) => { const r = parseFloat(n); r && (t[o] = r) }), t } var C_ = Fl({ name: "touch-swipe", beforeMount(e, { value: t, arg: n, modifiers: o }) { if (o.mouse !== !0 && Fe.has.touch !== !0) return; const r = o.mouseCapture === !0 ? "Capture" : "", i = { handler: t, sensitivity: w_(n), direction: vc(o), noop: hn, mouseStart(s) { pc(s, i) && dp(s) && (Nn(i, "temp", [[document, "mousemove", "move", `notPassive${r}`], [document, "mouseup", "end", "notPassiveCapture"]]), i.start(s, !0)) }, touchStart(s) { if (pc(s, i)) { const l = s.target; Nn(i, "temp", [[l, "touchmove", "move", "notPassiveCapture"], [l, "touchcancel", "end", "notPassiveCapture"], [l, "touchend", "end", "notPassiveCapture"]]), i.start(s) } }, start(s, l) { Fe.is.firefox === !0 && ds(e, !0); const a = mi(s); i.event = { x: a.left, y: a.top, time: Date.now(), mouse: l === !0, dir: !1 } }, move(s) { if (i.event === void 0) return; if (i.event.dir !== !1) { Be(s); return } const l = Date.now() - i.event.time; if (l === 0) return; const a = mi(s), c = a.left - i.event.x, u = Math.abs(c), d = a.top - i.event.y, f = Math.abs(d); if (i.event.mouse !== !0) { if (u < i.sensitivity[1] && f < i.sensitivity[1]) { i.end(s); return } } else if (u < i.sensitivity[2] && f < i.sensitivity[2]) return; const h = u / l, v = f / l; i.direction.vertical === !0 && u < f && u < 100 && v > i.sensitivity[0] && (i.event.dir = d < 0 ? "up" : "down"), i.direction.horizontal === !0 && u > f && f < 100 && h > i.sensitivity[0] && (i.event.dir = c < 0 ? "left" : "right"), i.direction.up === !0 && u < f && d < 0 && u < 100 && v > i.sensitivity[0] && (i.event.dir = "up"), i.direction.down === !0 && u < f && d > 0 && u < 100 && v > i.sensitivity[0] && (i.event.dir = "down"), i.direction.left === !0 && u > f && c < 0 && f < 100 && h > i.sensitivity[0] && (i.event.dir = "left"), i.direction.right === !0 && u > f && c > 0 && f < 100 && h > i.sensitivity[0] && (i.event.dir = "right"), i.event.dir !== !1 ? (Be(s), i.event.mouse === !0 && (document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), vf(), i.styleCleanup = x => { i.styleCleanup = void 0, document.body.classList.remove("non-selectable"); const _ = () => { document.body.classList.remove("no-pointer-events--children") }; x === !0 ? setTimeout(_, 50) : _() }), i.handler({ evt: s, touch: i.event.mouse !== !0, mouse: i.event.mouse, direction: i.event.dir, duration: l, distance: { x: u, y: f } })) : i.end(s) }, end(s) { i.event !== void 0 && (sr(i, "temp"), Fe.is.firefox === !0 && ds(e, !1), i.styleCleanup !== void 0 && i.styleCleanup(!0), s !== void 0 && i.event.dir !== !1 && Be(s), i.event = void 0) } }; if (e.__qtouchswipe = i, o.mouse === !0) { const s = o.mouseCapture === !0 || o.mousecapture === !0 ? "Capture" : ""; Nn(i, "main", [[e, "mousedown", "mouseStart", `passive${s}`]]) } Fe.has.touch === !0 && Nn(i, "main", [[e, "touchstart", "touchStart", `passive${o.capture === !0 ? "Capture" : ""}`], [e, "touchmove", "noop", "notPassiveCapture"]]) }, updated(e, t) { const n = e.__qtouchswipe; n !== void 0 && (t.oldValue !== t.value && (typeof t.value != "function" && n.end(), n.handler = t.value), n.direction = vc(t.modifiers)) }, beforeUnmount(e) { const t = e.__qtouchswipe; t !== void 0 && (sr(t, "main"), sr(t, "temp"), Fe.is.firefox === !0 && ds(e, !1), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchswipe) } }); function x_() { const e = new Map; return { getCache: function (t, n) { return e[t] === void 0 ? e[t] = n : e[t] }, getCacheWithFn: function (t, n) { return e[t] === void 0 ? e[t] = n() : e[t] } } } const k_ = { name: { required: !0 }, disable: Boolean }, gc = { setup(e, { slots: t }) { return () => b("div", { class: "q-panel scroll", role: "tabpanel" }, He(t.default)) } }, S_ = { modelValue: { required: !0 }, animated: Boolean, infinite: Boolean, swipeable: Boolean, vertical: Boolean, transitionPrev: String, transitionNext: String, transitionDuration: { type: [String, Number], default: 300 }, keepAlive: Boolean, keepAliveInclude: [String, Array, RegExp], keepAliveExclude: [String, Array, RegExp], keepAliveMax: Number }, E_ = ["update:modelValue", "beforeTransition", "transition"]; function q_() { const { props: e, emit: t, proxy: n } = Ee(), { getCacheWithFn: o } = x_(); let r, i; const s = z(null), l = z(null); function a(M) { const R = e.vertical === !0 ? "up" : "left"; T((n.$q.lang.rtl === !0 ? -1 : 1) * (M.direction === R ? 1 : -1)) } const c = y(() => [[C_, a, void 0, { horizontal: e.vertical !== !0, vertical: e.vertical, mouse: !0 }]]), u = y(() => e.transitionPrev || `slide-${e.vertical === !0 ? "down" : "right"}`), d = y(() => e.transitionNext || `slide-${e.vertical === !0 ? "up" : "left"}`), f = y(() => `--q-transition-duration: ${e.transitionDuration}ms`), h = y(() => typeof e.modelValue == "string" || typeof e.modelValue == "number" ? e.modelValue : String(e.modelValue)), v = y(() => ({ include: e.keepAliveInclude, exclude: e.keepAliveExclude, max: e.keepAliveMax })), x = y(() => e.keepAliveInclude !== void 0 || e.keepAliveExclude !== void 0); de(() => e.modelValue, (M, R) => { const ee = m(M) === !0 ? w(M) : -1; i !== !0 && k(ee === -1 ? 0 : ee < w(R) ? -1 : 1), s.value !== ee && (s.value = ee, t("beforeTransition", M, R), Ie(() => { t("transition", M, R) })) }); function _() { T(1) } function A() { T(-1) } function g(M) { t("update:modelValue", M) } function m(M) { return M != null && M !== "" } function w(M) { return r.findIndex(R => R.props.name === M && R.props.disable !== "" && R.props.disable !== !0) } function S() { return r.filter(M => M.props.disable !== "" && M.props.disable !== !0) } function k(M) { const R = M !== 0 && e.animated === !0 && s.value !== -1 ? "q-transition--" + (M === -1 ? u.value : d.value) : null; l.value !== R && (l.value = R) } function T(M, R = s.value) { let ee = R + M; for (; ee > -1 && ee < r.length;) { const fe = r[ee]; if (fe !== void 0 && fe.props.disable !== "" && fe.props.disable !== !0) { k(M), i = !0, t("update:modelValue", fe.props.name), setTimeout(() => { i = !1 }); return } ee += M } e.infinite === !0 && r.length > 0 && R !== -1 && R !== r.length && T(M, M === -1 ? r.length : -1) } function q() { const M = w(e.modelValue); return s.value !== M && (s.value = M), !0 } function F() { const M = m(e.modelValue) === !0 && q() && r[s.value]; return e.keepAlive === !0 ? [b(Vm, v.value, [b(x.value === !0 ? o(h.value, () => ({ ...gc, name: h.value })) : gc, { key: h.value, style: f.value }, () => M)])] : [b("div", { class: "q-panel scroll", style: f.value, key: h.value, role: "tabpanel" }, [M])] } function B() { if (r.length !== 0) return e.animated === !0 ? [b(fn, { name: l.value }, F)] : F() } function j(M) { return r = Ug(He(M.default, [])).filter(R => R.props !== null && R.props.slot === void 0 && m(R.props.name) === !0), r.length } function $() { return r } return Object.assign(n, { next: _, previous: A, goTo: g }), { panelIndex: s, panelDirectives: c, updatePanelsList: j, updatePanelIndex: q, getPanelContent: B, getEnabledPanels: S, getPanels: $, isValidPanelName: m, keepAliveProps: v, needsUniqueKeepAliveWrapper: x, goToPanelByOffset: T, goToPanel: g, nextPanel: _, previousPanel: A } } var sn = qe({ name: "QCarouselSlide", props: { ...k_, imgSrc: String }, setup(e, { slots: t }) { const n = y(() => e.imgSrc ? { backgroundImage: `url("${e.imgSrc}")` } : {}); return () => b("div", { class: "q-carousel__slide", style: n.value }, He(t.default)) } }); let Go = 0; const T_ = { fullscreen: Boolean, noRouteFullscreenExit: Boolean }, P_ = ["update:fullscreen", "fullscreen"]; function A_() { const e = Ee(), { props: t, emit: n, proxy: o } = e; let r, i, s; const l = z(!1); zl(e) === !0 && de(() => o.$route.fullPath, () => { t.noRouteFullscreenExit !== !0 && u() }), de(() => t.fullscreen, d => { l.value !== d && a() }), de(l, d => { n("update:fullscreen", d), n("fullscreen", d) }); function a() { l.value === !0 ? u() : c() } function c() { l.value !== !0 && (l.value = !0, s = o.$el.parentNode, s.replaceChild(i, o.$el), document.body.appendChild(o.$el), Go++, Go === 1 && document.body.classList.add("q-body--fullscreen-mixin"), r = { handler: u }, wr.add(r)) } function u() { l.value === !0 && (r !== void 0 && (wr.remove(r), r = void 0), s.replaceChild(o.$el, i), l.value = !1, Go = Math.max(0, Go - 1), Go === 0 && (document.body.classList.remove("q-body--fullscreen-mixin"), o.$el.scrollIntoView !== void 0 && setTimeout(() => { o.$el.scrollIntoView() }))) } return ql(() => { i = document.createElement("span") }), et(() => { t.fullscreen === !0 && c() }), Re(u), Object.assign(o, { toggleFullscreen: a, setFullscreen: c, exitFullscreen: u }), { inFullscreen: l, toggleFullscreen: a } } const O_ = ["top", "right", "bottom", "left"], R_ = ["regular", "flat", "outline", "push", "unelevated"]; var L_ = qe({ name: "QCarousel", props: { ...Ut, ...S_, ...T_, transitionPrev: { type: String, default: "fade" }, transitionNext: { type: String, default: "fade" }, height: String, padding: Boolean, controlColor: String, controlTextColor: String, controlType: { type: String, validator: e => R_.includes(e), default: "flat" }, autoplay: [Number, Boolean], arrows: Boolean, prevIcon: String, nextIcon: String, navigation: Boolean, navigationPosition: { type: String, validator: e => O_.includes(e) }, navigationIcon: String, navigationActiveIcon: String, thumbnails: Boolean }, emits: [...P_, ...E_], setup(e, { slots: t }) { const { proxy: { $q: n } } = Ee(), o = Wt(e, n); let r = null, i; const { updatePanelsList: s, getPanelContent: l, panelDirectives: a, goToPanel: c, previousPanel: u, nextPanel: d, getEnabledPanels: f, panelIndex: h } = q_(), { inFullscreen: v } = A_(), x = y(() => v.value !== !0 && e.height !== void 0 ? { height: e.height } : {}), _ = y(() => e.vertical === !0 ? "vertical" : "horizontal"), A = y(() => `q-carousel q-panel-parent q-carousel--with${e.padding === !0 ? "" : "out"}-padding` + (v.value === !0 ? " fullscreen" : "") + (o.value === !0 ? " q-carousel--dark q-dark" : "") + (e.arrows === !0 ? ` q-carousel--arrows-${_.value}` : "") + (e.navigation === !0 ? ` q-carousel--navigation-${S.value}` : "")), g = y(() => { const B = [e.prevIcon || n.iconSet.carousel[e.vertical === !0 ? "up" : "left"], e.nextIcon || n.iconSet.carousel[e.vertical === !0 ? "down" : "right"]]; return e.vertical === !1 && n.lang.rtl === !0 ? B.reverse() : B }), m = y(() => e.navigationIcon || n.iconSet.carousel.navigationIcon), w = y(() => e.navigationActiveIcon || m.value), S = y(() => e.navigationPosition || (e.vertical === !0 ? "right" : "bottom")), k = y(() => ({ color: e.controlColor, textColor: e.controlTextColor, round: !0, [e.controlType]: !0, dense: !0 })); de(() => e.modelValue, () => { e.autoplay && T() }), de(() => e.autoplay, B => { B ? T() : r !== null && (clearTimeout(r), r = null) }); function T() { const B = Ep(e.autoplay) === !0 ? Math.abs(e.autoplay) : 5e3; r !== null && clearTimeout(r), r = setTimeout(() => { r = null, B >= 0 ? d() : u() }, B) } et(() => { e.autoplay && T() }), Re(() => { r !== null && clearTimeout(r) }); function q(B, j) { return b("div", { class: `q-carousel__control q-carousel__navigation no-wrap absolute flex q-carousel__navigation--${B} q-carousel__navigation--${S.value}` + (e.controlColor !== void 0 ? ` text-${e.controlColor}` : "") }, [b("div", { class: "q-carousel__navigation-inner flex flex-center no-wrap" }, f().map(j))]) } function F() { const B = []; if (e.navigation === !0) { const j = t["navigation-icon"] !== void 0 ? t["navigation-icon"] : M => b(We, { key: "nav" + M.name, class: `q-carousel__navigation-icon q-carousel__navigation-icon--${M.active === !0 ? "" : "in"}active`, ...M.btnProps, onClick: M.onClick }), $ = i - 1; B.push(q("buttons", (M, R) => { const ee = M.props.name, fe = h.value === R; return j({ index: R, maxIndex: $, name: ee, active: fe, btnProps: { icon: fe === !0 ? w.value : m.value, size: "sm", ...k.value }, onClick: () => { c(ee) } }) })) } else if (e.thumbnails === !0) { const j = e.controlColor !== void 0 ? ` text-${e.controlColor}` : ""; B.push(q("thumbnails", $ => { const M = $.props; return b("img", { key: "tmb#" + M.name, class: `q-carousel__thumbnail q-carousel__thumbnail--${M.name === e.modelValue ? "" : "in"}active` + j, src: M.imgSrc || M["img-src"], onClick: () => { c(M.name) } }) })) } return e.arrows === !0 && h.value >= 0 && ((e.infinite === !0 || h.value > 0) && B.push(b("div", { key: "prev", class: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${_.value} absolute flex flex-center` }, [b(We, { icon: g.value[0], ...k.value, onClick: u })])), (e.infinite === !0 || h.value < i - 1) && B.push(b("div", { key: "next", class: `q-carousel__control q-carousel__arrow q-carousel__next-arrow q-carousel__next-arrow--${_.value} absolute flex flex-center` }, [b(We, { icon: g.value[1], ...k.value, onClick: d })]))), Lt(t.control, B) } return () => (i = s(t), b("div", { class: A.value, style: x.value }, [Xd("div", { class: "q-carousel__slides-container" }, l(), "sl-cont", e.swipeable, () => a.value)].concat(F()))) } }); const $_ = Ne({ name: "PhotoItem", setup() { const e = on(); return { slide: z(1), counterStore: e } } }), M_ = { class: "row" }, B_ = { class: "col-12" }, I_ = { class: "text-body1" }; function F_(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", M_, [V("div", B_, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [V("div", I_, [K(L_, { animated: "", style: { height: "90vh" }, modelValue: e.slide, "onUpdate:modelValue": t[0] || (t[0] = s => e.slide = s), arrows: "", navigation: "", infinite: "" }, { default: ae(() => [K(sn, { name: 1, "img-src": "gettyimages-1238783518-2048x2048.jpg" }), K(sn, { name: 2, "img-src": "gettyimages-1238782296-2048x2048.jpg" }), K(sn, { name: 3, "img-src": "gettyimages-186344200-2048x2048.jpg" }), K(sn, { name: 4, "img-src": "gettyimages-1034975746-2048x2048.jpg" }), K(sn, { name: 5, "img-src": "gettyimages-1043128656-2048x2048.jpg" }), K(sn, { name: 6, "img-src": "gettyimages-186344266-2048x2048.jpg" }), K(sn, { name: 7, "img-src": "gettyimages-LS017280-2048x2048.jpg" }), K(sn, { name: 8, "img-src": "gettyimages-558033781-2048x2048.jpg" }), K(sn, { name: 9, "img-src": "gettyimages-1238782233-2048x2048.jpg" })]), _: 1 }, 8, ["modelValue"])])]), _: 1 })]), _: 1 })])])]), _: 1 }) } var z_ = Mt($_, [["render", F_]]); const V_ = Ne({ name: "statueItem", setup() { return { counterStore: on() } } }), N_ = { class: "row" }, j_ = V("div", { class: "col-12 col-md-2" }, null, -1), D_ = { class: "col-12 col-md-8" }, H_ = V("div", { class: "col-12 col-md-2" }, null, -1), K_ = { class: "col-12" }, U_ = V("div", { class: "text-h6" }, " la Virgen del Socav\xF3n", -1), W_ = V("div", { class: "text-body1" }, [ie(" La Virgen del Socav\xF3n es una advocaci\xF3n de la Virgen Mar\xEDa que se venera en la ciudad de Oruro, Bolivia."), V("br"), ie(' Se celebra el s\xE1bado de carnaval, es la patrona de los mineros, adem\xE1s fue declarada "Patrona del Folklore Nacional" por ley de 12 de febrero de 1994.'), V("br"), ie(' Es venerada particularmente por los mineros, que le agradecen, y le piden que les d\xE9 su protecci\xF3n y que no les falten las riquezas minerales en los socavones de las minas. Cada a\xF1o es visitada el s\xE1bado de carnaval por m\xE1s de cuarenta mil bailarines, que despu\xE9s de haber recorrido m\xE1s de cinco kil\xF3metros bailando con fe y devoci\xF3n, terminan pasando de rodillas delante de su imagen. Su fiesta fue reconocido como "Obra Maestra del Patrimonio Oral e Intangible de la Humanidad" por la Unesco el 18 de mayo de 2001. ')], -1); function Q_(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", N_, [j_, V("div", D_, [K(Zi, { ratio: 16 / 9, src: "https://www.youtube.com/embed/gqu94MYh__Y" })]), H_, V("div", K_, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [U_]), _: 1 }), K(ze, null, { default: ae(() => [W_]), _: 1 })]), _: 1 })])])]), _: 1 }) } var G_ = Mt(V_, [["render", Q_]]); const Z_ = Ne({ name: "CulturaItem", setup() { return { counterStore: on() } } }), Y_ = { class: "row" }, J_ = { class: "col-12" }, X_ = V("div", { class: "text-body1" }, [V("div", { class: "text-h6" }, "Relatos de la Diablada y de los Incas dieron inicio a Primeras Jornadas Tur\xEDsticas"), ie(" Con los relatos de la Diablada y de los Incas comenzaron las Primeras Jornadas Tur\xEDsticas del Gobierno Aut\xF3nomo del Departamento de Oruro (Gador), estas actividades se realizaron en el hall de la instituci\xF3n, donde hasta el 1 de febrero se realizar\xE1n distintas presentaciones art\xEDsticas relacionadas con el Carnaval de Oruro, Obra Maestra del Patrimonio Oral e Intangible de la Humanidad."), V("br"), ie(' El relato de la Diablada fue representado por el bloque Prejuvenil de la Fraternidad Art\xEDstica y Cultural "La Diablada", denominados "Los P\xEDcaros", todos dirigidos por V\xEDctor Hugo Viscarra, \xE1ngel mayor de la instituci\xF3n folkl\xF3rica.'), V("br"), ie(" Jos\xE9 Pe\xF1aranda Villa G\xF3mez, vicepresidente de la Fraternidad, explic\xF3 que el relato tiene origen en los autos sacramentales, g\xE9neros dram\xE1ticos t\xEDpicos de la Inquisici\xF3n espa\xF1ola que fue impuesta en la parte andina cuando el cura Ladislao Montealegre adapta en 1700 sobre la invasi\xF3n de los diablos a la tierra."), V("br"), ie(" Rafael Ulises Pel\xE1ez transcribi\xF3 y teatraliz\xF3 la danza de la diablada que representa la lucha del bien y el mal, una pugna que comienza con la invasi\xF3n de los diablos por orden de Lucifer y luego la expiaci\xF3n de los siete pecados, la lujuria, la gula, la avaricia, la pereza, la ira, la envidia y la soberbia."), V("br"), V("div", { class: "text-h6" }, "RELATO DE LOS INCAS"), ie(' Posteriormente se realiz\xF3 la presentaci\xF3n del relato de los incas, teatralizaci\xF3n que estuvo a cargo de la Fraternidad "Hijos del Sol", Los Incas, que personificaron el pasaje hist\xF3rico universal de la conquista de los espa\xF1oles en la \xE9poca del incario.'), V("br"), ie(" El presidente de la instituci\xF3n folkl\xF3rica, Wilfredo Mendiola Mamani, explic\xF3 que el relato de los incas tiene una duraci\xF3n de aproximadamente cuatro horas, pero fue adaptado para cuarenta y cinco minutos."), V("br"), ie(' En la puesta en escena se represent\xF3 a personajes como Francisco Pizarro, Diego de Almagro, el padre dominico Vicente de Valverde, el cautivo Hu\xE1scar, Atahuallpa, Haylla Wisa, Mama Coya y el "chasqui".'), V("br"), ie(" La responsable del \xE1rea de promoci\xF3n tur\xEDstica, Tania Peredo, manifest\xF3 que el objetivo de las jornadas es mostrar el origen de las danzas que son parte del Carnaval porque cada una de ellas tiene su historia."), V("br"), ie(" De esta manera concluy\xF3 la primera jornada tur\xEDstica que proseguir\xE1 hoy en el hall de la Gobernaci\xF3n con las representaciones de la pisa de la uva relacionada con la danza de la morenada y la del significado de la danza de los Pujllay. Para el mi\xE9rcoles se program\xF3 la presentaci\xF3n de maestros del charango en una noche de cuerdas."), V("br"), ie(" Para el jueves se organiz\xF3 la presentaci\xF3n de maestros int\xE9rpretes de instrumentos de vientos en el que participar\xE1 el grupo aut\xF3ctono Sumaj Punchay."), V("br"), ie(' El viernes concluyen las jornadas con la presentaci\xF3n de los componentes de la Escuela Boliviana Intercultural de M\xFAsica "EBIM".'), V("br")], -1); function ew(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", Y_, [V("div", J_, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [X_]), _: 1 })]), _: 1 })])])]), _: 1 }) } var tw = Mt(Z_, [["render", ew]]); const nw = Ne({ name: "SocialItem", setup() { return { counterStore: on() } } }), ow = { class: "row" }, rw = { class: "col-12" }, iw = V("div", { class: "text-h6" }, "ACFO Carnaval de Oruro", -1), sw = { class: "text-body1" }, lw = { class: "row" }, aw = { class: "col-12 col-md-2 text-center" }, uw = { class: "col-12 col-md-2 text-center" }, cw = { class: "col-12 col-md-2 text-center" }, dw = { class: "col-12 col-md-2 text-center" }, fw = { class: "col-12 col-md-2 text-center" }; function hw(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", ow, [V("div", rw, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [iw]), _: 1 }), K(ze, null, { default: ae(() => [V("div", sw, [V("div", lw, [V("div", aw, [K(We, { color: "blue", push: "", icon: "fa-brands fa-facebook", style: { width: "150px" }, label: "Facebook" })]), V("div", uw, [K(We, { color: "pink", push: "", icon: "fa-brands fa-instagram", style: { width: "150px" }, label: "Instagram" })]), V("div", cw, [K(We, { color: "info", push: "", icon: "fa-brands fa-twitter", style: { width: "150px" }, label: "Twitter" })]), V("div", dw, [K(We, { color: "dark", push: "", icon: "fa-brands fa-tiktok", style: { width: "150px" }, label: "TikTok" })]), V("div", fw, [K(We, { color: "green", push: "", icon: "fa-brands fa-whatsapp", style: { width: "150px" }, label: "Whatsapp" })])])])]), _: 1 })]), _: 1 })])])]), _: 1 }) } var mw = Mt(nw, [["render", hw]]); const vw = Ne({ name: "ContacItem", setup() { return { counterStore: on() } } }), pw = { class: "row" }, gw = { class: "col-12" }, yw = V("div", { class: "text-h6" }, "ACFO Carnaval de Oruro", -1), bw = { class: "text-body1" }, _w = { class: "row" }, ww = { class: "col-12 col-md-6 text-center" }; function Cw(e, t, n, o, r, i) { return Oe(), Qe(nn, null, { default: ae(() => [V("div", pw, [V("div", gw, [K(St, null, { default: ae(() => [K(ze, null, { default: ae(() => [yw]), _: 1 }), K(ze, null, { default: ae(() => [V("div", bw, [V("div", _w, [V("div", ww, [K(We, { color: "green", push: "", icon: "fa-brands fa-whatsapp", style: { width: "500px" }, label: "Whatsapp (Amilkar Quispaya)" })])])])]), _: 1 })]), _: 1 })])])]), _: 1 }) } var xw = Mt(vw, [["render", Cw]]); const yc = { date: "####/##/##", datetime: "####/##/## ##:##", time: "##:##", fulltime: "##:##:##", phone: "(###) ### - ####", card: "#### #### #### ####" }, Ei = { "#": { pattern: "[\\d]", negate: "[^\\d]" }, S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" }, N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" }, A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: e => e.toLocaleUpperCase() }, a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: e => e.toLocaleLowerCase() }, X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: e => e.toLocaleUpperCase() }, x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: e => e.toLocaleLowerCase() } }, th = Object.keys(Ei); th.forEach(e => { Ei[e].regex = new RegExp(Ei[e].pattern) }); const kw = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + th.join("") + "])|(.)", "g"), bc = /[.*+?^${}()|[\]\\]/g, tt = String.fromCharCode(1), Sw = { mask: String, reverseFillMask: Boolean, fillMask: [Boolean, String], unmaskedValue: Boolean }; function Ew(e, t, n, o) { let r, i, s, l; const a = z(null), c = z(d()); function u() { return e.autogrow === !0 || ["textarea", "text", "search", "url", "tel", "password"].includes(e.type) } de(() => e.type + e.autogrow, h), de(() => e.mask, k => { if (k !== void 0) v(c.value, !0); else { const T = w(c.value); h(), e.modelValue !== T && t("update:modelValue", T) } }), de(() => e.fillMask + e.reverseFillMask, () => { a.value === !0 && v(c.value, !0) }), de(() => e.unmaskedValue, () => { a.value === !0 && v(c.value) }); function d() { if (h(), a.value === !0) { const k = g(w(e.modelValue)); return e.fillMask !== !1 ? S(k) : k } return e.modelValue } function f(k) { if (k < r.length) return r.slice(-k); let T = "", q = r; const F = q.indexOf(tt); if (F > -1) { for (let B = k - q.length; B > 0; B--)T += tt; q = q.slice(0, F) + T + q.slice(F) } return q } function h() { if (a.value = e.mask !== void 0 && e.mask.length > 0 && u(), a.value === !1) { l = void 0, r = "", i = ""; return } const k = yc[e.mask] === void 0 ? e.mask : yc[e.mask], T = typeof e.fillMask == "string" && e.fillMask.length > 0 ? e.fillMask.slice(0, 1) : "_", q = T.replace(bc, "\\$&"), F = [], B = [], j = []; let $ = e.reverseFillMask === !0, M = "", R = ""; k.replace(kw, (oe, Ce, ne, O, J) => { if (O !== void 0) { const ue = Ei[O]; j.push(ue), R = ue.negate, $ === !0 && (B.push("(?:" + R + "+)?(" + ue.pattern + "+)?(?:" + R + "+)?(" + ue.pattern + "+)?"), $ = !1), B.push("(?:" + R + "+)?(" + ue.pattern + ")?") } else if (ne !== void 0) M = "\\" + (ne === "\\" ? "" : ne), j.push(ne), F.push("([^" + M + "]+)?" + M + "?"); else { const ue = Ce !== void 0 ? Ce : J; M = ue === "\\" ? "\\\\\\\\" : ue.replace(bc, "\\\\$&"), j.push(ue), F.push("([^" + M + "]+)?" + M + "?") } }); const ee = new RegExp("^" + F.join("") + "(" + (M === "" ? "." : "[^" + M + "]") + "+)?" + (M === "" ? "" : "[" + M + "]*") + "$"), fe = B.length - 1, D = B.map((oe, Ce) => Ce === 0 && e.reverseFillMask === !0 ? new RegExp("^" + q + "*" + oe) : Ce === fe ? new RegExp("^" + oe + "(" + (R === "" ? "." : R) + "+)?" + (e.reverseFillMask === !0 ? "$" : q + "*")) : new RegExp("^" + oe)); s = j, l = oe => { const Ce = ee.exec(e.reverseFillMask === !0 ? oe : oe.slice(0, j.length)); Ce !== null && (oe = Ce.slice(1).join("")); const ne = [], O = D.length; for (let J = 0, ue = oe; J < O; J++) { const we = D[J].exec(ue); if (we === null) break; ue = ue.slice(we.shift().length), ne.push(...we) } return ne.length > 0 ? ne.join("") : oe }, r = j.map(oe => typeof oe == "string" ? oe : tt).join(""), i = r.split(tt).join(T) } function v(k, T, q) { const F = o.value, B = F.selectionEnd, j = F.value.length - B, $ = w(k); T === !0 && h(); const M = g($), R = e.fillMask !== !1 ? S(M) : M, ee = c.value !== R; F.value !== R && (F.value = R), ee === !0 && (c.value = R), document.activeElement === F && Ie(() => { if (R === i) { const D = e.reverseFillMask === !0 ? i.length : 0; F.setSelectionRange(D, D, "forward"); return } if (q === "insertFromPaste" && e.reverseFillMask !== !0) { const D = B - 1; _.right(F, D, D); return } if (["deleteContentBackward", "deleteContentForward"].indexOf(q) > -1) { const D = e.reverseFillMask === !0 ? B === 0 ? R.length > M.length ? 1 : 0 : Math.max(0, R.length - (R === i ? 0 : Math.min(M.length, j) + 1)) + 1 : B; F.setSelectionRange(D, D, "forward"); return } if (e.reverseFillMask === !0) if (ee === !0) { const D = Math.max(0, R.length - (R === i ? 0 : Math.min(M.length, j + 1))); D === 1 && B === 1 ? F.setSelectionRange(D, D, "forward") : _.rightReverse(F, D, D) } else { const D = R.length - j; F.setSelectionRange(D, D, "backward") } else if (ee === !0) { const D = Math.max(0, r.indexOf(tt), Math.min(M.length, B) - 1); _.right(F, D, D) } else { const D = B - 1; _.right(F, D, D) } }); const fe = e.unmaskedValue === !0 ? w(R) : R; String(e.modelValue) !== fe && n(fe, !0) } function x(k, T, q) { const F = g(w(k.value)); T = Math.max(0, r.indexOf(tt), Math.min(F.length, T)), k.setSelectionRange(T, q, "forward") } const _ = { left(k, T, q, F) { const B = r.slice(T - 1).indexOf(tt) === -1; let j = Math.max(0, T - 1); for (; j >= 0; j--)if (r[j] === tt) { T = j, B === !0 && T++; break } if (j < 0 && r[T] !== void 0 && r[T] !== tt) return _.right(k, 0, 0); T >= 0 && k.setSelectionRange(T, F === !0 ? q : T, "backward") }, right(k, T, q, F) { const B = k.value.length; let j = Math.min(B, q + 1); for (; j <= B; j++)if (r[j] === tt) { q = j; break } else r[j - 1] === tt && (q = j); if (j > B && r[q - 1] !== void 0 && r[q - 1] !== tt) return _.left(k, B, B); k.setSelectionRange(F ? T : q, q, "forward") }, leftReverse(k, T, q, F) { const B = f(k.value.length); let j = Math.max(0, T - 1); for (; j >= 0; j--)if (B[j - 1] === tt) { T = j; break } else if (B[j] === tt && (T = j, j === 0)) break; if (j < 0 && B[T] !== void 0 && B[T] !== tt) return _.rightReverse(k, 0, 0); T >= 0 && k.setSelectionRange(T, F === !0 ? q : T, "backward") }, rightReverse(k, T, q, F) { const B = k.value.length, j = f(B), $ = j.slice(0, q + 1).indexOf(tt) === -1; let M = Math.min(B, q + 1); for (; M <= B; M++)if (j[M - 1] === tt) { q = M, q > 0 && $ === !0 && q--; break } if (M > B && j[q - 1] !== void 0 && j[q - 1] !== tt) return _.leftReverse(k, B, B); k.setSelectionRange(F === !0 ? T : q, q, "forward") } }; function A(k) { if (t("keydown", k), Hi(k) === !0) return; const T = o.value, q = T.selectionStart, F = T.selectionEnd; if (k.keyCode === 37 || k.keyCode === 39) { const B = _[(k.keyCode === 39 ? "right" : "left") + (e.reverseFillMask === !0 ? "Reverse" : "")]; k.preventDefault(), B(T, q, F, k.shiftKey) } else k.keyCode === 8 && e.reverseFillMask !== !0 && q === F ? _.left(T, q, F, !0) : k.keyCode === 46 && e.reverseFillMask === !0 && q === F && _.rightReverse(T, q, F, !0) } function g(k) { if (k == null || k === "") return ""; if (e.reverseFillMask === !0) return m(k); const T = s; let q = 0, F = ""; for (let B = 0; B < T.length; B++) { const j = k[q], $ = T[B]; if (typeof $ == "string") F += $, j === $ && q++; else if (j !== void 0 && $.regex.test(j)) F += $.transform !== void 0 ? $.transform(j) : j, q++; else return F } return F } function m(k) { const T = s, q = r.indexOf(tt); let F = k.length - 1, B = ""; for (let j = T.length - 1; j >= 0 && F > -1; j--) { const $ = T[j]; let M = k[F]; if (typeof $ == "string") B = $ + B, M === $ && F--; else if (M !== void 0 && $.regex.test(M)) do B = ($.transform !== void 0 ? $.transform(M) : M) + B, F--, M = k[F]; while (q === j && M !== void 0 && $.regex.test(M)); else return B } return B } function w(k) { return typeof k != "string" || l === void 0 ? typeof k == "number" ? l("" + k) : k : l(k) } function S(k) { return i.length - k.length <= 0 ? k : e.reverseFillMask === !0 && k.length > 0 ? i.slice(0, -k.length) + k : k + i.slice(k.length) } return { innerValue: c, hasMask: a, moveCursorForPaste: x, updateMaskValue: v, onMaskedKeydown: A } } function qw(e, t) { function n() { const o = e.modelValue; try { const r = "DataTransfer" in window ? new DataTransfer : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0; return Object(o) === o && ("length" in o ? Array.from(o) : [o]).forEach(i => { r.items.add(i) }), { files: r.files } } catch { return { files: void 0 } } } return y(t === !0 ? () => { if (e.type === "file") return n() } : n) } var nh = qe({ name: "QInput", inheritAttrs: !1, props: { ...Wi, ...Sw, ...Gi, modelValue: { required: !1 }, shadowText: String, type: { type: String, default: "text" }, debounce: [String, Number], autogrow: Boolean, inputClass: [Array, String, Object], inputStyle: [Array, String, Object] }, emits: [...Hl, "paste", "change", "keydown", "animationend"], setup(e, { emit: t, attrs: n }) { const { proxy: o } = Ee(), { $q: r } = o, i = {}; let s = NaN, l, a, c = null, u; const d = z(null), f = Pf(e), { innerValue: h, hasMask: v, moveCursorForPaste: x, updateMaskValue: _, onMaskedKeydown: A } = Ew(e, t, ee, d), g = qw(e, !0), m = y(() => Er(h.value)), w = Af(M), S = Kl(), k = y(() => e.type === "textarea" || e.autogrow === !0), T = y(() => k.value === !0 || ["text", "search", "url", "tel", "password"].includes(e.type)), q = y(() => { const O = { ...S.splitAttrs.listeners.value, onInput: M, onPaste: $, onChange: D, onBlur: oe, onFocus: Gt }; return O.onCompositionstart = O.onCompositionupdate = O.onCompositionend = w, v.value === !0 && (O.onKeydown = A), e.autogrow === !0 && (O.onAnimationend = R), O }), F = y(() => { const O = { tabindex: 0, "data-autofocus": e.autofocus === !0 || void 0, rows: e.type === "textarea" ? 6 : void 0, "aria-label": e.label, name: f.value, ...S.splitAttrs.attributes.value, id: S.targetUid.value, maxlength: e.maxlength, disabled: e.disable === !0, readonly: e.readonly === !0 }; return k.value === !1 && (O.type = e.type), e.autogrow === !0 && (O.rows = 1), O }); de(() => e.type, () => { d.value && (d.value.value = e.modelValue) }), de(() => e.modelValue, O => { if (v.value === !0) { if (a === !0 && (a = !1, String(O) === s)) return; _(O) } else h.value !== O && (h.value = O, e.type === "number" && i.hasOwnProperty("value") === !0 && (l === !0 ? l = !1 : delete i.value)); e.autogrow === !0 && Ie(fe) }), de(() => e.autogrow, O => { O === !0 ? Ie(fe) : d.value !== null && n.rows > 0 && (d.value.style.height = "auto") }), de(() => e.dense, () => { e.autogrow === !0 && Ie(fe) }); function B() { Br(() => { const O = document.activeElement; d.value !== null && d.value !== O && (O === null || O.id !== S.targetUid.value) && d.value.focus({ preventScroll: !0 }) }) } function j() { d.value !== null && d.value.select() } function $(O) { if (v.value === !0 && e.reverseFillMask !== !0) { const J = O.target; x(J, J.selectionStart, J.selectionEnd) } t("paste", O) } function M(O) { if (!O || !O.target) return; if (e.type === "file") { t("update:modelValue", O.target.files); return } const J = O.target.value; if (O.target.qComposing === !0) { i.value = J; return } if (v.value === !0) _(J, !1, O.inputType); else if (ee(J), T.value === !0 && O.target === document.activeElement) { const { selectionStart: ue, selectionEnd: we } = O.target; ue !== void 0 && we !== void 0 && Ie(() => { O.target === document.activeElement && J.indexOf(O.target.value) === 0 && O.target.setSelectionRange(ue, we) }) } e.autogrow === !0 && fe() } function R(O) { t("animationend", O), fe() } function ee(O, J) { u = () => { c = null, e.type !== "number" && i.hasOwnProperty("value") === !0 && delete i.value, e.modelValue !== O && s !== O && (s = O, J === !0 && (a = !0), t("update:modelValue", O), Ie(() => { s === O && (s = NaN) })), u = void 0 }, e.type === "number" && (l = !0, i.value = O), e.debounce !== void 0 ? (c !== null && clearTimeout(c), i.value = O, c = setTimeout(u, e.debounce)) : u() } function fe() { requestAnimationFrame(() => { const O = d.value; if (O !== null) { const J = O.parentNode.style, { overflow: ue } = O.style; r.platform.is.firefox !== !0 && (O.style.overflow = "hidden"), J.marginBottom = O.scrollHeight - 1 + "px", O.style.height = "1px", O.style.height = O.scrollHeight + "px", O.style.overflow = ue, J.marginBottom = "" } }) } function D(O) { w(O), c !== null && (clearTimeout(c), c = null), u !== void 0 && u(), t("change", O.target.value) } function oe(O) { O !== void 0 && Gt(O), c !== null && (clearTimeout(c), c = null), u !== void 0 && u(), l = !1, a = !1, delete i.value, e.type !== "file" && setTimeout(() => { d.value !== null && (d.value.value = h.value !== void 0 ? h.value : "") }) } function Ce() { return i.hasOwnProperty("value") === !0 ? i.value : h.value !== void 0 ? h.value : "" } Re(() => { oe() }), et(() => { e.autogrow === !0 && fe() }), Object.assign(S, { innerValue: h, fieldClass: y(() => `q-${k.value === !0 ? "textarea" : "input"}` + (e.autogrow === !0 ? " q-textarea--autogrow" : "")), hasShadow: y(() => e.type !== "file" && typeof e.shadowText == "string" && e.shadowText.length > 0), inputRef: d, emitValue: ee, hasValue: m, floatingLabel: y(() => m.value === !0 || Er(e.displayValue)), getControl: () => b(k.value === !0 ? "textarea" : "input", { ref: d, class: ["q-field__native q-placeholder", e.inputClass], style: e.inputStyle, ...F.value, ...q.value, ...e.type !== "file" ? { value: Ce() } : g.value }), getShadowControl: () => b("div", { class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (k.value === !0 ? "" : " text-no-wrap") }, [b("span", { class: "invisible" }, Ce()), b("span", e.shadowText)]) }); const ne = Ul(S); return Object.assign(o, { focus: B, select: j, getNativeElement: () => d.value }), Ro(o, "nativeEl", () => d.value), ne } }); const Tw = Ne({ name: "PointItem", components: { GoogleMap: Yi, Polyline: Mf, Marker: $f, CustomControl: Gl }, setup() { const e = { url: "https://ruta.carnavaldeoruroacfo.org/", title: "Ruta del Carnaval de Oruro 2023", description: "Vive la experiencia del Carnaval de Oruro 2023", quote: "Vive la experiencia del Carnaval de Oruro 2023", hashtags: "Ruta,Carnaval,Oruro", twitterUser: "adimer" }, t = [{ network: "email", name: "Email", icon: "far fah fa-lg fa-envelope", color: "#333333" }, { network: "facebook", name: "Facebook", icon: "fab fah fa-lg fa-facebook-f", color: "#1877f2" }, { network: "skype", name: "Skype", icon: "fab fah fa-lg fa-skype", color: "#00aff0" }, { network: "sms", name: "SMS", icon: "far fah fa-lg fa-comment-dots", color: "#333333" }, { network: "telegram", name: "Telegram", icon: "fab fah fa-lg fa-telegram-plane", color: "#0088cc" }, { network: "twitter", name: "Twitter", icon: "fab fah fa-lg fa-twitter", color: "#1da1f2" }, { network: "whatsapp", name: "Whatsapp", icon: "fab fah fa-lg fa-whatsapp", color: "#25d366" }], n = on(), o = z([]), r = z([]), i = z([]), s = z(""), l = z(0), a = z(0), c = z(""), d = fr("https://sruta.carnavaldeoruroacfo.org/"), f = z(!1), h = z(!1), v = "https://bruta.carnavaldeoruroacfo.org/api/", x = { lat: -17.97, lng: -67.1111 }, A = { path: [{ lat: -17.9612296067391, lng: -67.10803475010364 }, { lat: -17.961445119004555, lng: -67.10603530174386 }, { lat: -17.96232282916619, lng: -67.10629282032106 }, { lat: -17.968323800452232, lng: -67.10788085154705 }, { lat: -17.971662120760836, lng: -67.10897768934925 }, { lat: -17.971242566549805, lng: -67.11073501577758 }, { lat: -17.970119969911718, lng: -67.11444757526542 }, { lat: -17.969288170678904, lng: -67.11418543294249 }, { lat: -17.96916065440438, lng: -67.11502699206409 }, { lat: -17.969895449728007, lng: -67.11526305075984 }, { lat: -17.969201476446962, lng: -67.11785969641318 }, { lat: -17.968323800452232, lng: -67.11760217783599 }, { lat: -17.968038044536293, lng: -67.1180742952275 }, { lat: -17.967323652515017, lng: -67.11785951304016 }, { lat: -17.96709912898689, lng: -67.11809575510893 }, { lat: -17.967242007761914, lng: -67.11841765333043 }, { lat: -17.967446120097293, lng: -67.11873955155191 }], geodesic: !1, clickable: !1, strokeColor: "#4998FB", strokeOpacity: .8, strokeWeight: 10 }, g = z(""), m = z(!1); return { keyApi: "AIzaSyDodySSKALGcAIxLK3Zo2tKa3pSbpbrGmw", type: g, boolAdmin: m, center: x, flightPath: A, sets: o, sets2: r, lat: l, lng: a, url: v, setDialog: f, set: s, sets1: i, store: n, sharing: e, networks: t, socket: d, setShowDialog: h, address: c } }, created() { this.type = this.$route.params.type, this.$route.params.admin === "admin" && (this.boolAdmin = !0), this.$watch(() => this.$route.params, (e, t) => { console.log(e), console.log(t), this.type = this.$route.params.type, this.setsGet() }), this.setsGet(), this.$api.get("sets").then(e => { this.sets2 = [], this.sets1 = [], e.data.forEach(t => { this.sets1.push({ label: t.name, value: t.id }), this.sets2.push({ lat: parseFloat(t.lat), lng: parseFloat(t.lng) }) }), this.set = this.sets1[0] }) }, methods: { pointCreate() { this.$api.post("point", { name: this.set, lat: this.lat, lng: this.lng, type: this.type }).then(e => { console.log(e), this.setDialog = !1, this.setsGet() }) }, setUpdate() { this.$q.loading.show(), this.$api.put(`sets/${this.set.value}`, { lat: this.lat, lng: this.lng }).then(e => { console.log(e.data), this.$q.loading.hide(), this.setDialog = !1 }) }, mapClick(e) { this.boolAdmin && (this.set = "", this.lat = e.latLng.lat(), this.lng = e.latLng.lng(), this.setDialog = !0) }, onDrag(e, t) { e.lat = t.latLng.lat(), e.lng = t.latLng.lng(), this.$api.put("point/" + e.id, { lat: t.latLng.lat(), lng: t.latLng.lng() }) }, setsGet() { this.$api.get("point/" + this.type).then(e => { this.sets = e.data }) }, onClick(e) { console.log(e); const t = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${e.lat},${e.lng}&key=AIzaSyDodySSKALGcAIxLK3Zo2tKa3pSbpbrGmw`; console.log(t), this.$api.get(t).then(n => { this.address = n.data.results }), this.setShowDialog = !0, this.set = e } } }), Pw = { class: "text-h6" }, Aw = { class: "text-subtitle2" }; function Ow(e, t, n, o, r, i) { const s = Pt("Polyline"), l = Pt("Marker"), a = Pt("ShareNetwork"), c = Pt("CustomControl"), u = Pt("GoogleMap"); return Oe(), Qe(nn, null, { default: ae(() => [K(u, { onClick: e.mapClick, "api-key": e.keyApi, style: { width: "100%", height: "85vh" }, center: e.center, zoom: 15 }, { default: ae(() => [K(s, { options: e.flightPath }, null, 8, ["options"]), (Oe(!0), Yt(Ue, null, po(e.sets, d => (Oe(), Qe(l, { onDragend: f => e.onDrag(d, f), onClick: f => e.onClick(d), class: "q-pa-none q-ma-none", key: d.id, options: { draggable: e.boolAdmin, position: { lat: parseFloat(d.lat), lng: parseFloat(d.lng) } } }, null, 8, ["onDragend", "onClick", "options"]))), 128)), K(c, { position: "TOP_RIGHT" }, { default: ae(() => [(Oe(!0), Yt(Ue, null, po(e.networks, d => (Oe(), Qe(a, { network: d.network, key: d.network, style: Ar([{ backgroundColor: d.color }, { "text-decoration": "none", border: "0px", margin: "0px", padding: "0px" }]), url: e.sharing.url, title: e.sharing.title, description: e.sharing.description, quote: e.sharing.quote, hashtags: e.sharing.hashtags, twitterUser: e.sharing.twitterUser }, { default: ae(() => [V("i", { class: Or(d.icon) }, null, 2)]), _: 2 }, 1032, ["network", "style", "url", "title", "description", "quote", "hashtags", "twitterUser"]))), 128))]), _: 1 })]), _: 1 }, 8, ["onClick", "api-key", "center"]), K(qo, { modelValue: e.setDialog, "onUpdate:modelValue": t[1] || (t[1] = d => e.setDialog = d) }, { default: ae(() => [K(St, null, { default: ae(() => [K(xi, { onSubmit: fi(e.pointCreate, ["prevent"]) }, { default: ae(() => [K(ze, { class: "row items-center q-pb-none" }, { default: ae(() => [V("div", Pw, "Colocar " + tr(e.type), 1), K(bi), Rt(K(We, { flat: "", icon: "close" }, null, 512), [[xn]])]), _: 1 }), K(ze, { class: "q-pt-none" }, { default: ae(() => [K(nh, { outlined: "", modelValue: e.set, "onUpdate:modelValue": t[0] || (t[0] = d => e.set = d), label: "Nombre" }, null, 8, ["modelValue"])]), _: 1 }), K(qr, { align: "right" }, { default: ae(() => [Rt(K(We, { flat: "", label: "Cancelar", color: "primary" }, null, 512), [[xn]]), K(We, { label: "Guardar", color: "primary", type: "submit" })]), _: 1 })]), _: 1 }, 8, ["onSubmit"])]), _: 1 })]), _: 1 }, 8, ["modelValue"]), K(qo, { modelValue: e.setShowDialog, "onUpdate:modelValue": t[2] || (t[2] = d => e.setShowDialog = d) }, { default: ae(() => [K(St, null, { default: ae(() => [K(xi, { onSubmit: fi(e.setUpdate, ["prevent"]) }, { default: ae(() => [K(ze, { class: "row items-center q-pb-none" }, { default: ae(() => [V("div", Aw, tr(e.set.name), 1), K(bi), Rt(K(We, { flat: "", icon: "close" }, null, 512), [[xn]])]), _: 1 }), K(ze, { class: "q-pt-none" }, { default: ae(() => [(Oe(!0), Yt(Ue, null, po(e.address, (d, f) => (Oe(), Yt("div", { class: "text-subtitle2", key: f }, [f <= 2 ? (Oe(), Yt(Ue, { key: 0 }, [ie(tr(d.formatted_address), 1)], 64)) : Lr("", !0)]))), 128))]), _: 1 }), K(qr, { align: "right" }, { default: ae(() => [Rt(K(We, { flat: "", label: "Cerrar", "text-color": "red", "no-caps": "", color: "primary" }, null, 512), [[xn]])]), _: 1 })]), _: 1 }, 8, ["onSubmit"])]), _: 1 })]), _: 1 }, 8, ["modelValue"])]), _: 1 }) } var Rw = Mt(Tw, [["render", Ow]]); const Lw = [{ path: "/", component: Cy, children: [{ path: "//:admin?", component: U0 }, { path: "carnaval", component: n_ }, { path: "especialidades", component: f_ }, { path: "sets", component: b_ }, { path: "photo", component: z_ }, { path: "statue", component: G_ }, { path: "cultura", component: tw }, { path: "social", component: mw }, { path: "contact", component: xw }, { path: "point/:type/:admin?", component: Rw }] }, { path: "/:catchAll(.*)*", component: () => ll(() => import("./ErrorNotFound.7b086db7.js"), []) }]; var Es = function () { return Ng({ scrollBehavior: () => ({ left: 0, top: 0 }), routes: Lw, history: og("/") }) }; async function $w(e, t) { const n = e(Rp); n.use(Pp, t); const o = typeof hs == "function" ? await hs({}) : hs; n.use(o); const r = it(typeof Es == "function" ? await Es({ store: o }) : Es); return o.use(({ store: i }) => { i.router = r }), { app: n, store: o, router: r } } var Mw = { isoName: "es", nativeName: "Espa\xF1ol", label: { clear: "Borrar", ok: "OK", cancel: "Cancelar", close: "Cerrar", set: "Establecer", select: "Seleccionar", reset: "Restablecer", remove: "Eliminar", update: "Actualizar", create: "Crear", search: "Buscar", filter: "Filtrar", refresh: "Actualizar", expand: e => e ? `Expandir "${e}"` : "Expandir", collapse: e => e ? `Ocultar "${e}"` : "Colapsar" }, date: { days: "Domingo_Lunes_Martes_Mi\xE9rcoles_Jueves_Viernes_S\xE1bado".split("_"), daysShort: "Dom_Lun_Mar_Mi\xE9_Jue_Vie_S\xE1b".split("_"), months: "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"), monthsShort: "Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic".split("_"), firstDayOfWeek: 1, format24h: !0, pluralDay: "dias" }, table: { noData: "Sin datos disponibles", noResults: "No se han encontrado resultados", loading: "Cargando...", selectedRecords: e => e > 1 ? e + " filas seleccionadas." : (e === 0 ? "Sin" : "1") + " fila seleccionada.", recordsPerPage: "Filas por p\xE1gina:", allRows: "Todas", pagination: (e, t, n) => e + "-" + t + " de " + n, columns: "Columnas" }, editor: { url: "URL", bold: "Negrita", italic: "It\xE1lico", strikethrough: "Tachado", underline: "Subrayado", unorderedList: "Lista Desordenada", orderedList: "Lista Ordenada", subscript: "Sub\xEDndice", superscript: "Super\xEDndice", hyperlink: "Hiperv\xEDnculo", toggleFullscreen: "Alternar pantalla completa", quote: "Cita", left: "Alineaci\xF3n izquierda", center: "Alineaci\xF3n centro", right: "Alineaci\xF3n derecha", justify: "Justificar alineaci\xF3n", print: "Imprimir", outdent: "Disminuir indentaci\xF3n", indent: "Aumentar indentaci\xF3n", removeFormat: "Eliminar formato", formatting: "Formato", fontSize: "Tama\xF1o de Fuente", align: "Alinear", hr: "Insertar l\xEDnea horizontal", undo: "Deshacer", redo: "Rehacer", heading1: "Encabezado 1", heading2: "Encabezado 2", heading3: "Encabezado 3", heading4: "Encabezado 4", heading5: "Encabezado 5", heading6: "Encabezado 6", paragraph: "P\xE1rrafo", code: "C\xF3digo", size1: "Muy peque\xF1o", size2: "Peque\xF1o", size3: "Normal", size4: "Mediano", size5: "Grande", size6: "Muy grande", size7: "M\xE1ximo", defaultFont: "Fuente por defecto", viewSource: "Ver fuente" }, tree: { noNodes: "Sin nodos disponibles", noResults: "No se encontraron nodos correspondientes" } }, Bw = qe({ name: "QAvatar", props: { ...Lo, fontSize: String, color: String, textColor: String, icon: String, square: Boolean, rounded: Boolean }, setup(e, { slots: t }) { const n = $o(e), o = y(() => "q-avatar" + (e.color ? ` bg-${e.color}` : "") + (e.textColor ? ` text-${e.textColor} q-chip--colored` : "") + (e.square === !0 ? " q-avatar--square" : e.rounded === !0 ? " rounded-borders" : "")), r = y(() => e.fontSize ? { fontSize: e.fontSize } : null); return () => { const i = e.icon !== void 0 ? [b(ct, { name: e.icon })] : void 0; return b("div", { class: o.value, style: n.value }, [b("div", { class: "q-avatar__content row flex-center overflow-hidden", style: r.value }, Jd(t.default, i))]) } } }); let Iw = 0; const si = {}, li = {}, zt = {}, oh = {}, Fw = /^\s*$/, rh = [], ta = ["top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right", "center"], zw = ["top-left", "top-right", "bottom-left", "bottom-right"], co = { positive: { icon: e => e.iconSet.type.positive, color: "positive" }, negative: { icon: e => e.iconSet.type.negative, color: "negative" }, warning: { icon: e => e.iconSet.type.warning, color: "warning", textColor: "dark" }, info: { icon: e => e.iconSet.type.info, color: "info" }, ongoing: { group: !1, timeout: 0, spinner: !0, color: "grey-8" } }; function ih(e, t, n) { if (!e) return Zo("parameter required"); let o; const r = { textColor: "white" }; if (e.ignoreDefaults !== !0 && Object.assign(r, si), At(e) === !1 && (r.type && Object.assign(r, co[r.type]), e = { message: e }), Object.assign(r, co[e.type || r.type], e), typeof r.icon == "function" && (r.icon = r.icon(t)), r.spinner ? (r.spinner === !0 && (r.spinner = So), r.spinner = it(r.spinner)) : r.spinner = !1, r.meta = { hasMedia: Boolean(r.spinner !== !1 || r.icon || r.avatar), hasText: _c(r.message) || _c(r.caption) }, r.position) { if (ta.includes(r.position) === !1) return Zo("wrong position", e) } else r.position = "bottom"; if (r.timeout === void 0) r.timeout = 5e3; else { const a = parseInt(r.timeout, 10); if (isNaN(a) || a < 0) return Zo("wrong timeout", e); r.timeout = a } r.timeout === 0 ? r.progress = !1 : r.progress === !0 && (r.meta.progressClass = "q-notification__progress" + (r.progressClass ? ` ${r.progressClass}` : ""), r.meta.progressStyle = { animationDuration: `${r.timeout + 1e3}ms` }); const i = (Array.isArray(e.actions) === !0 ? e.actions : []).concat(e.ignoreDefaults !== !0 && Array.isArray(si.actions) === !0 ? si.actions : []).concat(co[e.type] !== void 0 && Array.isArray(co[e.type].actions) === !0 ? co[e.type].actions : []), { closeBtn: s } = r; if (s && i.push({ label: typeof s == "string" ? s : t.lang.label.close }), r.actions = i.map(({ handler: a, noDismiss: c, ...u }) => ({ flat: !0, ...u, onClick: typeof a == "function" ? () => { a(), c !== !0 && l() } : () => { l() } })), r.multiLine === void 0 && (r.multiLine = r.actions.length > 1), Object.assign(r.meta, { class: `q-notification row items-stretch q-notification--${r.multiLine === !0 ? "multi-line" : "standard"}` + (r.color !== void 0 ? ` bg-${r.color}` : "") + (r.textColor !== void 0 ? ` text-${r.textColor}` : "") + (r.classes !== void 0 ? ` ${r.classes}` : ""), wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (r.multiLine === !0 ? "column no-wrap justify-center" : "row items-center"), contentClass: "q-notification__content row items-center" + (r.multiLine === !0 ? "" : " col"), leftClass: r.meta.hasText === !0 ? "additional" : "single", attrs: { role: "alert", ...r.attrs } }), r.group === !1 ? (r.group = void 0, r.meta.group = void 0) : ((r.group === void 0 || r.group === !0) && (r.group = [r.message, r.caption, r.multiline].concat(r.actions.map(a => `${a.label}*${a.icon}`)).join("|")), r.meta.group = r.group + "|" + r.position), r.actions.length === 0 ? r.actions = void 0 : r.meta.actionsClass = "q-notification__actions row items-center " + (r.multiLine === !0 ? "justify-end" : "col-auto") + (r.meta.hasMedia === !0 ? " q-notification__actions--with-media" : ""), n !== void 0) { n.notif.meta.timer && (clearTimeout(n.notif.meta.timer), n.notif.meta.timer = void 0), r.meta.uid = n.notif.meta.uid; const a = zt[r.position].value.indexOf(n.notif); zt[r.position].value[a] = r } else { const a = li[r.meta.group]; if (a === void 0) { if (r.meta.uid = Iw++, r.meta.badge = 1, ["left", "right", "center"].indexOf(r.position) !== -1) zt[r.position].value.splice(Math.floor(zt[r.position].value.length / 2), 0, r); else { const c = r.position.indexOf("top") > -1 ? "unshift" : "push"; zt[r.position].value[c](r) } r.group !== void 0 && (li[r.meta.group] = r) } else { if (a.meta.timer && (clearTimeout(a.meta.timer), a.meta.timer = void 0), r.badgePosition !== void 0) { if (zw.includes(r.badgePosition) === !1) return Zo("wrong badgePosition", e) } else r.badgePosition = `top-${r.position.indexOf("left") > -1 ? "right" : "left"}`; r.meta.uid = a.meta.uid, r.meta.badge = a.meta.badge + 1, r.meta.badgeClass = `q-notification__badge q-notification__badge--${r.badgePosition}` + (r.badgeColor !== void 0 ? ` bg-${r.badgeColor}` : "") + (r.badgeTextColor !== void 0 ? ` text-${r.badgeTextColor}` : "") + (r.badgeClass ? ` ${r.badgeClass}` : ""); const c = zt[r.position].value.indexOf(a); zt[r.position].value[c] = li[r.meta.group] = r } } const l = () => { Vw(r), o = void 0 }; if (r.timeout > 0 && (r.meta.timer = setTimeout(() => { r.meta.timer = void 0, l() }, r.timeout + 1e3)), r.group !== void 0) return a => { a !== void 0 ? Zo("trying to update a grouped one which is forbidden", e) : l() }; if (o = { dismiss: l, config: e, notif: r }, n !== void 0) { Object.assign(n, o); return } return a => { if (o !== void 0) if (a === void 0) o.dismiss(); else { const c = Object.assign({}, o.config, a, { group: !1, position: r.position }); ih(c, t, o) } } } function Vw(e) { e.meta.timer && (clearTimeout(e.meta.timer), e.meta.timer = void 0); const t = zt[e.position].value.indexOf(e); if (t !== -1) { e.group !== void 0 && delete li[e.meta.group]; const n = rh["" + e.meta.uid]; if (n) { const { width: o, height: r } = getComputedStyle(n); n.style.left = `${n.offsetLeft}px`, n.style.width = o, n.style.height = r } zt[e.position].value.splice(t, 1), typeof e.onDismiss == "function" && e.onDismiss() } } function _c(e) { return e != null && Fw.test(e) !== !0 } function Zo(e, t) { return console.error(`Notify: ${e}`, t), !1 } function Nw() { return qe({ name: "QNotifications", devtools: { hide: !0 }, setup() { return () => b("div", { class: "q-notifications" }, ta.map(e => b(Gv, { key: e, class: oh[e], tag: "div", name: `q-notification--${e}` }, () => zt[e].value.map(t => { const n = t.meta, o = []; if (n.hasMedia === !0 && (t.spinner !== !1 ? o.push(b(t.spinner, { class: "q-notification__spinner q-notification__spinner--" + n.leftClass, color: t.spinnerColor, size: t.spinnerSize })) : t.icon ? o.push(b(ct, { class: "q-notification__icon q-notification__icon--" + n.leftClass, name: t.icon, color: t.iconColor, size: t.iconSize, role: "img" })) : t.avatar && o.push(b(Bw, { class: "q-notification__avatar q-notification__avatar--" + n.leftClass }, () => b("img", { src: t.avatar, "aria-hidden": "true" })))), n.hasText === !0) { let i; const s = { class: "q-notification__message col" }; if (t.html === !0) s.innerHTML = t.caption ? `<div>${t.message}</div><div class="q-notification__caption">${t.caption}</div>` : t.message; else { const l = [t.message]; i = t.caption ? [b("div", l), b("div", { class: "q-notification__caption" }, [t.caption])] : l } o.push(b("div", s, i)) } const r = [b("div", { class: n.contentClass }, o)]; return t.progress === !0 && r.push(b("div", { key: `${n.uid}|p|${n.badge}`, class: n.progressClass, style: n.progressStyle })), t.actions !== void 0 && r.push(b("div", { class: n.actionsClass }, t.actions.map(i => b(We, i)))), n.badge > 1 && r.push(b("div", { key: `${n.uid}|${n.badge}`, class: t.meta.badgeClass, style: t.badgeStyle }, [n.badge])), b("div", { ref: i => { rh["" + n.uid] = i }, key: n.uid, class: n.class, ...n.attrs }, [b("div", { class: n.wrapperClass }, r)]) })))) } }) } var jw = { setDefaults(e) { At(e) === !0 && Object.assign(si, e) }, registerType(e, t) { At(t) === !0 && (co[e] = t) }, install({ $q: e, parentApp: t }) { if (e.notify = this.create = n => ih(n, e), e.notify.setDefaults = this.setDefaults, e.notify.registerType = this.registerType, e.config.notify !== void 0 && this.setDefaults(e.config.notify), this.__installed !== !0) { ta.forEach(o => { zt[o] = z([]); const r = ["left", "center", "right"].includes(o) === !0 ? "center" : o.indexOf("top") > -1 ? "top" : "bottom", i = o.indexOf("left") > -1 ? "start" : o.indexOf("right") > -1 ? "end" : "center", s = ["left", "right"].includes(o) ? `items-${o === "left" ? "start" : "end"} justify-center` : o === "center" ? "flex-center" : `items-${i}`; oh[o] = `q-notifications__list q-notifications__list--${r} fixed column no-wrap ${s}` }); const n = Qi("q-notify"); Ml(Nw(), t).mount(n) } } }; let ao, qs, wc = 0, $n = null, nt = {}, Dn = {}; const sh = { group: "__default_quasar_group__", delay: 0, message: !1, html: !1, spinnerSize: 80, spinnerColor: "", messageColor: "", backgroundColor: "", boxClass: "", spinner: So, customClass: "" }, lh = { ...sh }; function Dw(e) { if (e && e.group !== void 0 && Dn[e.group] !== void 0) return Object.assign(Dn[e.group], e); const t = At(e) === !0 && e.ignoreDefaults === !0 ? { ...sh, ...e } : { ...lh, ...e }; return Dn[t.group] = t, t } const Bt = $r({ isActive: !1 }, { show(e) { nt = Dw(e); const { group: t } = nt; return Bt.isActive = !0, ao !== void 0 ? (nt.uid = wc, qs.$forceUpdate()) : (nt.uid = ++wc, $n !== null && clearTimeout($n), $n = setTimeout(() => { $n = null; const n = Qi("q-loading"); ao = Ml({ name: "QLoading", setup() { et(() => { Js(!0) }); function o() { Bt.isActive !== !0 && ao !== void 0 && (Js(!1), ao.unmount(n), Wl(n), ao = void 0, qs = void 0) } function r() { if (Bt.isActive !== !0) return null; const i = [b(nt.spinner, { class: "q-loading__spinner", color: nt.spinnerColor, size: nt.spinnerSize })]; return nt.message && i.push(b("div", { class: "q-loading__message" + (nt.messageColor ? ` text-${nt.messageColor}` : ""), [nt.html === !0 ? "innerHTML" : "textContent"]: nt.message })), b("div", { class: "q-loading fullscreen flex flex-center z-max " + nt.customClass.trim(), key: nt.uid }, [b("div", { class: "q-loading__backdrop" + (nt.backgroundColor ? ` bg-${nt.backgroundColor}` : "") }), b("div", { class: "q-loading__box column items-center " + nt.boxClass }, i)]) } return () => b(fn, { name: "q-transition--fade", appear: !0, onAfterLeave: o }, r) } }, Bt.__parentApp), qs = ao.mount(n) }, nt.delay)), n => { if (n === void 0 || Object(n) !== n) { Bt.hide(t); return } Bt.show({ ...n, group: t }) } }, hide(e) { if (Bt.isActive === !0) { if (e === void 0) Dn = {}; else { if (Dn[e] === void 0) return; { delete Dn[e]; const t = Object.keys(Dn); if (t.length !== 0) { const n = t[t.length - 1]; Bt.show({ group: n }); return } } } $n !== null && (clearTimeout($n), $n = null), Bt.isActive = !1 } }, setDefaults(e) { At(e) === !0 && Object.assign(lh, e) }, install({ $q: e, parentApp: t }) { e.loading = this, Bt.__parentApp = t, e.config.loading !== void 0 && this.setDefaults(e.config.loading) } }), Hw = { true: "inset", item: "item-inset", "item-thumbnail": "item-thumbnail-inset" }, Ts = { xs: 2, sm: 4, md: 8, lg: 16, xl: 24 }; var Cc = qe({ name: "QSeparator", props: { ...Ut, spaced: [Boolean, String], inset: [Boolean, String], vertical: Boolean, color: String, size: String }, setup(e) { const t = Ee(), n = Wt(e, t.proxy.$q), o = y(() => e.vertical === !0 ? "vertical" : "horizontal"), r = y(() => ` q-separator--${o.value}`), i = y(() => e.inset !== !1 ? `${r.value}-${Hw[e.inset]}` : ""), s = y(() => `q-separator${r.value}${i.value}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (n.value === !0 ? " q-separator--dark" : "")), l = y(() => { const a = {}; if (e.size !== void 0 && (a[e.vertical === !0 ? "width" : "height"] = e.size), e.spaced !== !1) { const c = e.spaced === !0 ? `${Ts.md}px` : e.spaced in Ts ? `${Ts[e.spaced]}px` : e.spaced, u = e.vertical === !0 ? ["Left", "Right"] : ["Top", "Bottom"]; a[`margin${u[0]}`] = a[`margin${u[1]}`] = c } return a }); return () => b("hr", { class: s.value, style: l.value, "aria-orientation": o.value }) } }); function ah(e, t) { const n = z(null), o = y(() => e.disable === !0 ? null : b("span", { ref: n, class: "no-outline", tabindex: -1 })); function r(i) { const s = t.value; i !== void 0 && i.type.indexOf("key") === 0 ? s !== null && document.activeElement !== s && s.contains(document.activeElement) === !0 && s.focus() : n.value !== null && (i === void 0 || s !== null && s.contains(i.target) === !0) && n.value.focus() } return { refocusTargetEl: o, refocusTarget: r } } var uh = { xs: 30, sm: 35, md: 40, lg: 50, xl: 60 }; const Kw = b("svg", { key: "svg", class: "q-radio__bg absolute non-selectable", viewBox: "0 0 24 24" }, [b("path", { d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12" }), b("path", { class: "q-radio__check", d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6" })]); var Uw = qe({ name: "QRadio", props: { ...Ut, ...Lo, ...Gi, modelValue: { required: !0 }, val: { required: !0 }, label: String, leftLabel: Boolean, checkedIcon: String, uncheckedIcon: String, color: String, keepColor: Boolean, dense: Boolean, disable: Boolean, tabindex: [String, Number] }, emits: ["update:modelValue"], setup(e, { slots: t, emit: n }) { const { proxy: o } = Ee(), r = Wt(e, o.$q), i = $o(e, uh), s = z(null), { refocusTargetEl: l, refocusTarget: a } = ah(e, s), c = y(() => ke(e.modelValue) === ke(e.val)), u = y(() => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (e.disable === !0 ? " disabled" : "") + (r.value === !0 ? " q-radio--dark" : "") + (e.dense === !0 ? " q-radio--dense" : "") + (e.leftLabel === !0 ? " reverse" : "")), d = y(() => { const m = e.color !== void 0 && (e.keepColor === !0 || c.value === !0) ? ` text-${e.color}` : ""; return `q-radio__inner relative-position q-radio__inner--${c.value === !0 ? "truthy" : "falsy"}${m}` }), f = y(() => (c.value === !0 ? e.checkedIcon : e.uncheckedIcon) || null), h = y(() => e.disable === !0 ? -1 : e.tabindex || 0), v = y(() => { const m = { type: "radio" }; return e.name !== void 0 && Object.assign(m, { ".checked": c.value === !0, "^checked": c.value === !0 ? "checked" : void 0, name: e.name, value: e.val }), m }), x = Tf(v); function _(m) { m !== void 0 && (Be(m), a(m)), e.disable !== !0 && c.value !== !0 && n("update:modelValue", e.val, m) } function A(m) { (m.keyCode === 13 || m.keyCode === 32) && Be(m) } function g(m) { (m.keyCode === 13 || m.keyCode === 32) && _(m) } return Object.assign(o, { set: _ }), () => { const m = f.value !== null ? [b("div", { key: "icon", class: "q-radio__icon-container absolute-full flex flex-center no-wrap" }, [b(ct, { class: "q-radio__icon", name: f.value })])] : [Kw]; e.disable !== !0 && x(m, "unshift", " q-radio__native q-ma-none q-pa-none"); const w = [b("div", { class: d.value, style: i.value, "aria-hidden": "true" }, m)]; l.value !== null && w.push(l.value); const S = e.label !== void 0 ? Lt(t.default, [e.label]) : He(t.default); return S !== void 0 && w.push(b("div", { class: "q-radio__label q-anchor--skip" }, S)), b("div", { ref: s, class: u.value, tabindex: h.value, role: "radio", "aria-label": e.label, "aria-checked": c.value === !0 ? "true" : "false", "aria-disabled": e.disable === !0 ? "true" : void 0, onClick: _, onKeydown: A, onKeyup: g }, w) } } }); const ch = { ...Ut, ...Lo, ...Gi, modelValue: { required: !0, default: null }, val: {}, trueValue: { default: !0 }, falseValue: { default: !1 }, indeterminateValue: { default: null }, checkedIcon: String, uncheckedIcon: String, indeterminateIcon: String, toggleOrder: { type: String, validator: e => e === "tf" || e === "ft" }, toggleIndeterminate: Boolean, label: String, leftLabel: Boolean, color: String, keepColor: Boolean, dense: Boolean, disable: Boolean, tabindex: [String, Number] }, dh = ["update:modelValue"]; function fh(e, t) { const { props: n, slots: o, emit: r, proxy: i } = Ee(), { $q: s } = i, l = Wt(n, s), a = z(null), { refocusTargetEl: c, refocusTarget: u } = ah(n, a), d = $o(n, uh), f = y(() => n.val !== void 0 && Array.isArray(n.modelValue)), h = y(() => { const $ = ke(n.val); return f.value === !0 ? n.modelValue.findIndex(M => ke(M) === $) : -1 }), v = y(() => f.value === !0 ? h.value > -1 : ke(n.modelValue) === ke(n.trueValue)), x = y(() => f.value === !0 ? h.value === -1 : ke(n.modelValue) === ke(n.falseValue)), _ = y(() => v.value === !1 && x.value === !1), A = y(() => n.disable === !0 ? -1 : n.tabindex || 0), g = y(() => `q-${e} cursor-pointer no-outline row inline no-wrap items-center` + (n.disable === !0 ? " disabled" : "") + (l.value === !0 ? ` q-${e}--dark` : "") + (n.dense === !0 ? ` q-${e}--dense` : "") + (n.leftLabel === !0 ? " reverse" : "")), m = y(() => { const $ = v.value === !0 ? "truthy" : x.value === !0 ? "falsy" : "indet", M = n.color !== void 0 && (n.keepColor === !0 || (e === "toggle" ? v.value === !0 : x.value !== !0)) ? ` text-${n.color}` : ""; return `q-${e}__inner relative-position non-selectable q-${e}__inner--${$}${M}` }), w = y(() => { const $ = { type: "checkbox" }; return n.name !== void 0 && Object.assign($, { ".checked": v.value, "^checked": v.value === !0 ? "checked" : void 0, name: n.name, value: f.value === !0 ? n.val : n.trueValue }), $ }), S = Tf(w), k = y(() => { const $ = { tabindex: A.value, role: e === "toggle" ? "switch" : "checkbox", "aria-label": n.label, "aria-checked": _.value === !0 ? "mixed" : v.value === !0 ? "true" : "false" }; return n.disable === !0 && ($["aria-disabled"] = "true"), $ }); function T($) { $ !== void 0 && (Be($), u($)), n.disable !== !0 && r("update:modelValue", q(), $) } function q() { if (f.value === !0) { if (v.value === !0) { const $ = n.modelValue.slice(); return $.splice(h.value, 1), $ } return n.modelValue.concat([n.val]) } if (v.value === !0) { if (n.toggleOrder !== "ft" || n.toggleIndeterminate === !1) return n.falseValue } else if (x.value === !0) { if (n.toggleOrder === "ft" || n.toggleIndeterminate === !1) return n.trueValue } else return n.toggleOrder !== "ft" ? n.trueValue : n.falseValue; return n.indeterminateValue } function F($) { ($.keyCode === 13 || $.keyCode === 32) && Be($) } function B($) { ($.keyCode === 13 || $.keyCode === 32) && T($) } const j = t(v, _); return Object.assign(i, { toggle: T }), () => { const $ = j(); n.disable !== !0 && S($, "unshift", ` q-${e}__native absolute q-ma-none q-pa-none`); const M = [b("div", { class: m.value, style: d.value, "aria-hidden": "true" }, $)]; c.value !== null && M.push(c.value); const R = n.label !== void 0 ? Lt(o.default, [n.label]) : He(o.default); return R !== void 0 && M.push(b("div", { class: `q-${e}__label q-anchor--skip` }, R)), b("div", { ref: a, class: g.value, ...k.value, onClick: T, onKeydown: F, onKeyup: B }, M) } } const Ww = b("div", { key: "svg", class: "q-checkbox__bg absolute" }, [b("svg", { class: "q-checkbox__svg fit absolute-full", viewBox: "0 0 24 24" }, [b("path", { class: "q-checkbox__truthy", fill: "none", d: "M1.73,12.91 8.1,19.28 22.79,4.59" }), b("path", { class: "q-checkbox__indet", d: "M4,14H20V10H4" })])]); var Qw = qe({ name: "QCheckbox", props: ch, emits: dh, setup(e) { function t(n, o) { const r = y(() => (n.value === !0 ? e.checkedIcon : o.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || null); return () => r.value !== null ? [b("div", { key: "icon", class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap" }, [b(ct, { class: "q-checkbox__icon", name: r.value })])] : [Ww] } return fh("checkbox", t) } }), Gw = qe({ name: "QToggle", props: { ...ch, icon: String, iconColor: String }, emits: dh, setup(e) { function t(n, o) { const r = y(() => (n.value === !0 ? e.checkedIcon : o.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || e.icon), i = y(() => n.value === !0 ? e.iconColor : null); return () => [b("div", { class: "q-toggle__track" }), b("div", { class: "q-toggle__thumb absolute flex flex-center no-wrap" }, r.value !== void 0 ? [b(ct, { name: r.value, color: i.value })] : void 0)] } return fh("toggle", t) } }); const hh = { radio: Uw, checkbox: Qw, toggle: Gw }, Zw = Object.keys(hh); var Yw = qe({ name: "QOptionGroup", props: { ...Ut, modelValue: { required: !0 }, options: { type: Array, validator: e => e.every(t => "value" in t && "label" in t) }, name: String, type: { default: "radio", validator: e => Zw.includes(e) }, color: String, keepColor: Boolean, dense: Boolean, size: String, leftLabel: Boolean, inline: Boolean, disable: Boolean }, emits: ["update:modelValue"], setup(e, { emit: t, slots: n }) { const { proxy: { $q: o } } = Ee(), r = Array.isArray(e.modelValue); e.type === "radio" ? r === !0 && console.error("q-option-group: model should not be array") : r === !1 && console.error("q-option-group: model should be array in your case"); const i = Wt(e, o), s = y(() => hh[e.type]), l = y(() => "q-option-group q-gutter-x-sm" + (e.inline === !0 ? " q-option-group--inline" : "")), a = y(() => { const u = { role: "group" }; return e.type === "radio" && (u.role = "radiogroup", e.disable === !0 && (u["aria-disabled"] = "true")), u }); function c(u) { t("update:modelValue", u) } return () => b("div", { class: l.value, ...a.value }, e.options.map((u, d) => { const f = n["label-" + d] !== void 0 ? () => n["label-" + d](u) : n.label !== void 0 ? () => n.label(u) : void 0; return b("div", [b(s.value, { modelValue: e.modelValue, val: u.value, name: u.name === void 0 ? e.name : u.name, disable: e.disable || u.disable, label: f === void 0 ? u.label : null, leftLabel: u.leftLabel === void 0 ? e.leftLabel : u.leftLabel, color: u.color === void 0 ? e.color : u.color, checkedIcon: u.checkedIcon, uncheckedIcon: u.uncheckedIcon, dark: u.dark || i.value, size: u.size === void 0 ? e.size : u.size, dense: e.dense, keepColor: u.keepColor === void 0 ? e.keepColor : u.keepColor, "onUpdate:modelValue": c }, f)]) })) } }), Jw = qe({ name: "DialogPlugin", props: { ...Ut, title: String, message: String, prompt: Object, options: Object, progress: [Boolean, Object], html: Boolean, ok: { type: [String, Object, Boolean], default: !0 }, cancel: [String, Object, Boolean], focus: { type: String, default: "ok", validator: e => ["ok", "cancel", "none"].includes(e) }, stackButtons: Boolean, color: String, cardClass: [String, Array, Object], cardStyle: [String, Array, Object] }, emits: ["ok", "hide"], setup(e, { emit: t }) { const { proxy: n } = Ee(), { $q: o } = n, r = Wt(e, o), i = z(null), s = z(e.prompt !== void 0 ? e.prompt.model : e.options !== void 0 ? e.options.model : void 0), l = y(() => "q-dialog-plugin" + (r.value === !0 ? " q-dialog-plugin--dark q-dark" : "") + (e.progress !== !1 ? " q-dialog-plugin--progress" : "")), a = y(() => e.color || (r.value === !0 ? "amber" : "primary")), c = y(() => e.progress === !1 ? null : At(e.progress) === !0 ? { component: e.progress.spinner || So, props: { color: e.progress.color || a.value } } : { component: So, props: { color: a.value } }), u = y(() => e.prompt !== void 0 || e.options !== void 0), d = y(() => { if (u.value !== !0) return {}; const { model: R, isValid: ee, items: fe, ...D } = e.prompt !== void 0 ? e.prompt : e.options; return D }), f = y(() => At(e.ok) === !0 || e.ok === !0 ? o.lang.label.ok : e.ok), h = y(() => At(e.cancel) === !0 || e.cancel === !0 ? o.lang.label.cancel : e.cancel), v = y(() => e.prompt !== void 0 ? e.prompt.isValid !== void 0 && e.prompt.isValid(s.value) !== !0 : e.options !== void 0 ? e.options.isValid !== void 0 && e.options.isValid(s.value) !== !0 : !1), x = y(() => ({ color: a.value, label: f.value, ripple: !1, disable: v.value, ...At(e.ok) === !0 ? e.ok : { flat: !0 }, "data-autofocus": e.focus === "ok" && u.value !== !0 || void 0, onClick: m })), _ = y(() => ({ color: a.value, label: h.value, ripple: !1, ...At(e.cancel) === !0 ? e.cancel : { flat: !0 }, "data-autofocus": e.focus === "cancel" && u.value !== !0 || void 0, onClick: w })); de(() => e.prompt && e.prompt.model, k), de(() => e.options && e.options.model, k); function A() { i.value.show() } function g() { i.value.hide() } function m() { t("ok", ke(s.value)), g() } function w() { g() } function S() { t("hide") } function k(R) { s.value = R } function T(R) { v.value !== !0 && e.prompt.type !== "textarea" && en(R, 13) === !0 && m() } function q(R, ee) { return e.html === !0 ? b(ze, { class: R, innerHTML: ee }) : b(ze, { class: R }, () => ee) } function F() { return [b(nh, { color: a.value, dense: !0, autofocus: !0, dark: r.value, ...d.value, modelValue: s.value, "onUpdate:modelValue": k, onKeyup: T })] } function B() { return [b(Yw, { color: a.value, options: e.options.items, dark: r.value, ...d.value, modelValue: s.value, "onUpdate:modelValue": k })] } function j() { const R = []; return e.cancel && R.push(b(We, _.value)), e.ok && R.push(b(We, x.value)), b(qr, { class: e.stackButtons === !0 ? "items-end" : "", vertical: e.stackButtons, align: "right" }, () => R) } function $() { const R = []; return e.title && R.push(q("q-dialog__title", e.title)), e.progress !== !1 && R.push(b(ze, { class: "q-dialog__progress" }, () => b(c.value.component, c.value.props))), e.message && R.push(q("q-dialog__message", e.message)), e.prompt !== void 0 ? R.push(b(ze, { class: "scroll q-dialog-plugin__form" }, F)) : e.options !== void 0 && R.push(b(Cc, { dark: r.value }), b(ze, { class: "scroll q-dialog-plugin__form" }, B), b(Cc, { dark: r.value })), (e.ok || e.cancel) && R.push(j()), R } function M() { return [b(St, { class: [l.value, e.cardClass], style: e.cardStyle, dark: r.value }, $)] } return Object.assign(n, { show: A, hide: g }), () => b(qo, { ref: i, onHide: S }, M) } }); function mh(e, t) { for (const n in t) n !== "spinner" && Object(t[n]) === t[n] ? (e[n] = Object(e[n]) !== e[n] ? {} : { ...e[n] }, mh(e[n], t[n])) : e[n] = t[n] } function Xw(e, t, n) { return o => { let r, i; const s = t === !0 && o.component !== void 0; if (s === !0) { const { component: g, componentProps: m } = o; r = typeof g == "string" ? n.component(g) : g, i = m || {} } else { const { class: g, style: m, ...w } = o; r = e, i = w, g !== void 0 && (w.cardClass = g), m !== void 0 && (w.cardStyle = m) } let l, a = !1; const c = z(null), u = Qi(!1, "dialog"), d = g => { if (c.value !== null && c.value[g] !== void 0) { c.value[g](); return } const m = l.$.subTree; if (m && m.component) { if (m.component.proxy && m.component.proxy[g]) { m.component.proxy[g](); return } if (m.component.subTree && m.component.subTree.component && m.component.subTree.component.proxy && m.component.subTree.component.proxy[g]) { m.component.subTree.component.proxy[g](); return } } console.error("[Quasar] Incorrectly defined Dialog component") }, f = [], h = [], v = { onOk(g) { return f.push(g), v }, onCancel(g) { return h.push(g), v }, onDismiss(g) { return f.push(g), h.push(g), v }, hide() { return d("hide"), v }, update(g) { if (l !== null) { if (s === !0) Object.assign(i, g); else { const { class: m, style: w, ...S } = g; m !== void 0 && (S.cardClass = m), w !== void 0 && (S.cardStyle = w), mh(i, S) } l.$forceUpdate() } return v } }, x = g => { a = !0, f.forEach(m => { m(g) }) }, _ = () => { A.unmount(u), Wl(u), A = null, l = null, a !== !0 && h.forEach(g => { g() }) }; let A = Ml({ name: "QGlobalDialog", setup: () => () => b(r, { ...i, ref: c, onOk: x, onHide: _, onVnodeMounted(...g) { typeof i.onVnodeMounted == "function" && i.onVnodeMounted(...g), Ie(() => d("show")) } }) }, n); return l = A.mount(u), v } } var e1 = { install({ $q: e, parentApp: t }) { e.dialog = Xw(Jw, !0, t), this.__installed !== !0 && (this.create = e.dialog) } }, t1 = { config: {}, lang: Mw, plugins: { Notify: jw, Loading: Bt, Dialog: e1 } }, n1 = function () { return Boolean(window.location.hostname === "localhost" || window.location.hostname === "[::1]" || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)) }, sl; typeof window != "undefined" && (typeof Promise != "undefined" ? sl = new Promise(function (e) { return window.addEventListener("load", e) }) : sl = { then: function (e) { return window.addEventListener("load", e) } }); function o1(e, t) { t === void 0 && (t = {}); var n = t.registrationOptions; n === void 0 && (n = {}), delete t.registrationOptions; var o = function (r) { for (var i = [], s = arguments.length - 1; s-- > 0;)i[s] = arguments[s + 1]; t && t[r] && t[r].apply(t, i) }; "serviceWorker" in navigator && sl.then(function () { n1() ? (r1(e, o, n), navigator.serviceWorker.ready.then(function (r) { o("ready", r) }).catch(function (r) { return Pr(o, r) })) : (vh(e, o, n), navigator.serviceWorker.ready.then(function (r) { o("ready", r) }).catch(function (r) { return Pr(o, r) })) }) } function Pr(e, t) { navigator.onLine || e("offline"), e("error", t) } function vh(e, t, n) { navigator.serviceWorker.register(e, n).then(function (o) { if (t("registered", o), o.waiting) { t("updated", o); return } o.onupdatefound = function () { t("updatefound", o); var r = o.installing; r.onstatechange = function () { r.state === "installed" && (navigator.serviceWorker.controller ? t("updated", o) : t("cached", o)) } } }).catch(function (o) { return Pr(t, o) }) } function r1(e, t, n) { fetch(e).then(function (o) { o.status === 404 ? (t("error", new Error("Service worker not found at " + e)), xc()) : o.headers.get("content-type").indexOf("javascript") === -1 ? (t("error", new Error("Expected " + e + " to have javascript content-type, but received " + o.headers.get("content-type"))), xc()) : vh(e, t, n) }).catch(function (o) { return Pr(t, o) }) } function xc() { "serviceWorker" in navigator && navigator.serviceWorker.ready.then(function (e) { e.unregister() }).catch(function (e) { return Pr(emit, e) }) } o1("/sw.js", { ready() { }, registered() { }, cached() { }, updatefound() { }, updated() { }, offline() { }, error() { } }); /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream && window.navigator.standalone && ll(() => import("./fastclick.8a4a8267.js"), []); const i1 = "/"; async function s1({ app: e, router: t, store: n }, o) { let r = !1; const i = a => { try { return t.resolve(a).href } catch { } return Object(a) === a ? null : a }, s = a => { if (r = !0, typeof a == "string" && /^https?:\/\//.test(a)) { window.location.href = a; return } const c = i(a); c !== null && (window.location.href = c) }, l = window.location.href.replace(window.location.origin, ""); for (let a = 0; r === !1 && a < o.length; a++)try { await o[a]({ app: e, router: t, store: n, ssrContext: null, redirect: s, urlPath: l, publicPath: i1 }) } catch (c) { if (c && c.url) { s(c.url); return } console.error("[Quasar] boot error:", c); return } r !== !0 && (e.use(t), e.mount("#q-app")) } $w(qd, t1).then(e => { const [t, n] = Promise.allSettled !== void 0 ? ["allSettled", o => o.map(r => { if (r.status === "rejected") { console.error("[Quasar] boot error:", r.reason); return } return r.value.default })] : ["all", o => o.map(r => r.default)]; return Promise[t]([ll(() => import("./axios.446b4976.js"), [])]).then(o => { const r = n(o).filter(i => typeof i == "function"); s1(e, r) }) }); export { We as Q, Mt as _, V as a, l1 as b, Yt as c, Ne as d, K as e, Oe as o };
